---
number: 5657
title: "fix(doctor): preserve env var placeholders in config file during --fix"
author: Salt-Sunny
created: 2026-01-31T19:55:22Z
updated: 2026-02-01T13:46:13Z
labels: ["commands"]
additions: 234
deletions: 10
changed_files: 8
size: large
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 3
reactions_total: 1
ci_status: passing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/5657
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## üêõ Bug Fix
\`openclaw doctor --fix\` was incorrectly substituting environment variable placeholders (e.g., \`${API_KEY}\`) with their resolved values, causing secrets to be hardcoded into config files.

## üîß Changes
- Added \`template\` property to \`ConfigFileSnapshot\` type to preserve original config with placeholders
- Modified \`readConfigFileSnapshot\` to populate both resolved config (runtime) and template (write-back)
- Updated doctor command to operate on template instead of resolved config during \`--fix\`
- Added comprehensive test in \`doctor-env-var-placeholder.test.ts\`

## üß™ Testing
- [x] New test verifies placeholders are preserved after \`doctor --fix\`
- [x] Existing doctor tests pass
- [x] Runtime behavior unchanged (env vars still resolve for actual use)

## ü¶û Lobster Checklist
- [x] Small bug fix (no architecture changes)
- [x] Includes test
- [x] Security improvement (prevents secret leakage)

Fixes: #

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR prevents `openclaw doctor --fix` from writing resolved `${VAR}` values back into config files by introducing a `template` snapshot (placeholders preserved) alongside the runtime `config` (placeholders substituted). `doctor` now writes repairs using the template, and a new `restoreConfigEnvVars()` helper reconstitutes placeholders during write-back. A new Vitest suite exercises placeholder preservation and removal of invalid keys.

Main concern: there are still other code paths that write config (e.g. security auto-fix) that appear to call `writeConfigFile` without the `template`, which can reintroduce the same secret-hardcoding behavior.

<h3>Confidence Score: 3/5</h3>

- Mostly safe to merge, but it likely leaves at least one config-writing path still capable of hardcoding resolved secrets.
- Core change (doctor using template + restore on write) aligns with the stated security goal and is covered by targeted tests. However, other callers (e.g. security fixes) still write config without passing a template, which can reintroduce the regression in common workflows. There‚Äôs also some inconsistency in how `template` is populated on env-substitution failure paths in `readConfigFileSnapshot()`.
- src/security/fix.ts, src/config/io.ts

<!-- greptile_other_comments_section -->

<sub>(2/5) Greptile learns from your feedback when you react with thumbs up/down!</sub>

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews

### @greptile-apps ‚Äî COMMENTED (2026-01-31)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-01-31)

<details>
<summary>Additional Comments (2)</summary>

**`src/security/fix.ts`**
[P1] `fixSecurityFootguns()` will still hardcode resolved secrets when it writes the config, because it calls `io.writeConfigFile(fixed.cfg)` without passing the new `template` snapshot. This PR fixes `doctor --fix`, but this path can reintroduce the same secret-leak regression if users store placeholders in config.

Consider passing `snap.template` (or otherwise restoring placeholders) when writing here.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/security/fix.ts
Line: 495:498

Comment:
[P1] `fixSecurityFootguns()` will still hardcode resolved secrets when it writes the config, because it calls `io.writeConfigFile(fixed.cfg)` without passing the new `template` snapshot. This PR fixes `doctor --fix`, but this path can reintroduce the same secret-leak regression if users store placeholders in config.

Consider passing `snap.template` (or otherwise restoring placeholders) when writing here.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/config/io.ts`**
[P1] On env var substitution failure, `readConfigFileSnapshot()` currently sets `template` to the *resolved include* object (`template: coerceConfig(resolved)`), not the original config-with-placeholders. If the failure is due to a missing env var referenced by `${...}`, `resolved` still contains placeholders and you lose the distinction between template vs substituted config (and `config` is also set to `coerceConfig(resolved)` in this branch). That can make downstream code treat a placeholder-containing snapshot as a fully resolved runtime config.

You may want `template` to always be the pre-substitution object, and `config` to reflect the best-effort substituted output (or at least make this branch consistent with the intent of `template`).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/config/io.ts
Line: 410:427

Comment:
[P1] On env var substitution failure, `readConfigFileSnapshot()` currently sets `template` to the *resolved include* object (`template: coerceConfig(resolved)`), not the original config-with-placeholders. If the failure is due to a missing env var referenced by `${...}`, `resolved` still contains placeholders and you lose the distinction between template vs substituted config (and `config` is also set to `coerceConfig(resolved)` in this branch). That can make downstream code treat a placeholder-containing snapshot as a fully resolved runtime config.

You may want `template` to always be the pre-substitution object, and `config` to reflect the best-effort substituted output (or at least make this branch consistent with the intent of `template`).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @Salt-Sunny (2026-01-31)

Addressed review comments:
1. Updated `fixSecurityFootguns` in `src/security/fix.ts` to pass the template snapshot to `writeConfigFile`.
2. Improved `readConfigFileSnapshot` in `src/config/io.ts` to handle substitution/include failures more consistently (setting `template` to the pre-substitution object and `config` to an empty/safe state).

### @Salt-Sunny (2026-01-31)

Pushed one more update: added a regression test in `src/security/fix.test.ts` to verify that placeholders are also preserved during the security auto-fix (`fixSecurityFootguns`) path. All paths should now be secure! ü¶û


## Stats

- **Size:** large (234+, 10-, 8 files)
- **Age:** 2 days
- **Last activity:** 2026-02-01

## Links

- Fixes: (none detected)
