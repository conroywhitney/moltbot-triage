---
number: 7719
title: "fix(slack): thread replies with @mentions dropped in requireMention channels"
author: SocialNerd42069
created: 2026-02-03T04:31:22Z
updated: 2026-02-03T04:53:58Z
labels: ["channel: slack", "docker", "agents"]
additions: 267
deletions: 16
changed_files: 8
size: large
review_decision: none
reviews: [{"author":"chatgpt-codex-connector","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 1
reactions_total: 1
ci_status: failing
mergeable: true
draft: false
url: https://github.com/openclaw/openclaw/pull/7719
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Problem

Thread replies containing explicit `@bot` mentions in `requireMention: true` Slack channels are silently dropped. The bot never receives or processes these messages.

## Root Cause

`markMessageSeen` (dedup cache) was called **before** the mention gate check in `prepare.ts`. When Slack fires both `message` and `app_mention` events for the same thread reply:

1. `message` event arrives first ‚Üí fails `requireMention` check ‚Üí **but still marks the message as seen**
2. `app_mention` event arrives with `wasMentioned: true` ‚Üí **deduped by `markMessageSeen`** ‚Üí silently dropped

Net result: the user's @mention vanishes completely.

## Fix

**Moved `markMessageSeen` to after mention gating** in `prepare.ts`:
- Messages are only marked "seen" if they pass all checks (channel allowed, mention gate, etc.)
- If a `message` event fails the mention check, it's NOT marked as seen
- The subsequent `app_mention` event can then pass through with `wasMentioned: true`

**Added `dedupeSlackInboundEntries`** in the debouncer flush:
- Handles the case where both events pass through within the debounce window
- Dedupes by `ts`, preferring the entry with `wasMentioned: true`

## Tests

- 2 new test files, 5 tests covering the dedup logic and the mention-gate ordering
- All existing tests continue to pass

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR fixes a Slack ingestion edge case in `requireMention` channels where a thread reply could be dropped if Slack emits both `message` and `app_mention` events: the first event failed mention gating but still marked the message as ‚Äúseen‚Äù, causing the later `app_mention` to be deduped.

The change moves the dedup-cache `markMessageSeen` call into `prepareSlackMessage` after allowlist/mention gating, and adds `dedupeSlackInboundEntries` during debounce flush to collapse multiple inbound events for the same Slack timestamp, preferring entries that were explicitly marked as mentioned. Tests were added to cover the mention-gate ordering and the dedupe preference behavior.

One merge-safety concern remains: the debounce key currently includes a `senderId` derived from `user ?? bot_id`, which may differ between `message` vs `app_mention` events for the same underlying Slack message. If those events land in different debounce buckets, `dedupeSlackInboundEntries` won‚Äôt see both and the ‚Äúprefer mentioned‚Äù behavior may not apply consistently.

<h3>Confidence Score: 4/5</h3>

- This PR is likely safe to merge, with one plausible edge case that could reduce the effectiveness of the new inbound dedupe.
- The behavioral change (moving markMessageSeen after mention gating and adding an in-flush dedupe) is localized and covered by new tests. The main remaining risk is that `buildKey` derives `senderId` from `user ?? bot_id`, which may differ between Slack `message` and `app_mention` events for the same message; if so, the two events won‚Äôt be coalesced in the same debounce window and the new `dedupeSlackInboundEntries` preference logic won‚Äôt apply consistently.
- src/slack/monitor/message-handler.ts

<!-- greptile_other_comments_section -->

<sub>(5/5) You can turn off certain types of comments like style [here](https://app.greptile.com/review/github)!</sub>

<!-- /greptile_comment -->

## Reviews

### @chatgpt-codex-connector ‚Äî COMMENTED (2026-02-03)


### üí° Codex Review

Here are some automated review suggestions for this pull request.

**Reviewed commit:** `2206050ac7`
    

<details> <summary>‚ÑπÔ∏è About Codex in GitHub</summary>
<br/>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you
- Open a pull request for review
- Mark a draft as ready
- Comment "@codex review".

If Codex has suggestions, it will comment; otherwise it will react with üëç.




Codex can also answer questions or update the PR. Try commenting "@codex address that feedback".
            
</details>

### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>1 file reviewed, 1 comment</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/slack/monitor/message-handler.ts`**
[P1] Debounce key may split the same user message across different senderIds

In `buildKey`, the sender id is `user ?? bot_id` (line ~65), but Slack can emit the same underlying message as both a `message` event (with `user`) and an `app_mention` event (where `user` may be missing but `bot_id` is set). In that case the same message can end up in *different* debounce buckets, so the new `dedupeSlackInboundEntries` in `onFlush` won‚Äôt see both entries and you can still double-process (or miss the intended ‚Äúprefer mentioned‚Äù behavior).

This matters specifically for the scenario described in the PR (message + app_mention for the same thread reply). Consider keying only on `message.user` (when present), or falling back to a stable `authorizations[0].user_id`/`event.user` equivalent if available in your `SlackMessageEvent` shape, rather than `bot_id`.

Also appears relevant to `src/slack/monitor/message-handler/prepare.mention-dedupe.test.ts` which currently doesn‚Äôt exercise this split-key scenario.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/slack/monitor/message-handler.ts
Line: 69:76

Comment:
[P1] Debounce key may split the same user message across different senderIds

In `buildKey`, the sender id is `user ?? bot_id` (line ~65), but Slack can emit the same underlying message as both a `message` event (with `user`) and an `app_mention` event (where `user` may be missing but `bot_id` is set). In that case the same message can end up in *different* debounce buckets, so the new `dedupeSlackInboundEntries` in `onFlush` won‚Äôt see both entries and you can still double-process (or miss the intended ‚Äúprefer mentioned‚Äù behavior).

This matters specifically for the scenario described in the PR (message + app_mention for the same thread reply). Consider keying only on `message.user` (when present), or falling back to a stable `authorizations[0].user_id`/`event.user` equivalent if available in your `SlackMessageEvent` shape, rather than `bot_id`.

Also appears relevant to `src/slack/monitor/message-handler/prepare.mention-dedupe.test.ts` which currently doesn‚Äôt exercise this split-key scenario.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** large (267+, 16-, 8 files)
- **Age:** 0 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
