---
number: 2780
title: "feat(channels): Add WeChat Official Account support via Bridge"
author: NannaOlympicBroadcast
created: 2026-01-27T14:00:14Z
updated: 2026-02-02T12:03:14Z
labels: []
additions: 11169
deletions: 0
changed_files: 8
size: huge
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"xueshuai0922","state":"COMMENTED"}]
comments_count: 3
reactions_total: 3
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/2780
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

**Description:**

This PR introduces a new extension `@haiyanfengli-llc/webhook-server` that adds support for **WeChat Official Accounts** (Weixin Service/Subscription Accounts).

It works by exposing a webhook server that interfaces with a self-hosted [WeChat Bridge](https://github.com/NannaOlympicBroadcast/clawdbot-wechat-plugin), allowing Clawdbot to send and receive messages from WeChat users.

**Key Changes:**
- Added `extensions/wechat` with the plugin implementation.
- Implemented `fastify` server for efficient webhook handling.
- Added full documentation in [`PLUGIN_USAGE.md`](extensions/wechat/PLUGIN_USAGE.md).

**AI/Vibe-Coded:**
- [x] **AI-Assisted**: Yes (Google Antigravity)
- [x] **Degree of Testing**: Lightly tested (Verified with local WeChat Bridge and test account)
- [x] **Understanding**: Confirmed (I understand how the webhook/bridge architecture works)

**Related Links:**
- [Companion Bridge Repository](https://github.com/NannaOlympicBroadcast/clawdbot-wechat-plugin)

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR adds a new `extensions/wechat` package that registers a WeChat channel plugin and an HTTP webhook handler, then routes inbound webhook messages into the existing channel reply pipeline and posts responses back to a Bridge callback URL.

Key concerns are around webhook hardening and correctness of configuration/routing defaults: the new handler reads request bodies without any size limit and does not authenticate requests, and the fallback route/config paths appear inconsistent (`plugins.entries.webhook-server` vs `channels.wechat`). These issues could lead to the server being remotely driven by anyone who can reach it, memory exhaustion from large requests, and misrouting to the default agent even when configured.

<h3>Confidence Score: 2/5</h3>

- This PR has significant security and reliability risks if the webhook endpoint is exposed beyond a trusted network.
- The core integration approach matches existing channel patterns, but the webhook handler lacks request authentication and enforces no request size limit, which can enable unauthorized triggering of agent actions and memory exhaustion. There are also config/ID mismatches that can cause misrouting or confusing configuration.
- extensions/wechat/src/index.ts; extensions/wechat/clawdbot.plugin.json

<!-- greptile_other_comments_section -->

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-01)

<sub>1 file reviewed, 5 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @greptile-apps — COMMENTED (2026-02-01)

<sub>2 files reviewed, 5 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @xueshuai0922 — COMMENTED (2026-02-02)




## Comments

### @sebslight (2026-01-28)

Closing: Large PRs (1000+ lines) require prior alignment with maintainers before submission. Please:

1. Open an issue first to discuss the feature/change
2. Get maintainer buy-in on the approach
3. Consider breaking into smaller, reviewable PRs

We appreciate your interest in contributing, but reviewing massive unaligned PRs is not sustainable. Feel free to reopen after discussing the approach in an issue.

### @steipete (2026-02-01)

I concur here - having WeChat support would be great! What we need is ideally a plugin like this and also someone who can setup up and test/further develop it.

### @greptile-apps (2026-02-01)

<details>
<summary>Additional Comments (5)</summary>

**`extensions/clawdbot-plugin-webhook-server/src/index.ts`**
[P1] Unused imports and unused declared types likely cause `tsc` failures under `noUnusedLocals`/`noUnusedParameters`.

`normalizeAccountId`, `MarkdownTableMode`, `WeChatConfig`, `CoreRuntime`, and `fromLabel` are never referenced in this file, so if the repo/extension enforces unused checks this will fail CI builds. Consider removing the unused imports/types/vars or using them.

Also appears in: `extensions/clawdbot-plugin-webhook-server/src/index.ts` (unused `z` if `configSchema` is removed/refactored).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/clawdbot-plugin-webhook-server/src/index.ts
Line: 1:3

Comment:
[P1] Unused imports and unused declared types likely cause `tsc` failures under `noUnusedLocals`/`noUnusedParameters`.

`normalizeAccountId`, `MarkdownTableMode`, `WeChatConfig`, `CoreRuntime`, and `fromLabel` are never referenced in this file, so if the repo/extension enforces unused checks this will fail CI builds. Consider removing the unused imports/types/vars or using them.

Also appears in: `extensions/clawdbot-plugin-webhook-server/src/index.ts` (unused `z` if `configSchema` is removed/refactored).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`extensions/clawdbot-plugin-webhook-server/src/index.ts`**
[P0] `readJsonBody` has no request size limit, so a large POST body can consume unbounded memory.

Since this is an HTTP-exposed webhook handler, an attacker (or misconfigured bridge) can send a very large payload and force buffering into `chunks`, potentially causing OOM. Consider enforcing a max body size (and returning 413) or using the host server’s body parser with limits.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/clawdbot-plugin-webhook-server/src/index.ts
Line: 44:52

Comment:
[P0] `readJsonBody` has no request size limit, so a large POST body can consume unbounded memory.

Since this is an HTTP-exposed webhook handler, an attacker (or misconfigured bridge) can send a very large payload and force buffering into `chunks`, potentially causing OOM. Consider enforcing a max body size (and returning 413) or using the host server’s body parser with limits.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`extensions/clawdbot-plugin-webhook-server/src/index.ts`**
[P0] Webhook endpoint accepts any POST without authenticating the sender.

The plugin defines `authToken` in config/manifest, but `handleWebhookRequest` does not validate an Authorization header, signature, or source IP. This allows anyone who can reach the endpoint to inject messages into the agent pipeline and trigger outbound callbacks. At minimum, validate a shared secret (e.g., `Authorization: Bearer <token>`) against config before accepting the request.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/clawdbot-plugin-webhook-server/src/index.ts
Line: 69:76

Comment:
[P0] Webhook endpoint accepts any POST without authenticating the sender.

The plugin defines `authToken` in config/manifest, but `handleWebhookRequest` does not validate an Authorization header, signature, or source IP. This allows anyone who can reach the endpoint to inject messages into the agent pipeline and trigger outbound callbacks. At minimum, validate a shared secret (e.g., `Authorization: Bearer <token>`) against config before accepting the request.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`extensions/clawdbot-plugin-webhook-server/src/index.ts`**
[P1] `accountId`/agent routing ignores the configured account selection and always uses `DEFAULT_ACCOUNT_ID`.

If users configure multiple WeChat accounts or set `defaultAccount`, inbound messages will still be attributed to the default account, which can route to the wrong agent/session. Consider resolving `accountId` from config (e.g. `channels.wechat.defaultAccount`) or request metadata instead of hardcoding `DEFAULT_ACCOUNT_ID`.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/clawdbot-plugin-webhook-server/src/index.ts
Line: 108:116

Comment:
[P1] `accountId`/agent routing ignores the configured account selection and always uses `DEFAULT_ACCOUNT_ID`.

If users configure multiple WeChat accounts or set `defaultAccount`, inbound messages will still be attributed to the default account, which can route to the wrong agent/session. Consider resolving `accountId` from config (e.g. `channels.wechat.defaultAccount`) or request metadata instead of hardcoding `DEFAULT_ACCOUNT_ID`.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`extensions/clawdbot-plugin-webhook-server/src/index.ts`**
[P0] `callback_url` is used directly for outbound requests, enabling SSRF if the webhook payload is attacker-controlled.

`deliverWeChatReply` will `axios.post(callbackUrl, ...)` where `callbackUrl` can come from the inbound payload (`payload.callback_url`). If this endpoint is reachable by untrusted clients, they can force requests to internal services (e.g. `http://localhost`, cloud metadata IPs). Prefer using only the configured callback URL (from `channels.wechat.config.callbackUrl` / account config) or strictly validate/allowlist callback hosts.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/clawdbot-plugin-webhook-server/src/index.ts
Line: 146:154

Comment:
[P0] `callback_url` is used directly for outbound requests, enabling SSRF if the webhook payload is attacker-controlled.

`deliverWeChatReply` will `axios.post(callbackUrl, ...)` where `callbackUrl` can come from the inbound payload (`payload.callback_url`). If this endpoint is reachable by untrusted clients, they can force requests to internal services (e.g. `http://localhost`, cloud metadata IPs). Prefer using only the configured callback URL (from `channels.wechat.config.callbackUrl` / account config) or strictly validate/allowlist callback hosts.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** huge (11169+, 0-, 8 files)
- **Age:** 6 days
- **Last activity:** 2026-02-02

## Links

- Fixes: (none detected)
