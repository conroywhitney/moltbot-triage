---
number: 6095
title: "feat(gateway): support modular guardrails extensions for securing against indirect prompt injections and other agentic threats"
author: Reapor-Yurnero
created: 2026-02-01T08:30:55Z
updated: 2026-02-03T03:55:13Z
labels: ["docs", "gateway", "agents"]
additions: 5352
deletions: 109
changed_files: 35
size: huge
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"},{"author":"Reapor-Yurnero","state":"COMMENTED"}]
comments_count: 11
reactions_total: 4
ci_status: pending
mergeable: true
draft: false
url: https://github.com/openclaw/openclaw/pull/6095
fixes_issues: []
related_prs: [2340,4011,4278,4840,5155,5513,5922,5923,5924,5943,6264,6405,6459,6486,6535,6569,6592,6613,6660,6823]
duplicate_of: null
---

## Description

# Modular Guardrail / Validators / Interceptors via Plugin Hooks

## Summary
Introduces configurable pre- and post-message guardrail plugin system for monitoring all LLM traffic so that users can incorporate their guardrail of choice to block indirect prompt injection attacks and other policy violations. Initial selections are the open-weight gpt-oss-safeguard and cloud-based Gray Swan Cygnal, but any guardrail model can be configured similarly as a plugin. In addition to these model based guardrail, rule-based validators or monitors are also supported in this plugin based interface. Updates documentation, tests, and onboarding workflow to make configuration easy.

## Why
OpenClaw is an agent with deep access to tools, files, networks, and external accounts. That makes **prompt‑level attacks (especially indirect prompt injection / IPI)** uniquely dangerous: a single malicious message or web page can steer an agent into data exfiltration, unsafe tool use, or policy bypass. The broader community has been paying increasing attention to these risks as more systems move from chatbots to tool‑enabled agents (see the below relevant PRs/issues)

Critically, OpenClaw needs **defense‑in‑depth** that can:
- inspect inputs before the model sees them,
- validate tool calls/results,
- and scrutinize final outputs for risky behavior.
More importantly, all these should be **fully customizable** according to each user’s **needs** and desired **policies**.

This PR adds the minimal core hooks required for this protection and shows four diverse model‑based and non‑model guardrails via plugins.

## Example effects:
- Policy-violating request being blocked in Slack by GPT-OSS-20B
<img width="600" height="220" alt="slack example 1(a policy violation)" src="https://github.com/user-attachments/assets/31137032-5f0b-4198-8a57-797e40dbf652" />

- Prompt injection attempt being blocked in Slack by Gray Swan Cygnal
<img width="600" height="330" alt="slack example 2 (a prompt injection)" src="https://github.com/user-attachments/assets/8926636c-8462-45ca-906d-00557c132f73" />

- Unsafe tool call being rejected
<img width="600" height="380" alt="an example that a tool call being rejected due to policy violation" src="https://github.com/user-attachments/assets/e3b41b6d-c426-4fde-88cd-5c0db4d6d172" />

- Tool response with indirect prompt injections are marked
<img width="600" alt="image" src="https://github.com/user-attachments/assets/479ddc72-965e-4a7a-a864-4ed030e26d6d" />



## What this PR does
- Adds **minimal core wiring** so guardrails can run at the right lifecycle stages via the existing plugin hook system.
- Provides a **generic, extensible, and super flexible guardrail interface** that supports both model-based and non‑model validators/rule checkers etc..
- Demonstrates the approach with **four guardrail plugins**:
  - `extensions/grayswan-cygnal-guardrail` (API-based model guardrail)
  - `extensions/gpt-oss-safeguard` (open‑weight model guardrail)
  - `extensions/command-safety-guard` (rule-based command validator for `exec`)
  - `extensions/security-audit` (rule-based tool-call audit/monitoring)
(The latter two were proposed by @pauloportella in #6569) 

## Core changes (kept minimal yet essential)
- New hook stages for non‑tool guardrails: `before_request`, `after_response`  
  `src/plugins/types.ts`, `src/plugins/hooks.ts`
- Guardrail hook execution + block handling in the agent loop  
  `src/agents/pi-embedded-runner/run/attempt.ts`, `src/agents/pi-embedded-runner/run.ts`
- Tool hook context wiring for guardrails  
  `src/agents/pi-tool-definition-adapter.ts`, `src/agents/pi-embedded-runner/tool-split.ts`, `src/agents/pi-tools.before-tool-call.ts`
- Guardrail helper/factory utilities for consistent plugin behavior  
  `src/plugins/guardrails-utils.ts`, `src/plugins/guardrails-utils.test.ts`, `src/plugin-sdk/index.ts`
- Docs: guardrail usage + examples  
  `docs/gateway/guardrails.md`

## Rationale for maintainers
This PR keeps core changes narrowly scoped to hook types and wiring; most of the guardrail logic lives in extensions. The result is a flexible guardrail surface with minimal risk to existing behavior. Also, happy to decompose the extensions to subPRs etc. if needed. Putting here more for demonstration purposes.

## Testing
- `pnpm lint`
- `pnpm format`
- `pnpm test`
- `pnpm build`

## AI assistance
- **AI-assisted:** Yes (Codex CLI)
- **Testing:** `pnpm lint`, `pnpm build`
- **Prompts/logs:** available on request
- **Understanding:** I’ve reviewed the changes and understand the code


# Issues that this would close

- Fixes [Proposal: E2E Security Test Harness for Prompt Injection Detection #4011](https://github.com/openclaw/openclaw/issues/4011)
- Fixes [Feature: Runtime prompt injection defenses #4840](https://github.com/openclaw/openclaw/issues/4840)
- Fixes [[Feature]: Security Evaluation Harness Integration #5155](https://github.com/openclaw/openclaw/issues/5155)
- Fixes [Plugin hooks (agent_end, before_tool_call, etc.) are never invoked #5513](https://github.com/openclaw/openclaw/issues/5513)
- Fixes [Wire up before_tool_call plugin hook in tool execution pipeline #5943](https://github.com/openclaw/openclaw/issues/5943)
- Fixes [Feature: Exec denylist for dangerous commands (defense-in-depth) #6459](https://github.com/openclaw/openclaw/issues/6459)
- Fixes [Feature: Add tool:before / exec:before hook event for pre-execution interception #6613](https://github.com/openclaw/openclaw/issues/6613)
- Fixes [Feature Request: Execution Guardrails for Tool Safety #6823](https://github.com/openclaw/openclaw/issues/6823)
- Related to [Plugin hooks exist in type system but some are never called in execution flow #6535](https://github.com/openclaw/openclaw/issues/6535)
- Fixes [Feature Request: Tool execution hook events - tool:before, tool:after #7597](https://github.com/openclaw/openclaw/issues/7597)

# Ongoing PRs that this would replace

- Static prompt injection checks, PII filters, and dangerous command denylists can now be included with extensions/hooks
  - [fix(security): add input encoding detection and obfuscation decoder #5923](https://github.com/openclaw/openclaw/pull/5923)
  - [fix(security): add advanced multi-turn attack detection #5924](https://github.com/openclaw/openclaw/pull/5924)
  - [feat(security): add exec command denylist for defense-in-depth #6486](https://github.com/openclaw/openclaw/pull/6486)
  - [Security: guardrails audit + external content improvements #6592](https://github.com/openclaw/openclaw/pull/6592)
  - [Security: add hardening module and secure-bot extension #7346](https://github.com/openclaw/openclaw/pull/7346)
- Docs/system prompts around prompt injection security that shouldn’t be baked into core
  - [docs: add prompt-guard security skill recommendation #4278](https://github.com/openclaw/openclaw/pull/4278) - guardrails solutions should be plugins, not skills
  - [fix(security): add instruction confidentiality directive to system prompt #5922](https://github.com/openclaw/openclaw/pull/5922) - base system prompts can have extra security guidance added in via extension if desired, shouldn’t be baked in to this degree
- Fixing before_tool_call and after_tool_call plugin hooks to actually be called
  - [Agent tool call hooks now fire during tool execution #2340](https://github.com/openclaw/openclaw/pull/2340)
  - [Wire up before_tool_call and after_tool_call hooks in agent execution loop #6264](https://github.com/openclaw/openclaw/pull/6264)
  - Note that [#6660 Fix before_tool_call hook execution](https://github.com/openclaw/openclaw/pull/6660) fixed before_tool_call but not yet after_tool_call
- Using hooks system to allow for modular security guardrails plugins
  - [feat(security): Add HTTP API security hooks for plugin scanning #6405](https://github.com/openclaw/openclaw/pull/6405) - this introduces a new parallel HTTP hooks system that can likely better be handled within the existing hooks system
  - [feat: interceptor pipeline for tool, message, and params events #6569](https://github.com/openclaw/openclaw/pull/6569/) - this introduces a parallel “interceptor” system instead of using existing hooks

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR wires a modular “guardrails” plugin system into the agent lifecycle by adding new hook stages (`before_request`, `after_response`) and expanding the existing tool hooks to support inspection, mutation, and blocking (including returning synthetic tool results). The embedded runner now executes these hooks around model calls, and the tool definition adapter invokes `before_tool_call`/`after_tool_call` with richer context (messages/system prompt). New guardrail utilities and example extensions demonstrate model-based and rule-based guardrails.

Key review focus areas were correctness of hook result merging and the stability of event contracts (IDs/context) across call sites, since plugins will depend heavily on these semantics.

<h3>Confidence Score: 3/5</h3>

- This PR is reasonably safe to merge, but there are a couple of behavioral edge cases in hook/guardrail semantics that could surprise plugin authors.
- Core wiring looks coherent and tests exist, but the tool hook result-merging logic can leak prior handlers’ synthetic results, and the toolCallId handling has a type/behavior mismatch that could hide real correlation issues. These are fixable without redesigning the feature.
- src/plugins/hooks.ts, src/agents/pi-tool-definition-adapter.ts, src/agents/pi-embedded-runner/run/attempt.ts

<!-- greptile_other_comments_section -->

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-01)

<sub>2 files reviewed, 3 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @greptile-apps — COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @greptile-apps — COMMENTED (2026-02-03)

<sub>3 files reviewed, 3 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @greptile-apps — COMMENTED (2026-02-03)

<sub>4 files reviewed, 4 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @greptile-apps — COMMENTED (2026-02-03)

<sub>3 files reviewed, 5 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @greptile-apps — COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @Reapor-Yurnero — COMMENTED (2026-02-03)



### @Reapor-Yurnero — COMMENTED (2026-02-03)




## Comments

### @nwinter (2026-02-03)

@greptileai can you re-review?

### @Reapor-Yurnero (2026-02-03)

@greptileai your comments were addressed. can you re-review?

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/agents/pi-tool-definition-adapter.ts`**
[P2] `isAbortSignal()` / `isLegacyToolExecuteArgs()` detection is very loose: `isAbortSignal` only checks for an object with an `aborted` property, so any params object with an `aborted` key can be misclassified as an AbortSignal. That can cause `splitToolExecuteArgs` to treat the call as legacy and shuffle arguments incorrectly.

This matters if any tool’s execute signature changes or if third arg can be a plain object; mis-splitting here would produce hard-to-debug runtime failures.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/agents/pi-tool-definition-adapter.ts
Line: 68:76

Comment:
[P2] `isAbortSignal()` / `isLegacyToolExecuteArgs()` detection is very loose: `isAbortSignal` only checks for an object with an `aborted` property, so any params object with an `aborted` key can be misclassified as an AbortSignal. That can cause `splitToolExecuteArgs` to treat the call as legacy and shuffle arguments incorrectly.

This matters if any tool’s execute signature changes or if third arg can be a plain object; mis-splitting here would produce hard-to-debug runtime failures.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @Reapor-Yurnero (2026-02-03)

@greptileai your comments were addressed. current design princinple is to minimize modifications to the core components to reduce maintainer's load. can you re-review?

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (2)</summary>

**`extensions/command-safety-guard/index.ts`**
[P1] `configSchema` is being overwritten with `emptyPluginConfigSchema()` despite having a detailed schema in `openclaw.plugin.json`.

Because `createGuardrailPlugin` already returns a plugin object with a schema (and the extension has `openclaw.plugin.json`), setting `configSchema: emptyPluginConfigSchema()` here will likely disable runtime/UI validation for `extraPatterns`, `allowPatterns`, `disabledRules`, `stages`, etc., and make misconfigurations harder to catch.

If the schema should come from `openclaw.plugin.json`, consider removing this override entirely (or using the real schema helper instead of `emptyPluginConfigSchema`).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/command-safety-guard/index.ts
Line: 940:945

Comment:
[P1] `configSchema` is being overwritten with `emptyPluginConfigSchema()` despite having a detailed schema in `openclaw.plugin.json`.

Because `createGuardrailPlugin` already returns a plugin object with a schema (and the extension has `openclaw.plugin.json`), setting `configSchema: emptyPluginConfigSchema()` here will likely disable runtime/UI validation for `extraPatterns`, `allowPatterns`, `disabledRules`, `stages`, etc., and make misconfigurations harder to catch.

If the schema should come from `openclaw.plugin.json`, consider removing this override entirely (or using the real schema helper instead of `emptyPluginConfigSchema`).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`extensions/gpt-oss-safeguard/index.ts`**
[P1] `configSchema` is set to `emptyPluginConfigSchema()` even though this plugin exposes many config options (`provider`, `model`, `stages`, etc.) and `openclaw.plugin.json` defines a full schema.

Overriding the schema here likely prevents config validation and UI hints from reflecting the actual shape, which can lead to silent misconfigurations. If the schema is meant to be sourced from `openclaw.plugin.json`, drop this override (or wire the real schema into `configSchema`).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: extensions/gpt-oss-safeguard/index.ts
Line: 1654:1658

Comment:
[P1] `configSchema` is set to `emptyPluginConfigSchema()` even though this plugin exposes many config options (`provider`, `model`, `stages`, etc.) and `openclaw.plugin.json` defines a full schema.

Overriding the schema here likely prevents config validation and UI hints from reflecting the actual shape, which can lead to silent misconfigurations. If the schema is meant to be sourced from `openclaw.plugin.json`, drop this override (or wire the real schema into `configSchema`).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @Reapor-Yurnero (2026-02-03)

@greptileai

### @Reapor-Yurnero (2026-02-03)

@greptileai followed your suggestion and addresed your comments. should be mostly safe. can you re-review?

### @Reapor-Yurnero (2026-02-03)

@greptileai

### @nwinter (2026-02-03)

@greptileai are you able to re-review?

### @greptile-apps (2026-02-03)

Yes, looks excellent! All the suggestions have been properly implemented:

✅ **toolCallId correlation fixed** - Now properly handles undefined values with fallback and string conversion  
✅ **Tool result content preservation** - `appendWarningToToolResult` correctly copies arrays before modification  
✅ **Hook wiring consistency** - Both regular and client tools have proper guardrail integration

The code is now much more robust and addresses all the edge cases that could have caused correlation issues or content loss. Great work implementing those fixes!

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/agents/pi-embedded-runner/run/attempt.ts`**
[P2] `skipGuardrailHooks` uses `isGuardrailRunId(params.sessionId) || isGuardrailRunId(params.runId)`. Using `sessionId` here looks unintended: `sessionId` is typically user/session-scoped, so a guardrail-internal run is more naturally identified by `runId` alone. Including `sessionId` means any session whose ID happens to start with `guardrail:` will disable *all* hooks for that session.

If `sessionId` is always generated internally and guaranteed not to collide, this is harmless; otherwise it’s an easy footgun.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/agents/pi-embedded-runner/run/attempt.ts
Line: 725:735

Comment:
[P2] `skipGuardrailHooks` uses `isGuardrailRunId(params.sessionId) || isGuardrailRunId(params.runId)`. Using `sessionId` here looks unintended: `sessionId` is typically user/session-scoped, so a guardrail-internal run is more naturally identified by `runId` alone. Including `sessionId` means any session whose ID happens to start with `guardrail:` will disable *all* hooks for that session.

If `sessionId` is always generated internally and guaranteed not to collide, this is harmless; otherwise it’s an easy footgun.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** huge (5352+, 109-, 35 files)
- **Age:** 1 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
