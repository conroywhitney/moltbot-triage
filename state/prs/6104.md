---
number: 6104
title: "fix(ui): add tick monitoring to browser WebSocket client"
author: lailoo
created: 2026-02-01T08:42:07Z
updated: 2026-02-01T08:44:03Z
labels: ["app: web-ui"]
additions: 73
deletions: 0
changed_files: 1
size: medium
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 1
reactions_total: 1
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/6104
fixes_issues: [6087]
related_prs: [6087]
duplicate_of: null
---

## Description

Fixes #6087

## Problem
The browser WebSocket client in the webchat dashboard was missing tick/keepalive monitoring that the Node.js client has. This caused silent disconnections that manifested as the agent appearing to "hang" indefinitely.

**Symptoms:**
- Browser client continues to think it's connected after silent disconnect
- Misses all incoming messages
- Shows agent as "thinking" forever
- User has to manually refresh to see actual responses

## Root Cause
The Node.js client (`gateway/client.ts`) monitors for `tick` events and closes/reconnects if 2x the tick interval passes without receiving one. The browser client had NO tick handling - it only relied on `onclose`/`onerror` events which may not fire reliably on silent disconnects.

## Solution
Added tick monitoring to `GatewayBrowserClient` matching the Node.js implementation:

1. **Tick monitoring properties:**
   - `lastTick`: timestamp of last received tick
   - `tickIntervalMs`: interval from server policy (default 30s)
   - `tickTimer`: interval timer for checking tick staleness

2. **Tick event handling:**
   - Update `lastTick` when receiving tick events
   - Initialize monitoring after successful hello handshake

3. **Stale connection detection:**
   - `startTickWatch()`: starts interval to check if 2x tick interval passed
   - Closes connection with code 4000 ("tick timeout") when stale
   - Triggers automatic reconnect via existing `scheduleReconnect()`

4. **Visibility change handling:**
   - Listen for `visibilitychange` events
   - Check connection health when tab becomes visible
   - Force reconnect if connection is stale

## Testing
- TypeScript type check passes
- Lint passes
- Manual testing: tab backgrounding now triggers reconnect when returning

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

Adds tick/keepalive monitoring to the browser `GatewayBrowserClient` to mirror the Node gateway client: tracks `lastTick`, reads `tickIntervalMs` from the hello policy, starts an interval that closes the socket on tick timeout, and adds a `visibilitychange` hook to trigger a reconnect when returning to a stale tab.

Main concern is lifecycle/cleanup: unlike the Node client, the browser client doesn’t stop tick monitoring/listeners on reconnect paths, and its `onclose` always schedules a reconnect even if the client was intentionally stopped, which can lead to multiple reconnect timers/sockets once tick timeouts start closing the connection.

<h3>Confidence Score: 3/5</h3>

- Mostly safe, but has reconnection lifecycle edge cases that can create duplicate sockets/timers.
- The tick timeout logic itself matches the Node implementation, but the browser client currently doesn’t clear tick timers/listeners during reconnect and always schedules reconnect on `onclose`, which can cause overlapping reconnect attempts and stale timers acting on newer sockets.
- ui/src/ui/gateway.ts

<!-- greptile_other_comments_section -->

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-01)

<sub>1 file reviewed, 4 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-01)

<details>
<summary>Additional Comments (3)</summary>

**`ui/src/ui/gateway.ts`**
[P0] `onclose` always schedules a reconnect, even when the client was intentionally stopped. If `stop()` triggers `ws.close()`, the close event will still fire and `scheduleReconnect()` will run later because `this.closed` has been set back to `false` by a subsequent `start()`, potentially creating an extra parallel connection/reconnect loop.

This PR makes that more likely because `ws.close(4000, ...)` is now called from the tick timer/visibility handler.

Consider guarding the close handler: e.g. `if (this.closed) return;` (or capture a local `const wasClosed = this.closed` before closing) before calling `scheduleReconnect()`.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: ui/src/ui/gateway.ts
Line: 105:111

Comment:
[P0] `onclose` always schedules a reconnect, even when the client was intentionally stopped. If `stop()` triggers `ws.close()`, the close event will still fire and `scheduleReconnect()` will run later because `this.closed` has been set back to `false` by a subsequent `start()`, potentially creating an extra parallel connection/reconnect loop.

This PR makes that more likely because `ws.close(4000, ...)` is now called from the tick timer/visibility handler.

Consider guarding the close handler: e.g. `if (this.closed) return;` (or capture a local `const wasClosed = this.closed` before closing) before calling `scheduleReconnect()`.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`ui/src/ui/gateway.ts`**
[P1] `connect()` overwrites `this.ws` without closing any existing socket first. With the new tick timer/visibility handler calling `ws.close()` (and `onclose` scheduling reconnect), it’s easier to end up calling `connect()` while a previous socket is still OPEN/CONNECTING, which can lead to multiple concurrent sockets and confusing state.

Consider closing/cleaning up the existing `this.ws` before assigning a new one, or tracking a connection attempt id and ignoring stale `onclose`/`onmessage` from previous sockets.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: ui/src/ui/gateway.ts
Line: 100:104

Comment:
[P1] `connect()` overwrites `this.ws` without closing any existing socket first. With the new tick timer/visibility handler calling `ws.close()` (and `onclose` scheduling reconnect), it’s easier to end up calling `connect()` while a previous socket is still OPEN/CONNECTING, which can lead to multiple concurrent sockets and confusing state.

Consider closing/cleaning up the existing `this.ws` before assigning a new one, or tracking a connection attempt id and ignoring stale `onclose`/`onmessage` from previous sockets.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`ui/src/ui/gateway.ts`**
[P1] Tick watch/visibility handler aren’t stopped on reconnect paths. In Node `scheduleReconnect()` clears the tick timer; in the browser client, `scheduleReconnect()` doesn’t call `stopTickWatch()` or remove the visibility handler, so timers/listeners can keep running between reconnect attempts and can close a newer socket based on an old `lastTick`.

Consider stopping tick watch and removing the visibility handler in the `onclose` handler (or inside `scheduleReconnect()`), and restarting them only after a successful `hello` on the new connection.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: ui/src/ui/gateway.ts
Line: 105:111

Comment:
[P1] Tick watch/visibility handler aren’t stopped on reconnect paths. In Node `scheduleReconnect()` clears the tick timer; in the browser client, `scheduleReconnect()` doesn’t call `stopTickWatch()` or remove the visibility handler, so timers/listeners can keep running between reconnect attempts and can close a newer socket based on an old `lastTick`.

Consider stopping tick watch and removing the visibility handler in the `onclose` handler (or inside `scheduleReconnect()`), and restarting them only after a successful `hello` on the new connection.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** medium (73+, 0-, 1 files)
- **Age:** 1 days
- **Last activity:** 2026-02-01

## Links

- Fixes: #6087
