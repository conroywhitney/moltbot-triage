---
number: 4010
title: " Prevent crash on unhandled fetch rejections (Closes #3974)"
author: TechWizard9999
created: 2026-01-29T14:24:16Z
updated: 2026-02-03T02:52:36Z
labels: []
additions: 19
deletions: 1
changed_files: 2
size: small
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 1
reactions_total: 1
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/4010
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Summary
Updates the global unhandled rejection handler to correctly identify `TypeError: fetch failed` as a transient network error, even when the underlying cause is missing a specific Error Code.
## Changes
- **src/infra/unhandled-rejections.ts**: Relaxed `isTransientNetworkError` check for fetch errors.
- **src/infra/unhandled-rejections.test.ts**: Added regression tests for fetch errors with missing/unknown causes.
## Verification
- Added new unit tests covering the crash scenario.
- Verified `process.exit(1)` is no longer called for these errors.

With Gemini Flash

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR updates the unhandled rejection classification logic for Node/undici `TypeError("fetch failed")` errors and adds a regression test to cover cases where the underlying `cause` is missing or has an unknown `code`.

The logic lives in `src/infra/unhandled-rejections.ts` as part of `isTransientNetworkError`, which is used by the global `unhandledRejection` handler to decide whether to warn-and-continue (transient network / abort) or `process.exit(1)` (fatal/config/unknown). The test changes in `src/infra/unhandled-rejections.test.ts` aim to ensure the gateway doesn’t crash on these fetch failures.

<h3>Confidence Score: 4/5</h3>

- This PR is likely safe to merge and improves resilience against a known crash scenario.
- Changes are localized to error classification and add tests, but the new conditional logic in the `fetch failed` branch appears redundant given the unconditional `return true`, so the tests may not actually be validating the intended behavioral distinction.
- src/infra/unhandled-rejections.ts and src/infra/unhandled-rejections.test.ts

<!-- greptile_other_comments_section -->

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/infra/unhandled-rejections.test.ts`**
[P2] Regression test name doesn’t match what’s asserted

This test is labeled “unknown cause”, but it asserts `isTransientNetworkError(...)` is `true` in both cases. Since the implementation currently returns `true` for all `TypeError("fetch failed")` regardless of cause, this test will pass even if the new cause-handling logic is removed, so it won’t catch regressions around misclassifying non-network causes.

If the goal is to prevent a crash when the *cause has no/unknown code*, consider making the test assert the *decision point that used to crash* (e.g., that fatal/config causes are still treated as fatal, or that only certain cause shapes are treated as transient), so the test actually fails if the behavior regresses.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/infra/unhandled-rejections.test.ts
Line: 90:99

Comment:
[P2] Regression test name doesn’t match what’s asserted

This test is labeled “unknown cause”, but it asserts `isTransientNetworkError(...)` is `true` in both cases. Since the implementation currently returns `true` for all `TypeError("fetch failed")` regardless of cause, this test will pass even if the new cause-handling logic is removed, so it won’t catch regressions around misclassifying non-network causes.

If the goal is to prevent a crash when the *cause has no/unknown code*, consider making the test assert the *decision point that used to crash* (e.g., that fatal/config causes are still treated as fatal, or that only certain cause shapes are treated as transient), so the test actually fails if the behavior regresses.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** small (19+, 1-, 2 files)
- **Age:** 4 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
