---
number: 7592
title: "fix(slack): prevent unbounded memory growth in channel type cache"
author: namratabhaumik
created: 2026-02-03T00:50:01Z
updated: 2026-02-03T01:27:29Z
labels: []
additions: 28
deletions: 8
changed_files: 2
size: small
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 2
reactions_total: 1
ci_status: passing
mergeable: false
draft: false
url: https://github.com/openclaw/openclaw/pull/7592
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Problem
Slack channel type cache grows unbounded in large workspaces, causing memory leaks and potential OOM crashes. A workspace with thousands of channels could accumulate gigabytes of memory from cached entries that are never evicted.

## Solution
Implement LRU (Least Recently Used) eviction in the Slack channel type cache with a maximum size limit of 1,000 entries. When the cache reaches capacity, the oldest entry is evicted before adding new ones.

## Changes
- Add `MAX_SLACK_CHANNEL_CACHE_SIZE` constant (1,000 entries)
- Implement `setSlackChannelTypeCache()` helper with LRU eviction logic
- Update all 5 cache write sites to use the new helper function

## Impact
Prevents memory leaks in long-running gateways serving large Slack workspaces, while maintaining identical cache behavior from the caller's perspective.

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR adds an LRU-style cap (max 1000 entries) to the in-memory Slack channel type cache used by `resolveSlackChannelType()` in `src/infra/outbound/outbound-session.ts`, and updates all cache write sites to route through the new helper. It also adds a changelog entry documenting the fix.

The intent is to prevent unbounded memory growth in long-running gateway processes serving large Slack workspaces while keeping the caller-facing behavior the same (still returning cached channel types when available, otherwise falling back to allowlist/config checks and Slack API lookup).

<h3>Confidence Score: 3/5</h3>

- This PR is close to safe, but has a cache key mismatch that can negate the intended caching/eviction behavior in some configurations.
- The LRU cap is straightforward, but the read path uses `${params.accountId ?? "default"}` while writes use `${account.accountId}`, which can cause persistent cache misses and churn; also cache hits do not refresh recency so “LRU” can evict hot entries. No other functional changes were identified.
- src/infra/outbound/outbound-session.ts

<!-- greptile_other_comments_section -->

<sub>(2/5) Greptile learns from your feedback when you react with thumbs up/down!</sub>

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/infra/outbound/outbound-session.ts`**
[P0] Cache key mismatch makes LRU cache mostly ineffective for `accountId=null` and breaks LRU recency

`resolveSlackChannelType()` reads from `SLACK_CHANNEL_TYPE_CACHE` using `${params.accountId ?? "default"}:${channelId}` (line ~160), but all writes in this function use `${account.accountId}:${channelId}`. If `params.accountId` is null/undefined and `resolveSlackAccount()` returns an `account.accountId` that is *not* the literal string `"default"` (likely), cache hits will never happen (and LRU eviction will churn). Also, on cache hits you don’t update recency, so frequently used entries can still be evicted.

Repro: call `resolveSlackChannelType({ accountId: null, channelId: "G..." })` repeatedly; it will miss cache every time and re-add entries.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/infra/outbound/outbound-session.ts
Line: 156:163

Comment:
[P0] Cache key mismatch makes LRU cache mostly ineffective for `accountId=null` and breaks LRU recency

`resolveSlackChannelType()` reads from `SLACK_CHANNEL_TYPE_CACHE` using `${params.accountId ?? "default"}:${channelId}` (line ~160), but all writes in this function use `${account.accountId}:${channelId}`. If `params.accountId` is null/undefined and `resolveSlackAccount()` returns an `account.accountId` that is *not* the literal string `"default"` (likely), cache hits will never happen (and LRU eviction will churn). Also, on cache hits you don’t update recency, so frequently used entries can still be evicted.

Repro: call `resolveSlackChannelType({ accountId: null, channelId: "G..." })` repeatedly; it will miss cache every time and re-add entries.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @namratabhaumik (2026-02-03)

Thanks for the review feedback! I've fixed both issues you identified:

1. Cache Key Mismatch: The problem was reading with `params.accountId ?? "default"` but writing with `account.accountId`. Now I'm resolving the account first and using a consistent cache key for all operations:

```typescript
// Resolve account first to get the canonical accountId for consistent cache keys.
const account = resolveSlackAccount({ cfg: params.cfg, accountId: params.accountId });
const cacheKey = `${account.accountId}:${channelId}`;
const cached = SLACK_CHANNEL_TYPE_CACHE.get(cacheKey);
```

2. LRU Recency Update: On cache hit, the entry now gets moved to the end (most recently used):

```typescript
if (cached) {
  // Update recency on cache hit (move to end for LRU).
  setSlackChannelTypeCache(cacheKey, cached);
  return cached;
}
```


## Stats

- **Size:** small (28+, 8-, 2 files)
- **Age:** 0 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
