---
number: 6405
title: "feat(security): Add HTTP API security hooks for plugin scanning"
author: masterfung
created: 2026-02-01T16:47:05Z
updated: 2026-02-03T04:53:50Z
labels: ["gateway"]
additions: 1189
deletions: 14
changed_files: 6
size: huge
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"},{"author":"masterfung","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"},{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 10
reactions_total: 3
ci_status: failing
mergeable: true
draft: false
url: https://github.com/openclaw/openclaw/pull/6405
fixes_issues: []
related_prs: [6098,6099]
duplicate_of: null
---

## Description

## Summary

This PR adds 4 new plugin hooks to protect HTTP API endpoints from prompt injection and data exfiltration attacks.

**Related Discussion:** #6098
**Previous PR:** #6099 (closed for rebase)

## Problem

OpenClaw's HTTP API endpoints currently **bypass ALL plugin security hooks**:

| Endpoint | Hook Coverage | Risk |
|----------|---------------|------|
| `/v1/chat/completions` | ‚ùå None | **Critical** |
| `/v1/responses` | ‚ùå None | **Critical** |
| `/tools/invoke` | ‚ùå None | **Critical** |

Any application using the API directly (SDKs, curl) has zero protection against:
- Prompt injection attacks
- Data exfiltration via LLM responses
- Tool argument injection
- Indirect injection via tool results

## Solution

Added 4 new plugin hooks:

| Hook | Purpose | Execution |
|------|---------|-----------|
| `http_request_received` | Scan/block incoming requests | Sequential (can block) |
| `http_response_sending` | Scan/block responses for leaks | Sequential (can block) |
| `http_tool_invoke` | Scan/block tool arguments | Sequential (can block) |
| `http_tool_result` | Scan/block tool results | Sequential (can block) |

### Security Features
- **FAIL-CLOSED**: Hook errors/timeouts block requests (not bypass)
- **Header redaction**: Authorization/Cookie/X-API-Key redacted
- **Request ID**: For correlation/audit logging

## Changes

| File | Lines | Description |
|------|-------|-------------|
| `src/plugins/types.ts` | +157 | Hook type definitions |
| `src/plugins/hooks.ts` | +126 | Hook runners |
| `src/gateway/openai-http.ts` | +166 | Hooks for `/v1/chat/completions` |
| `src/gateway/openresponses-http.ts` | +103 | Hooks for `/v1/responses` |
| `src/gateway/tools-invoke-http.ts` | +108 | Hooks for `/tools/invoke` |
| `src/plugins/http-hooks.test.ts` | +387 | 13 unit tests |

**Total: 651 lines added, 9 lines removed**

## Test Plan

- [x] 13 new unit tests covering all hooks
- [x] Tests for error handling (fail-closed behavior)
- [x] Tests for hook priority ordering
- [x] TypeScript compilation passes
- [x] All existing tests unaffected
- [x] Rebased on latest main (26 new commits)

```bash
npx vitest run src/plugins/http-hooks.test.ts
# ‚úì 13 tests pass
```

## Usage Example

Security plugins can now register for HTTP hooks:

```typescript
api.on("http_request_received", async (event, ctx) => {
  const result = await scanForInjection(event.content);
  if (result.isInjection) {
    return { 
      block: true, 
      blockReason: "Prompt injection detected",
      blockStatusCode: 400 
    };
  }
});

api.on("http_response_sending", async (event, ctx) => {
  const result = await scanForLeaks(event.content);
  if (result.hasLeak) {
    return { 
      block: true, 
      blockReason: "Credential leak detected" 
    };
  }
});
```

## Real-World Plugin

This PR enables [Citadel Guard](https://github.com/TryMightyAI/citadel-guard-openclaw), a security plugin that:
- Scans for prompt injection using ML models
- Detects credential/PII leaks in responses
- Provides multi-turn attack detection
- Works with both OSS and Pro Citadel backends

The plugin already has conditional hook registration to work with both current OpenClaw (messaging hooks) and this PR (HTTP hooks).

## Known Limitations

1. **Streaming responses**: Output scanning only works for non-streaming responses. Streaming would require buffering which breaks the streaming UX.

## Breaking Changes

None. New hooks are additive and don't affect existing behavior.

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR introduces new plugin hook types and hook-runner entrypoints for securing HTTP API endpoints (`/v1/chat/completions`, `/v1/responses`, `/tools/invoke`). The gateways now invoke `http_request_received` before processing requests and `http_response_sending` before returning responses (with end-of-stream audit-only scanning for streaming responses), and `/tools/invoke` invokes `http_tool_invoke`/`http_tool_result` with safe JSON serialization.

Main functional concern: `/v1/responses` currently does not run `http_response_sending` at all for non-streaming responses, which leaves a major coverage gap for response-side leak/exfiltration scanning in the most common non-streaming case.


<h3>Confidence Score: 3/5</h3>

- Moderate risk to merge due to a response-hook coverage gap on `/v1/responses` non-streaming path.
- While the hook type additions and `/tools/invoke` changes look coherent, the non-streaming `/v1/responses` handler never executes `http_response_sending`, undermining the stated security goal and likely surprising plugin authors relying on response scanning. Other items appear lower risk.
- src/gateway/openresponses-http.ts

<!-- greptile_other_comments_section -->

<!-- /greptile_comment -->

## Reviews

### @greptile-apps ‚Äî COMMENTED (2026-02-01)

<sub>3 files reviewed, 5 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @masterfung ‚Äî COMMENTED (2026-02-01)



### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>2 files reviewed, 4 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-01)

<details>
<summary>Additional Comments (2)</summary>

**`src/gateway/openresponses-http.ts`**
[P0] Streaming `/v1/responses` never runs `http_response_sending`, so streaming responses bypass the new ‚Äúresponse leak/exfil‚Äù hook entirely.

The PR description calls out streaming limitations, but the code currently doesn‚Äôt invoke `runHttpResponseSending` at all in the streaming path (only `http_request_received` is enforced). That means plugins can‚Äôt block/redact streaming output even at end-of-stream. If the intended behavior is ‚Äúnon-streaming only‚Äù, this is a security gap vs the stated goal of protecting the endpoint.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openresponses-http.ts
Line: 703:710

Comment:
[P0] Streaming `/v1/responses` never runs `http_response_sending`, so streaming responses bypass the new ‚Äúresponse leak/exfil‚Äù hook entirely.

The PR description calls out streaming limitations, but the code currently doesn‚Äôt invoke `runHttpResponseSending` at all in the streaming path (only `http_request_received` is enforced). That means plugins can‚Äôt block/redact streaming output even at end-of-stream. If the intended behavior is ‚Äúnon-streaming only‚Äù, this is a security gap vs the stated goal of protecting the endpoint.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/gateway/openai-http.ts`**
[P0] Streaming `/v1/chat/completions` bypasses `http_response_sending` (and can‚Äôt be blocked/redacted).

`http_response_sending` is only invoked in the non-streaming branch. In the SSE streaming branch, chunks are written directly from `onAgentEvent`/fallback without any hook call, so plugins cannot detect leaks or block/modify content for streamed responses. Given the PR‚Äôs goal (‚Äúprotect HTTP API endpoints‚Äù), this is a meaningful coverage hole unless explicitly accepted and documented as such.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openai-http.ts
Line: 430:476

Comment:
[P0] Streaming `/v1/chat/completions` bypasses `http_response_sending` (and can‚Äôt be blocked/redacted).

`http_response_sending` is only invoked in the non-streaming branch. In the SSE streaming branch, chunks are written directly from `onAgentEvent`/fallback without any hook call, so plugins cannot detect leaks or block/modify content for streamed responses. Given the PR‚Äôs goal (‚Äúprotect HTTP API endpoints‚Äù), this is a meaningful coverage hole unless explicitly accepted and documented as such.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @masterfung (2026-02-02)

## Addressed Streaming Security Gap ‚úÖ

Thanks for the thorough review @greptile-apps! The P0 concerns about streaming responses are valid and have been addressed:

### What we added:

**End-of-stream scanning** (commit `8ad63df`):
- Accumulates streamed content during SSE transmission
- Runs `http_response_sending` hook at end-of-stream with full response
- Works in **audit mode** - logs/alerts but doesn't break stream mid-flight

```typescript
// At end of stream:
if (hookRunner && httpCtx && accumulatedContent) {
  hookRunner.runHttpResponseSending({
    content: accumulatedContent,
    isStreaming: true,
    isFinalChunk: true,
  }, httpCtx);
}
```

### Why audit-only for streaming?

Blocking mid-stream would corrupt the SSE connection. Instead, plugins can:
1. Log the leak for investigation
2. Alert security team
3. Terminate the session for future requests
4. Flag the response in audit trail

This matches how other security gateways handle streaming (can't un-send bytes already transmitted).

### Documentation

Added inline comments explaining this tradeoff in both `openai-http.ts` and `openresponses-http.ts`.

---

Ready for review! Happy to address any other feedback.

### @masterfung (2026-02-02)

cc @steipete - would love your feedback on this security hooks feature when you have a moment! It closes a gap where HTTP API consumers bypass plugin hooks that protect messaging platforms.

### @greptile-apps (2026-02-02)

Perfect! I can see the implementation now. This is a solid approach to the streaming security challenge.

## ‚úÖ What Works Well

**1. Proper content accumulation:**
```typescript
// Content accumulated during streaming in both files
accumulatedText += content; // openresponses-http.ts  
accumulatedContent += content; // openai-http.ts
```

**2. End-of-stream hook execution:**
Both files properly invoke the `http_response_sending` hook after streaming completes with clear audit logging when content would have been blocked.

**3. Clear documentation:**
The header comments clearly explain the tradeoff and alternatives for security teams.

## Summary

This is the right solution for streaming security - **audit-mode scanning** that:
- ‚úÖ Accumulates content during streaming
- ‚úÖ Runs security hooks at end-of-stream  
- ‚úÖ Logs when content would have been blocked (audit trail)
- ‚úÖ Doesn't break streaming UX by mid-stream blocking
- ‚úÖ Clearly documents the architectural tradeoff

The implementation properly balances security visibility with streaming performance. Security plugins can still detect and log issues for investigation, alert security teams, and take action on future requests.

This addresses the P0 streaming gap concern effectively! üéØ

### @masterfung (2026-02-02)

## Why We Built This: Citadel Guard for OpenClaw üõ°Ô∏è

We're building **[Citadel Guard](https://github.com/TryMightyAI/citadel-guard-openclaw)** - an open-source security plugin that protects OpenClaw agents from prompt injection, jailbreaks, and data exfiltration.

### The Problem We Hit

Our plugin works great for **messaging platforms** (Telegram, Discord, Slack) because all messages flow through plugin hooks:

```
User ‚Üí message_received hook ‚Üí Citadel scans ‚Üí AI ‚Üí message_sending hook ‚Üí Citadel scans ‚Üí User
        ‚úÖ Protected                                    ‚úÖ Protected
```

But when users hit the **HTTP API directly** (`/v1/chat/completions`, `/v1/responses`), there are no hooks:

```
User ‚Üí HTTP API ‚Üí AI ‚Üí HTTP Response ‚Üí User
        ‚ùå No scanning    ‚ùå No scanning
```

**Same OpenClaw instance, completely different security posture** depending on how you access it.

### What This PR Enables

With these 4 hooks, Citadel can protect ALL entry points:

| Hook | What Citadel Does |
|------|-------------------|
| `http_request_received` | Blocks prompt injection before it hits the model |
| `http_response_sending` | Catches credential leaks, PII exposure |
| `http_tool_invoke` | Stops dangerous tool args (`rm -rf /`, SQL injection) |
| `http_tool_result` | Detects indirect injection from external data |

### Real-World Use Case

We have the plugin ready and tested: **[citadel-guard-openclaw](https://github.com/TryMightyAI/citadel-guard-openclaw)**

- 258 tests passing
- Handles both Citadel Pro (hosted) and OSS (self-hosted)
- Already protects messaging + tools
- **Just waiting on this PR to protect HTTP API**

### Why This Matters for OpenClaw

Security plugins are a huge value-add for enterprise adoption. This PR makes OpenClaw a platform where the community can build security layers - not just Citadel, but rate limiters, PII redactors, compliance filters, etc.

Happy to jump on a call to demo if that helps! üôè

### @masterfung (2026-02-03)

@greptileai can you re-review the pr?

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (2)</summary>

**`src/gateway/openai-http.ts`**
[P1] `writeSse` uses `JSON.stringify` directly; this can throw and break streaming responses.

If an SSE payload includes a `bigint` or a circular structure (even via nested event data), `JSON.stringify` will throw synchronously and can terminate the streaming response unexpectedly. Consider using the same kind of ‚Äúsafe stringify‚Äù approach used in `/tools/invoke` or otherwise ensuring SSE payloads are always JSON-serializable.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openai-http.ts
Line: 54:56

Comment:
[P1] `writeSse` uses `JSON.stringify` directly; this can throw and break streaming responses.

If an SSE payload includes a `bigint` or a circular structure (even via nested event data), `JSON.stringify` will throw synchronously and can terminate the streaming response unexpectedly. Consider using the same kind of ‚Äúsafe stringify‚Äù approach used in `/tools/invoke` or otherwise ensuring SSE payloads are always JSON-serializable.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/gateway/openai-http.ts`**
[P1] Likely bug in `extractTextContent`: `type === "input_text"` branch checks `text` instead of `input_text`.

For content parts shaped like `{ type: "input_text", input_text: "..." }`, this currently returns empty because it does `typeof text === "string"`. That means request scanning and prompt building may miss user content for some clients.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openai-http.ts
Line: 78:83

Comment:
[P1] Likely bug in `extractTextContent`: `type === "input_text"` branch checks `text` instead of `input_text`.

For content parts shaped like `{ type: "input_text", input_text: "..." }`, this currently returns empty because it does `typeof text === "string"`. That means request scanning and prompt building may miss user content for some clients.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @masterfung (2026-02-03)

cc @cpojer @shakkernerd @justinhuangcode love your takes on this PR. Simple, powerful, and secure.

### @masterfung (2026-02-03)

@greptileai review

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (2)</summary>

**`src/gateway/openresponses-http.ts`**
[P0] `http_response_sending` hook is never executed for non-streaming `/v1/responses` responses.

`handleOpenResponsesHttpRequest` runs `http_request_received` (and end-of-stream audit scanning for streaming), but in the non-streaming path it builds `content` and immediately `sendJson(res, 200, response)` without invoking `hookRunner.runHttpResponseSending(...)`. That means direct API callers get no response-side leak/exfiltration scanning unless they use streaming, which defeats a core goal of this PR.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openresponses-http.ts
Line: 630:702

Comment:
[P0] `http_response_sending` hook is never executed for non-streaming `/v1/responses` responses.

`handleOpenResponsesHttpRequest` runs `http_request_received` (and end-of-stream audit scanning for streaming), but in the non-streaming path it builds `content` and immediately `sendJson(res, 200, response)` without invoking `hookRunner.runHttpResponseSending(...)`. That means direct API callers get no response-side leak/exfiltration scanning unless they use streaming, which defeats a core goal of this PR.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/gateway/openai-http.ts`**
[P2] `new URL(req.url, ...)` can throw on malformed request targets, which will crash the handler before sending an HTTP response.

If `req.url` contains an invalid URL (can happen with raw HTTP clients), `new URL(...)` throws synchronously; there‚Äôs no surrounding try/catch here. Other handlers in the codebase often defensively handle malformed URLs, so it may be worth aligning here to avoid a process-level exception.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/gateway/openai-http.ts
Line: 246:249

Comment:
[P2] `new URL(req.url, ...)` can throw on malformed request targets, which will crash the handler before sending an HTTP response.

If `req.url` contains an invalid URL (can happen with raw HTTP clients), `new URL(...)` throws synchronously; there‚Äôs no surrounding try/catch here. Other handlers in the codebase often defensively handle malformed URLs, so it may be worth aligning here to avoid a process-level exception.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** huge (1189+, 14-, 6 files)
- **Age:** 1 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
