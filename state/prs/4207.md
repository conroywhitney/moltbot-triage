---
number: 4207
title: "fix: avoid cron self-deadlock when embedded agent calls cron tools"
author: JoelCooperPhD
created: 2026-01-29T21:34:41Z
updated: 2026-02-03T02:52:44Z
labels: ["gateway", "agents"]
additions: 81
deletions: 17
changed_files: 5
size: medium
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 1
reactions_total: 1
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/4207
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Summary

- When a cron job triggers an agent that calls back into cron (e.g. `cron.list`), the non-reentrant async mutex in `locked()` causes a circular wait: `onTimer` holds the lock ‚Üí agent runs ‚Üí agent calls `cron.list` ‚Üí `cron.list` waits for the lock ‚Üí deadlock.
- Splits `onTimer` to collect due jobs under the lock, then execute them after releasing it. The `runningAtMs` sentinel prevents double-runs.
- Adds a module-level `CronService` registry so the cron tool can call the service directly in-process, bypassing the gateway WebSocket round-trip.

## Files changed

- `src/cron/service-registry.ts` (new) ‚Äî singleton get/set for CronService
- `src/cron/service/timer.ts` ‚Äî collect due jobs under lock, execute outside it
- `src/agents/tools/cron-tool.ts` ‚Äî prefer direct service call over gateway WebSocket
- `src/agents/moltbot-tools.ts` ‚Äî thread `cronService` option
- `src/gateway/server.impl.ts` ‚Äî register singleton at boot and on reload

## Test plan

- [x] Cron job that triggers an agent calling `cron.list` no longer deadlocks
- [ ] Manual `cron.run` still works
- [ ] Timer-fired jobs still execute on schedule
- [ ] No double-runs (verified via `runningAtMs` guard)

ü§ñ AI-assisted (Claude). I understand what the code does.
Testing: locally tested with cron jobs that call cron.list mid-execution.

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR addresses a real deadlock scenario where `onTimer()` holds the non-reentrant cron mutex while running jobs, and an embedded agent job calls back into cron tools (e.g. `cron.list`), creating a circular wait. It does this by (1) splitting `onTimer()` to collect due jobs under `locked()` and execute them after releasing the lock, and (2) adding a module-level CronService registry so the cron agent tool can call the in-process CronService instead of doing a gateway WebSocket round-trip.

Main risk introduced is concurrency correctness around claiming due jobs now that execution is outside the lock (and type/behavior drift in the new `cronService` fast-path typing).

<h3>Confidence Score: 3/5</h3>

- This PR is directionally safe but has a plausible concurrency regression risk around job double-execution.
- The deadlock fix is well-motivated, but moving job execution outside `locked()` means the existing `runningAtMs` guard no longer prevents concurrent selection unless the guard is set under the lock. If any other code path selects due jobs while a timer tick is between selection and `executeJob()` start, the same job can run twice. The new CronService registry/tool fast-path is small and isolated, but the `cronService` type doesn‚Äôt fully match `CronService` and `wake` still uses the gateway path, which may surprise callers.
- src/cron/service/timer.ts; src/agents/tools/cron-tool.ts

<!-- greptile_other_comments_section -->

<sub>(4/5) You can add custom instructions or style guidelines for the agent [here](https://app.greptile.com/review/github)!</sub>

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews

### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (2)</summary>

**`src/cron/service/timer.ts`**
[P0] Due jobs can double-run because `runningAtMs` is set outside the lock.

`collectDueJobs()` filters by `j.state.runningAtMs`, but `onTimer()` now releases the lock before calling `executeJob()`, and `executeJob()` sets `job.state.runningAtMs` without taking `locked()`. If another `onTimer()` tick (or `cron.run`/`ops.run`) acquires the lock in between, it can also select the same job as due and start it, resulting in concurrent double execution.

Consider setting `runningAtMs` (or another ‚Äúclaimed‚Äù sentinel) for each due job while still inside the `locked()` section, so other selectors won‚Äôt pick it up.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/cron/service/timer.ts
Line: 34:41

Comment:
[P0] Due jobs can double-run because `runningAtMs` is set outside the lock.

`collectDueJobs()` filters by `j.state.runningAtMs`, but `onTimer()` now releases the lock before calling `executeJob()`, and `executeJob()` sets `job.state.runningAtMs` without taking `locked()`. If another `onTimer()` tick (or `cron.run`/`ops.run`) acquires the lock in between, it can also select the same job as due and start it, resulting in concurrent double execution.

Consider setting `runningAtMs` (or another ‚Äúclaimed‚Äù sentinel) for each due job while still inside the `locked()` section, so other selectors won‚Äôt pick it up.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/agents/tools/cron-tool.ts`**
[P1] `CronToolOptions.cronService` signature doesn‚Äôt match `CronService` for `wake`/`run`.

`CronService.wake()` returns a value (and is synchronous), and `CronService.run()` accepts `mode?: "due" | "force"`. Here `wake` is typed as returning `unknown` (but is never used for the `wake` action), and `run` is typed as `(id: string, mode?: string)`.

This makes it easy to pass an incompatible object (or miss required behavior) without TS catching it; also the tool currently still calls the gateway for `wake`, so supplying `cronService` won‚Äôt actually avoid the self-deadlock for wake events.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/agents/tools/cron-tool.ts
Line: 44:55

Comment:
[P1] `CronToolOptions.cronService` signature doesn‚Äôt match `CronService` for `wake`/`run`.

`CronService.wake()` returns a value (and is synchronous), and `CronService.run()` accepts `mode?: "due" | "force"`. Here `wake` is typed as returning `unknown` (but is never used for the `wake` action), and `run` is typed as `(id: string, mode?: string)`.

This makes it easy to pass an incompatible object (or miss required behavior) without TS catching it; also the tool currently still calls the gateway for `wake`, so supplying `cronService` won‚Äôt actually avoid the self-deadlock for wake events.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** medium (81+, 17-, 5 files)
- **Age:** 4 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
