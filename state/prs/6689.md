---
number: 6689
title: "Fix: auto-remove idle session lanes to prevent unbounded command queue growth"
author: kamb5686
created: 2026-02-01T23:24:26Z
updated: 2026-02-02T15:49:30Z
labels: ["agents"]
additions: 68
deletions: 13
changed_files: 3
size: medium
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 4
reactions_total: 1
ci_status: passing
mergeable: false
draft: false
url: https://github.com/openclaw/openclaw/pull/6689
fixes_issues: [5264]
related_prs: [5264]
duplicate_of: null
---

## Description

Fixes #5264.

The command queue stores per-lane state in an in-process Map. Session-derived lanes ("session:*") are created as new sessions appear and previously were never removed, leading to unbounded growth over long runtimes.

This change removes *idle* session lanes (no active tasks, empty queue) once they become idle, while keeping the main lane persistent. Includes a unit test to prevent regression.

Testing: `pnpm vitest run src/process/command-queue.test.ts`

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR addresses unbounded growth in the in-process command queue’s per-lane `Map` by auto-removing idle session-derived lanes (`session:*`) once they have no active tasks and an empty queue. The change hooks lane cleanup into the lane draining loop and into `clearCommandLane`, and adds a unit test to assert that a `session:*` lane is removed after its work completes.

The changes fit into the existing `command-queue.ts` design where lanes are lightweight in-memory schedulers; the PR keeps the `main` lane persistent while allowing ephemeral session lanes to be garbage-collected to avoid long-lived processes accumulating lane state.

<h3>Confidence Score: 4/5</h3>

- This PR is likely safe to merge, with a small risk of edge-case lane state getting stuck.
- The core change is localized and conceptually correct (remove `session:*` lanes when idle). The main concern is correctness around `state.active` bookkeeping if a task throws synchronously, plus some minor test/cleanup triggering nuances.
- src/process/command-queue.ts (active decrement and cleanup trigger paths), src/process/command-queue.test.ts (test stability)

<!-- greptile_other_comments_section -->

<sub>(2/5) Greptile learns from your feedback when you react with thumbs up/down!</sub>

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-01)

<sub>2 files reviewed, 3 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-01)

<details>
<summary>Additional Comments (1)</summary>

**`src/process/command-queue.ts`**
[P1] `active` can leak when a task resolves/rejects before decrement

In `drainLane`, `state.active -= 1` happens *after* `await entry.task()` (and likewise only inside the `catch`). If `entry.task()` throws synchronously before returning a promise (or returns a promise but throws before the first `await` in the wrapper), `state.active` will never be decremented, leaving the lane permanently “active” and preventing `maybeRemoveIdleLane` from ever cleaning up session lanes (and potentially stalling concurrency decisions). Consider moving the decrement into a `finally` block so it always runs.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/process/command-queue.ts
Line: 82:86

Comment:
[P1] `active` can leak when a task resolves/rejects before decrement

In `drainLane`, `state.active -= 1` happens *after* `await entry.task()` (and likewise only inside the `catch`). If `entry.task()` throws synchronously before returning a promise (or returns a promise but throws before the first `await` in the wrapper), `state.active` will never be decremented, leaving the lane permanently “active” and preventing `maybeRemoveIdleLane` from ever cleaning up session lanes (and potentially stalling concurrency decisions). Consider moving the decrement into a `finally` block so it always runs.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @kamb5686 (2026-02-01)

Good catch. Updated to ensure `state.active` is always decremented via a `finally` block, so synchronous throws or early rejections can’t leak the active count and block cleanup. Pushed in latest commit on this PR branch.

### @kamb5686 (2026-02-01)

Pre-emptively cleaned up a couple of lint/CI issues to keep this PR spotless: (1) avoid enum/string compare in lane predicate (compare against literal "main" with comment), (2) remove unnecessary type assertions in oauth provider resolution via a tiny type guard. Pushed to PR branch.

### @kamb5686 (2026-02-02)

Thanks — agreed on both points.

**Cleanup trigger:** I added an additional cleanup hook so empty session lanes don’t rely solely on a future `drainLane`/`clearCommandLane` call. Specifically, `getQueueSize(lane)` now prunes idle `session:*` lanes when it observes `size===0`.

**Test flake:** I rewrote the idle-lane cleanup test to be deterministic (no 5ms/timeout assumptions; it now runs a zero-delay task and asserts cleanup via the size query path).

Latest head: `902339613b7d7ec54801da2d4b48db4f3af3a8c9`.


## Stats

- **Size:** medium (68+, 13-, 3 files)
- **Age:** 1 days
- **Last activity:** 2026-02-02

## Links

- Fixes: #5264
