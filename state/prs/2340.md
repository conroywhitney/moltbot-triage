---
number: 2340
title: "Agent tool call hooks now fire during tool execution"
author: AhmedTheGeek
created: 2026-01-26T19:12:36Z
updated: 2026-01-28T23:25:12Z
labels: []
additions: 133
deletions: 7
changed_files: 2
size: medium
review_decision: none
reviews: []
comments_count: 0
reactions_total: 0
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/2340
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Summary

Wire up the existing `before_tool_call` and `after_tool_call` plugin hooks so they actually fire during the agent execution loop. These hooks were defined in `src/plugins/hooks.ts` but never invoked.

## What changed

### New file: `src/agents/pi-tools.hooks.ts`

A tool wrapper module (following the same pattern as `pi-tools.abort.ts`) that wraps each tool's `execute` method to fire plugin hooks:

- **`wrapToolWithHooks(tool, hookRunner, ctx)`** — wraps a single tool
- **`wrapToolsWithHooks(tools, hookRunner, ctx)`** — wraps an array; returns the original array unchanged if no hooks are registered (zero overhead)

### Modified: `src/agents/pi-embedded-runner/run/attempt.ts`

- Moved `hookRunner` initialization earlier (before `splitSdkTools`) so it's available for tool wrapping
- Both `builtInTools` and `customTools` are wrapped before being passed to `createAgentSession`
- Extracted `hookAgentId` to avoid repeated `sessionKey.split(":")` calls

## How it works

### `before_tool_call`

Fires **before** each tool executes. Plugin handlers receive `{ toolName, params }` and can:

- **Block the call**: return `{ block: true, blockReason: "..." }` → tool is skipped, a synthetic `[Tool call blocked] ...` result is returned to the model
- **Modify params**: return `{ params: modifiedParams }` → the modified params are used instead

Handlers run sequentially in priority order. If any handler blocks, the tool is not executed.

### `after_tool_call`

Fires **after** each tool returns (or throws). Plugin handlers receive `{ toolName, params, result, error, durationMs }`.

This is fire-and-forget (void hook) — handlers run in parallel and failures are caught and logged.

## Plugin author usage

```typescript
// In a plugin's hooks registration:
{
  hookName: "before_tool_call",
  handler: async (event, ctx) => {
    // Log all tool calls
    console.log(`Tool ${event.toolName} called with`, event.params);

    // Block dangerous tools
    if (event.toolName === "exec" && isSuspicious(event.params)) {
      return { block: true, blockReason: "Blocked by security policy" };
    }

    // Or modify params
    return { params: sanitize(event.params) };
  },
}

{
  hookName: "after_tool_call",
  handler: async (event, ctx) => {
    // Post-execution logging / telemetry
    metrics.recordToolCall({
      tool: event.toolName,
      durationMs: event.durationMs,
      success: !event.error,
    });
  },
}
```

## Safety

- Hook errors never break tool execution (caught and logged)
- Tools are only wrapped when hooks are registered (no overhead otherwise)
- Follows existing patterns: same wrapper style as `wrapToolWithAbortSignal`, same hook runner access as `session-tool-result-guard-wrapper.ts`
- No refactoring of existing code — purely additive wiring

## Reviews


## Comments


## Stats

- **Size:** medium (133+, 7-, 2 files)
- **Age:** 3 days
- **Last activity:** 2026-01-28

## Links

- Fixes: (none detected)
