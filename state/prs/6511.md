---
number: 6511
title: "Fix: allow memory flush after compaction during previous flush"
author: rafaelreis-r
created: 2026-02-01T18:51:05Z
updated: 2026-02-01T20:24:54Z
labels: ["docs", "channel: telegram", "docker"]
additions: 116
deletions: 28
changed_files: 10
size: medium
review_decision: none
reviews: []
comments_count: 0
reactions_total: 1
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/6511
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

### Bug
When a memory flush triggers near the compaction threshold, compaction can complete during the flush. In that case the session `compactionCount` is incremented and the flush metadata was being recorded as:

- `memoryFlushCompactionCount = compactionCount` (the *new* count after compaction)

On the next user turn, the memory flush gate checks `memoryFlushCompactionCount === compactionCount` and would incorrectly skip the flush for the entire compaction cycle, even if the context grows again after compaction.

### Fix
Track the flush against the **pre-flush compaction cycle**:
- Capture `preFlushCompactionCount` before running the flush
- If compaction completes during the flush, increment `compactionCount` as before
- Persist `memoryFlushCompactionCount = preFlushCompactionCount` (not the advanced count)

This keeps the original “don't run multiple flushes in the same cycle” behavior, while allowing a new flush later if the context grows again after a compaction.

### Tests
- Updated expectation for flush+compaction case
- Added regression test ensuring a second flush can run after compaction completed during the first flush

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR adjusts how memory flush metadata is recorded when compaction completes during the flush. Instead of storing `memoryFlushCompactionCount` as the post-compaction `compactionCount`, it now pins the flush to the **pre-flush** compaction cycle (`preFlushCompactionCount`), preventing the next turn from being incorrectly gated for the entire new compaction cycle. The accompanying tests update the expected persisted value and add a regression test ensuring a second flush can run after a compaction completed during the first flush.

This fits into the existing memory flush gating in `src/auto-reply/reply/memory-flush.ts`, which uses `memoryFlushCompactionCount === compactionCount` to prevent multiple flushes per compaction cycle.

<h3>Confidence Score: 4/5</h3>

- This PR is safe to merge with low risk; the change is localized and has regression coverage.
- The behavioral change is narrowly scoped to how `memoryFlushCompactionCount` is persisted after a flush, aligning with the gating condition in `memory-flush.ts`. Tests were updated and a regression test was added to cover the compaction-during-flush scenario. Main remaining uncertainty is unverified CI/runtime execution in this sandbox (couldn’t run tests here).
- src/auto-reply/reply/agent-runner-memory.ts

<!-- greptile_other_comments_section -->

<sub>(4/5) You can add custom instructions or style guidelines for the agent [here](https://app.greptile.com/review/github)!</sub>

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews


## Comments


## Stats

- **Size:** medium (116+, 28-, 10 files)
- **Age:** 1 days
- **Last activity:** 2026-02-01

## Links

- Fixes: (none detected)
