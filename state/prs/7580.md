---
number: 7580
title: "feat: add message:received internal hook with prompt injection"
author: rodrigoschott
created: 2026-02-03T00:35:27Z
updated: 2026-02-03T02:56:31Z
labels: ["agents"]
additions: 34
deletions: 2
changed_files: 3
size: small
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"},{"author":"chatgpt-codex-connector","state":"COMMENTED"}]
comments_count: 2
reactions_total: 1
ci_status: pending
mergeable: true
draft: false
url: https://github.com/openclaw/openclaw/pull/7580
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Motivation

The OpenClaw documentation lists `message:received` as a [planned event (Future Event)](https://docs.openclaw.ai/hooks#future-events) since the introduction of the hooks system, but the implementation was pending. This PR implements the missing event, completing the lifecycle event coverage for inbound messages.

## What was implemented

- Added `"message"` type to `InternalHookEventType` in `internal-hooks.ts`
- Trigger `message:received` event in `dispatchInboundMessage()` before agent processing
- **Context injection**: hooks can add messages to `hookEvent.messages[]` which will be concatenated to `BodyForAgent`, allowing invisible injection of instructions/context into the LLM prompt
- Debug logs for development tracing

## Advantages

1. **Extensibility**: Allows hooks to react to every received message (not just commands)
2. **Context injection**: Hooks can dynamically modify agent input based on rules (e.g., detect patterns and inject specific instructions)
3. **Documentation parity**: Implements a feature already documented as "Future Event"
4. **Zero breaking changes**: Pure addition, does not alter existing behavior

## Use cases

### 1. Pattern-based context injection
```typescript
const handler: HookHandler = async (event) => {
  if (event.type !== "message" || event.action !== "received") return;
  
  if (event.context.body?.includes("urgent")) {
    event.messages.push("‚ö†Ô∏è User mentioned urgency. Prioritize this request.");
  }
};
```

### 2. Pre-processing validation/auditing
```typescript
const handler: HookHandler = async (event) => {
  if (event.type === "message" && event.action === "received") {
    console.log(`[audit] Message from ${event.context.senderId} at ${event.timestamp}`);
  }
};
```

### 3. Trigger external automations
```typescript
const handler: HookHandler = async (event) => {
  if (event.type === "message" && event.action === "received") {
    void notifyExternalSystem(event.context);
  }
};
```

## Tests

- [x] Hook is triggered for every inbound message
- [x] Injected messages appear in agent prompt
- [ ] No performance impact (async, non-blocking)
- [x] Debug logs appear in development mode

## Breaking changes

None. Pure feature addition.

## Related documentation

- [Hooks - Future Events](https://docs.openclaw.ai/hooks#future-events)
- Implements: `message:received` (previously listed as "Future Event")

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR implements the previously-documented `message:received` internal hook by extending `InternalHookEventType` with `"message"` and triggering the hook from `dispatchInboundMessage()` before reply/agent processing. It also introduces ‚Äúcontext injection‚Äù by allowing hook handlers to push strings onto `event.messages`, which are then concatenated into `finalized.BodyForAgent`.

The change fits into the existing internal hook registry (`registerInternalHook` / `triggerInternalHook`) by following the same `type` + `action` dispatch scheme used for other lifecycle events.

<h3>Confidence Score: 3/5</h3>

- Reasonably safe to merge, but there are a couple of behavioral and logging concerns that should be addressed first.
- Core changes are small and additive, but the current implementation (1) can corrupt `BodyForAgent` when undefined during injection, and (2) adds synchronous hook execution plus unconditional debug logging that may affect latency and leak message content. These are straightforward to fix but meaningful in production paths.
- src/auto-reply/dispatch.ts

<!-- greptile_other_comments_section -->

<sub>(2/5) Greptile learns from your feedback when you react with thumbs up/down!</sub>

<!-- /greptile_comment -->

## Reviews

### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>2 files reviewed, 5 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>

### @chatgpt-codex-connector ‚Äî COMMENTED (2026-02-03)


### üí° Codex Review

Here are some automated review suggestions for this pull request.

**Reviewed commit:** `a46eacb237`
    

<details> <summary>‚ÑπÔ∏è About Codex in GitHub</summary>
<br/>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you
- Open a pull request for review
- Mark a draft as ready
- Comment "@codex review".

If Codex has suggestions, it will comment; otherwise it will react with üëç.




Codex can also answer questions or update the PR. Try commenting "@codex address that feedback".
            
</details>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (4)</summary>

**`src/auto-reply/dispatch.ts`**
[P1] `dispatchInboundMessage()` now blocks on hook execution.

`await triggerInternalHook(hookEvent);` runs before agent processing, so any slow hook will add latency to every inbound message (and hooks are user-extensible). If the intent is ‚Äúasync, non-blocking‚Äù as the PR description states, this should be scheduled (e.g., fire-and-forget with error reporting) or explicitly documented as intentionally synchronous.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/auto-reply/dispatch.ts
Line: 16:18

Comment:
[P1] `dispatchInboundMessage()` now blocks on hook execution.

`await triggerInternalHook(hookEvent);` runs before agent processing, so any slow hook will add latency to every inbound message (and hooks are user-extensible). If the intent is ‚Äúasync, non-blocking‚Äù as the PR description states, this should be scheduled (e.g., fire-and-forget with error reporting) or explicitly documented as intentionally synchronous.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/auto-reply/dispatch.ts`**
[P1] `timestamp` is duplicated/inconsistent between `event.timestamp` (Date) and `event.context.timestamp` (string).

`createInternalHookEvent()` already sets `timestamp: new Date()`. Adding `timestamp: new Date().toISOString()` into `context` creates two different timestamp fields with different types, which is confusing for hook authors. Consider removing the context `timestamp` (or renaming it if you need a separate value).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/auto-reply/dispatch.ts
Line: 14:16

Comment:
[P1] `timestamp` is duplicated/inconsistent between `event.timestamp` (Date) and `event.context.timestamp` (string).

`createInternalHookEvent()` already sets `timestamp: new Date()`. Adding `timestamp: new Date().toISOString()` into `context` creates two different timestamp fields with different types, which is confusing for hook authors. Consider removing the context `timestamp` (or renaming it if you need a separate value).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/auto-reply/dispatch.ts`**
[P2] Debug logging is unconditional and may leak message content.

The `console.log` includes a substring of the user message body. If this runs in production, it can leak PII/user content and add noisy logs. Prefer routing through the repo‚Äôs logger with log-level gating (or guard behind a dev/debug flag).

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/auto-reply/dispatch.ts
Line: 15:18

Comment:
[P2] Debug logging is unconditional and may leak message content.

The `console.log` includes a substring of the user message body. If this runs in production, it can leak PII/user content and add noisy logs. Prefer routing through the repo‚Äôs logger with log-level gating (or guard behind a dev/debug flag).

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/hooks/internal-hooks.ts`**
[P3] Event-type comment is now stale.

The `InternalHookEvent.type` docstring lists `(command, session, agent, gateway, etc.)` but `message` is now a first-class type. Updating the comment helps hook authors discover the new event.

<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/hooks/internal-hooks.ts
Line: 16:16

Comment:
[P3] Event-type comment is now stale.

The `InternalHookEvent.type` docstring lists `(command, session, agent, gateway, etc.)` but `message` is now a first-class type. Updating the comment helps hook authors discover the new event.

How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>

### @rodrigoschott (2026-02-03)

## üìã Update: Addressed Review Feedback

All review comments have been addressed in the latest commit:

### ‚úÖ Fixed Issues

| Issue | Fix |
|-------|-----|
| **P0** - `BodyForAgent` undefined | Now uses `${finalized.BodyForAgent ?? ""}` |
| **P1** - Duplicate timestamp | Removed from context (already exists in `event.timestamp`) |
| **P2** - Debug logging | Removed all `console.log` statements |
| **P2** - Message semantics | **NEW**: Separate `instructions[]` field from `messages[]` |
| **P3** - Docstring | Updated to include `message` type |

### üéØ Key Design Decision: `instructions` vs `messages`

Created separate field to avoid confusion:

- `event.instructions[]` ‚Üí Injected into LLM prompt (invisible to user)
- `event.messages[]` ‚Üí Sent to user as reply

This resolves the semantics issue raised by ChatGPT (P2).

### üìù Synchronous Execution (Intentional)

The `await` is necessary because injection must complete **before** agent processes. With fire-and-forget, injection would be lost (local variable `finalized` no longer exists after function returns).

---

**Awaiting re-review from bots.** üîÑ


## Stats

- **Size:** small (34+, 2-, 3 files)
- **Age:** 0 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
