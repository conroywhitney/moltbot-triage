---
number: 3565
title: "fix(sessions): truncate at incomplete tool calls instead of synthetic results"
author: kiranjd
created: 2026-01-28T20:46:28Z
updated: 2026-02-03T03:54:56Z
labels: ["agents"]
additions: 166
deletions: 29
changed_files: 3
size: medium
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 1
reactions_total: 1
ci_status: failing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/3565
fixes_issues: []
related_prs: []
duplicate_of: null
---

## Description

## Summary

When session history contains an assistant message with tool calls but missing results (due to branching, interruption, or crash), the API rejects the request with errors like:

> "an assistant message with 'tool_calls' must be followed by tool messages responding to each 'tool_call_id'"

**This change makes agents recover automatically instead of getting stuck.**

## What users experience

### Before (broken)
1. User messages agent
2. Agent is stuck, returns errors, won't respond
3. Only fix: manually delete entire conversation history
4. User loses everything

### After (fixed)
1. User messages agent
2. Agent responds normally
3. Agent may have forgotten one thing from earlier (the broken part)
4. User asks again if needed, conversation continues

## Technical details

### Root cause
Session files use a tree structure with branching. When linearizing the tree for API calls:
1. Tool calls and their results can end up on different branches
2. Linearization picks one path, potentially leaving tool results orphaned
3. API rejects the malformed history

### Previous approach (fragile)
- Scan transcript, try to re-associate orphaned tool results
- Insert synthetic error results for missing tool calls
- Drop orphaned results

Problems:
- Complex repair logic with many edge cases
- Synthetic error results confuse the conversation
- Still failed in some scenarios

### New approach (simple)
- Detect the first assistant message with incomplete tool calls
- Truncate history **before** that message
- Always produces valid history (just shorter)
- Log truncation details for debugging

### Code changes
- `session-transcript-repair.ts`: New `findFirstIncompleteToolCallIndex()` function, truncation logic
- `google.ts`: Log when truncation occurs for monitoring
- Tests updated to verify new behavior

## Alternatives considered

| Approach | Why rejected |
|----------|--------------|
| Insert synthetic error results | Confusing conversation state, fragile |
| Show error, ask user to fix | Users shouldn't need to understand session internals |
| Delete entire conversation | Too much data loss |
| Prevent all interruptions | Impossible (network issues, crashes, user edits) |

## Testing
- [x] Unit tests updated and passing
- [x] Lint passing
- [x] Build passing

ü§ñ Generated with [Claude Code](https://claude.com/code)

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR changes session transcript recovery to avoid provider rejections when an assistant tool-call turn lacks matching tool results. Instead of inserting synthetic error tool results, `repairToolUseResultPairing` now detects the first assistant message with missing tool results and truncates history before it, then reorders any in-span tool results and drops duplicates/orphans. `sanitizeSessionHistory` is updated to use the new repair report and log when truncation occurs, and tests were updated to cover the new truncation behavior.

<h3>Confidence Score: 3/5</h3>

- Mostly safe to merge, but the new truncation detection may miss the branch/orphan scenario it is meant to fix.
- Core change is localized and tests cover the new truncation behavior, but `findFirstIncompleteToolCallIndex` treats any matching toolResult anywhere in the transcript as satisfying a tool call, which can prevent truncation when results exist off-path (the described root cause). Logging change is low risk.
- src/agents/session-transcript-repair.ts

<!-- greptile_other_comments_section -->

**Context used:**

- Context from `dashboard` - CLAUDE.md ([source](https://app.greptile.com/review/custom-context?memory=fd949e91-5c3a-4ab5-90a1-cbe184fd6ce8))
- Context from `dashboard` - AGENTS.md ([source](https://app.greptile.com/review/custom-context?memory=0d0c8278-ef8e-4d6c-ab21-f5527e322f13))

<!-- /greptile_comment -->

## Reviews

### @greptile-apps ‚Äî COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (2)</summary>

**`src/agents/session-transcript-repair.ts`**
[P1] Truncation check can false-positive due to global toolResult scan

`findFirstIncompleteToolCallIndex` precomputes `allResultIds` by scanning *all* tool results anywhere in the transcript (`indexAllToolResultIds`). That means an assistant tool call will be considered ‚Äúcomplete‚Äù if a matching `toolResult` exists later on a different branch/turn, even if it won‚Äôt be included after linearization (the exact failure mode described in the PR). In that scenario, this function won‚Äôt truncate and the provider will still reject the request.

This is especially likely when the missing results are actually ‚Äúorphaned on another branch‚Äù rather than truly absent. Consider checking for tool results only within the linearized path/after the call turn (or the same span the reordering logic already scans) instead of globally.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/agents/session-transcript-repair.ts
Line: 80:83

Comment:
[P1] Truncation check can false-positive due to global toolResult scan

`findFirstIncompleteToolCallIndex` precomputes `allResultIds` by scanning *all* tool results anywhere in the transcript (`indexAllToolResultIds`). That means an assistant tool call will be considered ‚Äúcomplete‚Äù if a matching `toolResult` exists later on a different branch/turn, even if it won‚Äôt be included after linearization (the exact failure mode described in the PR). In that scenario, this function won‚Äôt truncate and the provider will still reject the request.

This is especially likely when the missing results are actually ‚Äúorphaned on another branch‚Äù rather than truly absent. Consider checking for tool results only within the linearized path/after the call turn (or the same span the reordering logic already scans) instead of globally.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>

---

**`src/agents/pi-embedded-runner/google.ts`**
[P2] Log may include untrusted tool call IDs and get very large

The truncation warning logs `missingToolCallIds.join(", ")` inline. If tool call IDs can be influenced by user/session contents (or just be numerous), this can produce noisy/oversized logs and make parsing harder. Consider logging them as structured data (array field) and/or truncating the list/count (e.g., first N ids + total) to keep logs bounded.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/agents/pi-embedded-runner/google.ts
Line: 341:348

Comment:
[P2] Log may include untrusted tool call IDs and get very large

The truncation warning logs `missingToolCallIds.join(", ")` inline. If tool call IDs can be influenced by user/session contents (or just be numerous), this can produce noisy/oversized logs and make parsing harder. Consider logging them as structured data (array field) and/or truncating the list/count (e.g., first N ids + total) to keep logs bounded.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** medium (166+, 29-, 3 files)
- **Age:** 5 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
