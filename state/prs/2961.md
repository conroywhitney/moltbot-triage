---
number: 2961
title: "fix(memory): support symlinks in memory file discovery"
author: kira-ariaki
created: 2026-01-27T21:18:25Z
updated: 2026-02-03T04:05:32Z
labels: []
additions: 111
deletions: 3
changed_files: 2
size: medium
review_decision: none
reviews: [{"author":"greptile-apps","state":"COMMENTED"}]
comments_count: 4
reactions_total: 1
ci_status: passing
mergeable: false
draft: false
url: https://github.com/openclaw/openclaw/pull/2961
fixes_issues: []
related_prs: [2884]
duplicate_of: null
---

## Description

## Summary

`walkDir` now follows symbolic links using `fs.stat()` to determine if the target is a file or directory. This enables:

- Symlinked markdown files inside `memory/` to be indexed
- Symlinked directories inside `memory/` to be traversed
- Graceful handling of dangling symlinks (silently skipped)

## Problem

The current `walkDir` implementation uses `dirent.isFile()` to check if an entry is a file. However, for symbolic links, `dirent.isFile()` returns `false` (the dirent type is "symbolic-link", not "file"), causing symlinks to be excluded from memory search indexing.

This is especially relevant for:
- Users who symlink external note directories into `memory/`
- The proposed workspace setup in #2884 that creates symlinks for identity files

## Solution

For entries that are symbolic links, we now call `fs.stat()` (which follows symlinks) to determine the actual target type:

```typescript
if (entry.isSymbolicLink()) {
  try {
    const stat = await fs.stat(full);
    isDir = stat.isDirectory();
    isFile = stat.isFile();
  } catch {
    // Dangling symlink or inaccessible target - skip silently
    continue;
  }
}
```

## Cross-platform notes

- **Linux/macOS**: Works as expected
- **Windows**: Creating symlinks may require elevated permissions, but **reading** existing symlinks works without special privileges
- Dangling symlinks are gracefully skipped (no errors thrown)

## Test plan

- [x] Added test: symlinked markdown files are discovered
- [x] Added test: files inside symlinked directories are discovered  
- [x] Added test: dangling symlinks are skipped gracefully
- [x] Existing tests unaffected

Related: #2884

<!-- greptile_comment -->

<h2>Greptile Overview</h2>

<h3>Greptile Summary</h3>

This PR updates `walkDir` in `src/memory/internal.ts` to treat symlink entries specially by `stat()`ing them (following the link) so symlinked `.md` files and symlinked directories under `memory/` are included in `listMemoryFiles()` results, while dangling symlinks are skipped. It also adds Vitest coverage in `src/memory/internal.test.ts` for symlinked file discovery, symlinked directory traversal, and dangling symlink handling.


<h3>Confidence Score: 3/5</h3>

- Moderately safe to merge, but needs a symlink-loop/escape guard and CI-friendly symlink tests.
- The core change is small and targeted, but following symlinks introduces a real risk of infinite recursion and unintended traversal outside `memory/` if users add cyclic or external symlinks. The added tests also directly create symlinks, which can fail on Windows or restricted CI environments, reducing confidence without conditional skipping.
- src/memory/internal.ts, src/memory/internal.test.ts

<!-- greptile_other_comments_section -->

<sub>(5/5) You can turn off certain types of comments like style [here](https://app.greptile.com/review/github)!</sub>

<!-- /greptile_comment -->

## Reviews

### @greptile-apps — COMMENTED (2026-02-03)

<sub>2 files reviewed, 2 comments</sub>

<sub>[Edit Code Review Agent Settings](https://app.greptile.com/review/github) | [Greptile](https://greptile.com?utm_source=greptile_expert&utm_medium=github&utm_campaign=code_reviews)</sub>


## Comments

### @gumadeiras (2026-01-27)

Symlinking outside of the workspace could introduce a number of problems in terms of security, recurrence, and scoping. Would it maybe be better to add support for custom search paths and force the user to add them manually?

Adding explicit, user‑configured search paths is safer than automatically following arbitrary symlinks

### @kira-ariaki (2026-01-27)

Thanks for the feedback! You raise a valid point about security considerations.

A few thoughts:

1. **User intent is explicit** — Symlinks inside `memory/` are created by the user themselves, so following them respects an intentional configuration choice (similar to how git follows symlinks in the working tree).

2. **Scoped to workspace** — We only follow symlinks discovered inside the existing `memory/` directory, not arbitrary paths. The user must deliberately place a symlink there.

3. **Consistency with #2884** — The proposed workspace setup in #2884 creates symlinks for identity files. Without this fix, those symlinks would be silently ignored.

4. **Recursion safety** — `fs.stat()` follows the symlink to its final target, so circular symlinks would fail with ELOOP and be gracefully skipped (same as dangling symlinks).

That said, I agree that explicit search paths could be a nice enhancement for power users who want more control. Would you prefer that as a follow-up PR, or should we gate symlink traversal behind a config flag (e.g., `memorySearch.followSymlinks: true`)?

### @gumadeiras (2026-01-28)

> 1. **User intent is explicit** — Symlinks inside `memory/` are created by the user themselves, so following them respects an intentional configuration choice (similar to how git follows symlinks in the working tree).

Yes, but it can lead to unwanted situations where the user thinks it’s symlinking a single directory, but that directory could also contain symlinks, resulting in unwanted/insecure behavior. Or a simple attack where a symlink is created in the workspace to give it access to things outside of the workspace. We could think about hierarchical symlinking in terms of allowing `depth=1`, but that could become very ad hoc; I think having an explicit specification would be safer and simpler for a first pass at this feature

Let's put a pin on the symlinking for a couple of days and i'll get back on this after we've discussed implications

Could you do a follow up PR for explicit search paths? thanks!

### @greptile-apps (2026-02-03)

<details>
<summary>Additional Comments (1)</summary>

**`src/memory/internal.ts`**
[P0] Following symlinks can recurse infinitely (symlink loops) and/or escape the `memory/` subtree.

Because `walkDir` now calls `fs.stat()` and then recurses into `full` when the symlink points to a directory, a symlink like `memory/loop -> memory/` (or any parent/ancestor) will cause unbounded recursion. Similarly, a symlink like `memory/out -> /` will traverse outside the intended workspace memory area.

Consider guarding against this by tracking visited realpaths (or inodes) for directories you recurse into and/or rejecting symlink targets whose resolved path is outside `memoryDir`.


<details><summary>Prompt To Fix With AI</summary>

`````markdown
This is a comment left during a code review.
Path: src/memory/internal.ts
Line: 49:66

Comment:
[P0] Following symlinks can recurse infinitely (symlink loops) and/or escape the `memory/` subtree.

Because `walkDir` now calls `fs.stat()` and then recurses into `full` when the symlink points to a directory, a symlink like `memory/loop -> memory/` (or any parent/ancestor) will cause unbounded recursion. Similarly, a symlink like `memory/out -> /` will traverse outside the intended workspace memory area.

Consider guarding against this by tracking visited realpaths (or inodes) for directories you recurse into and/or rejecting symlink targets whose resolved path is outside `memoryDir`.


How can I resolve this? If you propose a fix, please make it concise.
`````
</details>
</details>


## Stats

- **Size:** medium (111+, 3-, 2 files)
- **Age:** 6 days
- **Last activity:** 2026-02-03

## Links

- Fixes: (none detected)
