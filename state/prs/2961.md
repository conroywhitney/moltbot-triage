---
number: 2961
title: "fix(memory): support symlinks in memory file discovery"
author: kira-ariaki
created: 2026-01-27T21:18:25Z
updated: 2026-01-28T23:25:10Z
labels: []
additions: 86
deletions: 3
changed_files: 2
size: medium
review_decision: none
reviews: []
comments_count: 3
reactions_total: 0
ci_status: passing
mergeable: unknown
draft: false
url: https://github.com/openclaw/openclaw/pull/2961
fixes_issues: []
related_prs: [2884]
duplicate_of: null
---

## Description

## Summary

`walkDir` now follows symbolic links using `fs.stat()` to determine if the target is a file or directory. This enables:

- Symlinked markdown files inside `memory/` to be indexed
- Symlinked directories inside `memory/` to be traversed
- Graceful handling of dangling symlinks (silently skipped)

## Problem

The current `walkDir` implementation uses `dirent.isFile()` to check if an entry is a file. However, for symbolic links, `dirent.isFile()` returns `false` (the dirent type is "symbolic-link", not "file"), causing symlinks to be excluded from memory search indexing.

This is especially relevant for:
- Users who symlink external note directories into `memory/`
- The proposed workspace setup in #2884 that creates symlinks for identity files

## Solution

For entries that are symbolic links, we now call `fs.stat()` (which follows symlinks) to determine the actual target type:

```typescript
if (entry.isSymbolicLink()) {
  try {
    const stat = await fs.stat(full);
    isDir = stat.isDirectory();
    isFile = stat.isFile();
  } catch {
    // Dangling symlink or inaccessible target - skip silently
    continue;
  }
}
```

## Cross-platform notes

- **Linux/macOS**: Works as expected
- **Windows**: Creating symlinks may require elevated permissions, but **reading** existing symlinks works without special privileges
- Dangling symlinks are gracefully skipped (no errors thrown)

## Test plan

- [x] Added test: symlinked markdown files are discovered
- [x] Added test: files inside symlinked directories are discovered  
- [x] Added test: dangling symlinks are skipped gracefully
- [x] Existing tests unaffected

Related: #2884

## Reviews


## Comments

### @gumadeiras (2026-01-27)

Symlinking outside of the workspace could introduce a number of problems in terms of security, recurrence, and scoping. Would it maybe be better to add support for custom search paths and force the user to add them manually?

Adding explicit, user‑configured search paths is safer than automatically following arbitrary symlinks

### @kira-ariaki (2026-01-27)

Thanks for the feedback! You raise a valid point about security considerations.

A few thoughts:

1. **User intent is explicit** — Symlinks inside `memory/` are created by the user themselves, so following them respects an intentional configuration choice (similar to how git follows symlinks in the working tree).

2. **Scoped to workspace** — We only follow symlinks discovered inside the existing `memory/` directory, not arbitrary paths. The user must deliberately place a symlink there.

3. **Consistency with #2884** — The proposed workspace setup in #2884 creates symlinks for identity files. Without this fix, those symlinks would be silently ignored.

4. **Recursion safety** — `fs.stat()` follows the symlink to its final target, so circular symlinks would fail with ELOOP and be gracefully skipped (same as dangling symlinks).

That said, I agree that explicit search paths could be a nice enhancement for power users who want more control. Would you prefer that as a follow-up PR, or should we gate symlink traversal behind a config flag (e.g., `memorySearch.followSymlinks: true`)?

### @gumadeiras (2026-01-28)

> 1. **User intent is explicit** — Symlinks inside `memory/` are created by the user themselves, so following them respects an intentional configuration choice (similar to how git follows symlinks in the working tree).

Yes, but it can lead to unwanted situations where the user thinks it’s symlinking a single directory, but that directory could also contain symlinks, resulting in unwanted/insecure behavior. Or a simple attack where a symlink is created in the workspace to give it access to things outside of the workspace. We could think about hierarchical symlinking in terms of allowing `depth=1`, but that could become very ad hoc; I think having an explicit specification would be safer and simpler for a first pass at this feature

Let's put a pin on the symlinking for a couple of days and i'll get back on this after we've discussed implications

Could you do a follow up PR for explicit search paths? thanks!


## Stats

- **Size:** medium (86+, 3-, 2 files)
- **Age:** 2 days
- **Last activity:** 2026-01-28

## Links

- Fixes: (none detected)
