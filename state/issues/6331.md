---
number: 6331
title: "[Bug] Cron module deadlock with periodic main+systemEvent+wakeMode:now tasks"
author: desicend
created: 2026-02-01T15:03:16Z
updated: 2026-02-01T20:58:41Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6331
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

# Bug Report: Cron module deadlock with periodic `main + systemEvent + wakeMode:now` tasks

## Environment

- **OpenClaw Version**: 2026.1.30
- **OS**: Linux 6.1.0-42-amd64 (x64)
- **Node.js**: v22.22.0
- **Gateway Mode**: local (loopback)

## Bug Description

The Cron module becomes completely unresponsive (all operations timeout) when a periodic task is created with the following configuration:

```json
{
  "schedule": { "kind": "every", "everyMs": <any_interval> },
  "sessionTarget": "main",
  "wakeMode": "now",
  "payload": { "kind": "systemEvent", "text": "..." }
}
```

## Steps to Reproduce

1. Create a periodic cron task with the configuration above (e.g., every 60 seconds)
2. Wait for the task to trigger multiple times
3. Attempt any cron operation (list, add, remove, status)
4. **Result**: All cron tool calls timeout (even with 60s timeout)

**Example task that triggered the issue**:
```json
{
  "id": "839ba4ce-6a59-421c-a671-8eee73b017e0",
  "name": "Test task",
  "enabled": true,
  "schedule": {
    "kind": "every",
    "everyMs": 60000
  },
  "sessionTarget": "main",
  "wakeMode": "now",
  "payload": {
    "kind": "systemEvent",
    "text": "[Test message]"
  }
}
```

## Expected Behavior

- Cron operations should complete within reasonable time (<5 seconds)
- Periodic tasks should not cause resource exhaustion or deadlocks
- If a task configuration is problematic, it should fail fast or be rejected

## Actual Behavior

- **All** cron tool operations timeout (tested with 10s, 30s, 60s timeouts)
- Other Gateway tools (exec, message, etc.) continue to work normally
- WebSocket connection remains healthy
- Gateway logs show repeated timeout errors:

```
2026-02-01T14:32:57.466Z error [tools] cron failed: gateway timeout after 10000ms
Gateway target: ws://127.0.0.1:18789
Source: local loopback
Config: /root/.openclaw/openclaw.json
Bind: loopback
```

- Previous successful cron operations took 99980ms, 63403ms, 25571ms (approaching timeout threshold)

## Impact

- **Severity**: High
- Entire cron functionality becomes unusable
- Cannot list, add, or remove any cron jobs
- Requires manual intervention (file editing + Gateway restart) to recover

## Workaround

1. Manually disable the problematic task in `/root/.openclaw/cron/jobs.json`:
```bash
cat /root/.openclaw/cron/jobs.json | jq '.jobs |= map(if .id == "<task_id>" then .enabled = false else . end)' > /tmp/jobs-fixed.json
mv /tmp/jobs-fixed.json /root/.openclaw/cron/jobs.json
```

2. Restart Gateway:
```bash
kill -HUP <gateway_pid>
```

## Root Cause Analysis (User Observation)

The combination of:
- Periodic scheduling (`every`)
- Main session target (`sessionTarget: "main"`)
- Immediate wake mode (`wakeMode: "now"`)
- System event payload (`kind: "systemEvent"`)

Appears to create a feedback loop or resource contention that causes the Cron module's request handler to block indefinitely.

## Suggested Fix

1. **Validation**: Reject or warn when creating tasks with `main + systemEvent + wakeMode:now + periodic schedule`
2. **Timeout handling**: Implement proper timeout/cancellation for cron operations
3. **Resource limits**: Add safeguards against recursive wake loops
4. **Documentation**: Clarify that periodic systemEvent tasks should use `isolated` session target

## Additional Context

- One-shot tasks (`kind: "at"`) with the same configuration work fine
- Using `sessionTarget: "isolated"` with `kind: "agentTurn"` for periodic tasks works correctly
- The issue persists across Gateway restarts until the task is manually disabled

## Related Logs

Session count during incident: 7 cron sessions accumulated
```
- agent:main:cron:75a86b8f-e868-4e99-80ee-ff8fba26a7e8
- agent:main:cron:252a3295-945a-4f09-97bc-ab8102c5d6f4
- agent:main:cron:20f39ded-64f1-4194-9918-3c016840aef3
- agent:main:cron:839ba4ce-6a59-421c-a671-8eee73b017e0 (problematic task)
- ... (3 more)
```

---

**Thank you for OpenClaw! This is an excellent project. Happy to provide more details if needed.**

## Comments

### @JanderV (2026-02-01)

## Proposed Fix — Patch for `cron/service/timer.js`

I hit a similar deadlock scenario (one-shot `at` jobs with past timestamps cascading) and traced it to the same root cause: **`executeJob` runs inside the lock**, blocking all cron API calls (`list`, `add`, `remove`, `status`) for the entire duration of job execution.

### Root Cause

In `onTimer()`, the entire flow — `ensureLoaded` → `runDueJobs` (which calls `executeJob` for each due job) → `persist` → `armTimer` — runs inside a single `locked()` call. Since `executeJob` can take minutes (isolated agent turns, or the 2-min heartbeat retry loop for main+wakeMode:now), every other cron operation queues behind it and times out.

### Patch (two changes)

**1. Execute jobs outside the lock**

Restructure `onTimer` to collect due jobs under lock (fast), then execute them outside the lock, then persist under lock:

```js
export async function onTimer(state) {
    if (state.running) return;
    state.running = true;
    try {
        const dueJobs = await locked(state, async () => {
            await ensureLoaded(state);
            return collectDueJobs(state);
        });
        for (const job of dueJobs) {
            const now = state.deps.nowMs();
            await executeJob(state, job, now, { forced: false });
            await locked(state, async () => {
                await persist(state);
            });
        }
        await locked(state, async () => {
            await persist(state);
            armTimer(state);
        });
    } finally {
        state.running = false;
    }
}
```

**2. Auto-disable stale one-shot jobs**

Prevent cascading from bad timestamps by skipping `at` jobs that are >5 minutes past due:

```js
const MAX_STALENESS_MS = 5 * 60_000;

export function collectDueJobs(state) {
    if (!state.store) return [];
    const now = state.deps.nowMs();
    const due = [];
    for (const j of state.store.jobs) {
        if (!j.enabled) continue;
        if (typeof j.state.runningAtMs === "number") continue;
        const next = j.state.nextRunAtMs;
        if (typeof next !== "number" || now < next) continue;
        if (j.schedule.kind === "at" && now - next > MAX_STALENESS_MS) {
            j.enabled = false;
            j.state.nextRunAtMs = undefined;
            state.deps.log.warn({ jobId: j.id, name: j.name, staleMs: now - next },
                "cron: auto-disabled stale one-shot job (>5min past due)");
            emit(state, { jobId: j.id, action: "finished", status: "skipped",
                error: "stale one-shot job — scheduled time too far in the past" });
            continue;
        }
        due.push(j);
    }
    return due;
}
```

### Why this helps

- **Fix 1** means `list`/`add`/`remove`/`status` no longer queue behind long-running job executions — they only wait for brief state reads/writes.
- **Fix 2** prevents the specific cascade where multiple past-due one-shot jobs (e.g., from wrong timestamps or gateway downtime) all fire simultaneously and overwhelm the system.

Both issues described in the OP (periodic main+systemEvent+wakeMode:now deadlock, and one-shot cascade) are addressed. The `state.running` flag still prevents concurrent timer ticks, so there's no race on job state.

Tested on 2026.1.30 — patched `dist/cron/service/timer.js` directly, gateway restart picks it up immediately.



## Links

- None detected yet
