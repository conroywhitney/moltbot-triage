---
number: 2831
title: "Feature Request: Per-tool approval gates (tools.ask)"
author: Jackten
created: 2026-01-27T15:36:32Z
updated: 2026-01-30T17:04:17Z
labels: ["enhancement"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/2831
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

# Tool approval / confirmation audit + feature request

## The Problem (Visual)

![Screenshot showing agent restarting without approval](https://files.catbox.moe/3jnpzj.jpg)

*The agent announced "Let me restart to apply and test it" and executed `gateway restart` before the user could intervene. User's "No!" came too late — the restart was already in progress.*

This is exactly why per-tool approval gates are needed.

## Findings (current state)

### 1) Explicit approval gates exist only for **exec/system.run**
- **Exec approvals file + policy knobs**: `~/.clawdbot/exec-approvals.json` with `security` (`deny|allowlist|full`), `ask` (`off|on-miss|always`), `askFallback`, and per‑agent allowlists. Source: `src/infra/exec-approvals.ts` (types + defaults) and `docs/tools/exec-approvals.md`.
- **Config knobs that influence approvals**:
  - `tools.exec.security` / `tools.exec.ask` / `tools.exec.askFallback` (config) — combined with approvals file to compute effective policy. Source: `src/config/types.tools.ts` + `docs/tools/exec-approvals.md`.
  - `approvals.exec.*` is **not** a gate; it only forwards exec approval prompts to chat targets. Source: `src/config/types.approvals.ts`, `src/config/zod-schema.approvals.ts`, `src/infra/exec-approval-forwarder.ts`.
- **Approval request/resolve flow**:
  - Gateway methods: `exec.approval.request` + `exec.approval.resolve`; broadcasts `exec.approval.requested|resolved`. Source: `src/gateway/server-methods/exec-approval.ts`, `src/gateway/server-broadcast.ts`, `src/gateway/server-methods-list.ts`.
  - Exec tool uses these methods and returns `approval-pending` when needed. Source: `src/agents/bash-tools.exec.ts`.
  - Node host enforces approvals/allowlists and consumes approval decisions. Source: `src/node-host/runner.ts`.
  - Discord UI surfaces approvals in chat. Source: `src/discord/monitor/exec-approvals.ts`.

### 2) General tool gating exists, but it’s **allow/deny** only (no approval prompt)
- **Tool policy filtering** is applied before tools are exposed to the model and before tool dispatch:
  - Global/per‑agent/per‑provider/per‑group/sandbox/subagent tool policy: `tools.allow`, `tools.deny`, `tools.byProvider`, `agents.*.tools`, `tools.sandbox.tools`, `tools.subagents.tools`, etc. Source: `src/config/types.tools.ts` and policy application in `src/agents/pi-tools.ts`.
  - Channel‑level overrides exist (Discord/Slack/MSTeams, etc.) using `tools` and `toolsBySender`, but they are still allow/deny lists, not approvals. Source: `src/config/types.discord.ts`, `src/config/types.slack.ts`, `src/config/types.msteams.ts` and channel docs in `docs/channels/*`.
  - Tool policy is documented (no interactive approvals). Source: `docs/gateway/sandbox-vs-tool-policy-vs-elevated.md`, `docs/gateway/configuration.md`, `docs/tools/index.md`, `docs/multi-agent-sandbox-tools.md`.

### 3) “Ask before running” exists for exec only
- `tools.exec.ask` + exec approvals are the only **ask-before-run** mechanism in code. Source: `src/config/types.tools.ts`, `src/agents/bash-tools.exec.ts`.
- No equivalent “ask” or “confirm” for other tools (`browser`, `read`, `write`, `edit`, `apply_patch`, `sessions_send`, etc.) in the dispatch pipeline.

### 4) Workflow approvals exist in docs (Lobster), but not in standard tool dispatch
- Docs describe Lobster workflows where a tool can return `needs_approval` and resume with a token. This is scoped to deterministic workflows, not the normal tool dispatcher. Source: `docs/automation/cron-vs-heartbeat.md`.

### 5) CLI confirmations exist, but they are **not** tool approvals
- There are many CLI confirm prompts for configuration, doctor, uninstall, etc. (`src/commands/*`). These are interactive CLI safety checks, not tool execution confirmations.

### 6) No evidence of a general “tool approval / confirm” feature in dispatch code
- The tool dispatcher (`src/agents/pi-tools.ts` + pi‑embedded runner) enforces allow/deny lists but does not pause for approval or emit approval requests for non‑exec tools.

---

## Feature request proposal: **Per‑tool approval gates**

### Problem statement
Clawdbot has a strong allow/deny **tool policy** and a robust **exec approval** system, but it lacks a general approval/confirmation step for *non‑exec* tools. Teams running in shared channels (or with mixed‑trust inputs) want Claude‑Code‑style “about to run X, approve?” prompts for tools like `browser`, `write`, `edit`, `apply_patch`, `sessions_send`, etc. Without this, operators must either deny tools entirely (too restrictive) or allow them without an interactive checkpoint (too permissive).

### Proposed solution (simplified config)
Introduce a single list of tools that require approval.

**New config (draft):**
```jsonc
{
  "tools": {
    "ask": ["exec", "browser", "write", "edit", "apply_patch", "sessions_send"]
  }
}
```

**Notes:**
- `tools.ask` is opt‑in; default empty means no behavior change.
- Tool policy allow/deny still applies first; approval only happens for tools that are allowed.
- Reuse the existing exec approval forwarding targets/UI for tool approvals to avoid a second approvals namespace.

### Behavior (actionable)
- If a tool is in `tools.ask`, the dispatcher emits a `tool.approval.request` and returns `approval-pending`.
- Approval resolution (`allow-once` or `deny`) replays or cancels the stored tool call.
- Keep approval storage in memory with a short timeout (e.g., 120s) and no allow‑always caching in the first cut.

### MVP / Minimal Implementation
1) **Config + validation**: add `tools.ask: string[]` with default `[]`.
2) **Approval gate**: in the tool invocation pipeline (pi‑embedded runner / dispatcher), check `tools.ask` right before execution.
3) **Approval flow**: add `tool.approval.request` + `tool.approval.resolve` and broadcasts, modeled after exec approvals.
4) **Storage**: in‑memory pending approvals with TTL; on timeout, auto‑deny and emit a resolved event.
5) **UI reuse**: route tool approvals through the existing approval UI/commands used for exec.

### Edge Cases
- **Idempotency**: replays for side‑effecting tools should be safe; store a single‑use approval token and reject duplicate replays.
- **PII in args**: sanitize/trim tool args before emitting approval requests; avoid logging secrets or large payloads.
- **Timeouts**: if approval arrives after TTL, return a clear “expired” response and require a new approval.
- **Subagent approvals**: decide whether subagent tool calls require approval and how they map to the parent session/agent.

---

## Summary
- Keep existing tool allow/deny policy as the first filter.
- Add a single `tools.ask` list to require approvals for specific tools.
- Implement the smallest approval loop (request → allow‑once/deny → replay) using existing exec approval UI.

## Comments

### @rodrigorm (2026-01-30)

Hey, I have the same request. I think an workflow like that will improve an loot on security trying to prevent prompt inject, by using lobster approval request to block exfiltrating, but right now lobster approval is decided by the llm itself so it can just bypass and self approve lobster envelope.


## Links

- None detected yet
