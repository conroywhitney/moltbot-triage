---
number: 4484
title: "[BUG] Sub-agent announce fails to route back to Slack — result appears in webchat instead"
author: spartakb
created: 2026-01-30T08:18:06Z
updated: 2026-01-31T02:30:36Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/4484
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Bug Description

When a sub-agent is spawned from a **Slack channel session**, the announce result sometimes fails to route back to Slack and instead appears only in the webchat dashboard. The error logged is:

```
Subagent announce failed: Error: Delivering to Slack requires target <channelId|user:ID|channel:ID>
```

This was observed when posting simultaneous messages in a Slack private channel — e.g., a main channel message and a thread reply at the same time. One message would be handled correctly, but the sub-agent spawned by the other would fail to deliver its result back to Slack.

## Reproduction Steps

1. Have a Slack private channel session (e.g., `agent:main:slack:channel:c0abweenegy`) with `noMention: true`
2. Send a message in the channel that triggers `sessions_spawn` (e.g., a research task)
3. Around the same time, send another message (e.g., a thread reply in the same channel, or the session receives a heartbeat/internal message)
4. Wait for the sub-agent to complete
5. **Expected**: Announce delivers the result back to the Slack channel
6. **Actual**: Announce fails — result appears only in the webchat dashboard window, never in Slack

## Root Cause Analysis

The session entry's `lastChannel` field gets contaminated from `"slack"` to `"webchat"` when any internal message touches the session (heartbeats, previous announce flows via `callGateway({ method: "agent" })`, etc.). The internal `agent` gateway method always sets `OriginatingChannel: INTERNAL_MESSAGE_CHANNEL` ("webchat"), which overwrites `lastChannel` on the session entry.

### Chain of events:

1. User sends a message from **Slack** → session `agent:main:slack:channel:c0abweenegy` is active
2. At some point, an internal message touches the session (heartbeat, a prior announce, or concurrent message processing) → `lastChannel` gets overwritten from `"slack"` to `"webchat"`
3. `sessions_spawn` captures `requesterOrigin` from `opts.agentChannel` / `opts.agentTo` which come from `ctx.OriginatingChannel` / `ctx.OriginatingTo`
   - If the inbound context was already contaminated: `agentChannel = "webchat"`, `agentTo = undefined`
   - Result: `requesterOrigin = { channel: "webchat" }` — **no `to` field** (webchat has no outbound target)
4. Sub-agent runs and completes
5. Announce flow fires (direct path, when no active run on requester session)
6. `directOrigin = { channel: "webchat" }` — no `to`
7. `callGateway({ method: "agent", deliver: true, channel: "webchat", to: undefined })`
8. `resolveAgentDeliveryPlan` sees `requestedChannel: "webchat"` → `INTERNAL_MESSAGE_CHANNEL`, but `wantsDelivery: true` → falls back to default channel → `"slack"`
9. `resolvedTo` is undefined (no explicit `to`, `lastChannel` doesn't match `resolvedChannel`)
10. Slack outbound plugin rejects: `"Delivering to Slack requires target <channelId|user:ID|channel:ID>"`

### Log evidence:

```
# 14+ failures from Jan 28-30 (all messages originated from Slack):
2026-01-28T01:22:54.882Z Subagent announce failed: Error: Delivering to Slack requires target <channelId|user:ID|channel:ID>
2026-01-28T01:24:36.149Z Subagent announce failed: ...
2026-01-28T02:31:48.936Z Subagent announce failed: ...
2026-01-28T15:06:41.180Z Subagent announce failed: ...
2026-01-28T17:12:28.299Z Subagent announce failed: ...
# ... repeated through Jan 30
```

Debug logging on the spawn tool confirmed the contaminated origin:
```
[spawn-debug] agentChannel=webchat agentTo=undefined requesterOrigin={"channel":"webchat"} sessionKey=agent:main:slack:channel:c0abweenegy
```

Session store showed the contaminated state:
```json
{
  "lastChannel": "webchat",          // should be "slack"
  "lastTo": "channel:C0ABWEENEGY",   // correct
  "channel": "slack",                // correct (set by routing, stable)
  "origin": {
    "provider": "webchat",           // contaminated (should be "slack")
    "to": "channel:C0ABWEENEGY"
  }
}
```

## Underlying Issues

### 1. `lastChannel` contamination (primary cause)
When any internal/webchat message touches a Slack/Discord channel session, `lastChannel` gets overwritten to `"webchat"`. This happens because `session.js` line ~175 sets:
```js
const lastChannelRaw = ctx.OriginatingChannel || baseEntry?.lastChannel;
```
And the `agent` gateway method (used by heartbeats, announce flows, webchat) always sets `OriginatingChannel: INTERNAL_MESSAGE_CHANNEL` ("webchat"). The `entry.channel` field (set by routing) remains correct, but `lastChannel` drifts.

### 2. `origin.provider` contamination
Session `origin` metadata also gets overwritten by internal runs, losing the original provider info.

### 3. `agentChannel` at spawn time
`sessions_spawn` captures `agentChannel` from `opts.agentChannel` (from `ctx.OriginatingChannel`) — which may already be "webchat" due to contamination, regardless of the session's actual channel.

## Suggested Fix

The announce flow should resolve the delivery channel from the session entry's canonical routing (`entry.channel`) rather than trusting `lastChannel` or the `requesterOrigin` captured at spawn time.

Local workaround applied: a `resolveCanonicalChannelFromEntry()` helper that checks `entry.channel` (stable, set by routing) instead of `lastChannel` (transient, gets contaminated):

```js
// In subagent-announce.js
import { INTERNAL_MESSAGE_CHANNEL } from "../utils/message-channel.js";

function resolveCanonicalChannelFromEntry(entry) {
    const originProvider = entry?.origin?.provider?.trim().toLowerCase();
    if (originProvider && originProvider !== INTERNAL_MESSAGE_CHANNEL && originProvider !== "heartbeat") {
        return originProvider;
    }
    // entry.channel is set by routing and is stable
    const sessionChannel = entry?.channel?.trim().toLowerCase();
    if (sessionChannel && sessionChannel !== INTERNAL_MESSAGE_CHANNEL) {
        return sessionChannel;
    }
    return undefined;
}
```

Applied in both `resolveAnnounceOrigin()` and the direct announce path in `runSubagentAnnounceFlow()`:

```js
const sessionDelivery = deliveryContextFromSession(entry);
const canonicalChannel = resolveCanonicalChannelFromEntry(entry);
if (canonicalChannel && sessionDelivery) {
    sessionDelivery.channel = canonicalChannel;
}
// When requesterOrigin is webchat but session belongs to a real channel, prefer session delivery
if (requesterOrigin?.channel === INTERNAL_MESSAGE_CHANNEL && sessionDelivery?.channel && sessionDelivery.channel !== INTERNAL_MESSAGE_CHANNEL) {
    directOrigin = mergeDeliveryContext(sessionDelivery, requesterOrigin);
}
```

### More comprehensive fix
The deeper issue is that `lastChannel` should not be overwritten by internal/webchat messages when the session is owned by a real channel. Either:
- Guard `lastChannel` writes to skip `INTERNAL_MESSAGE_CHANNEL` when the session's `channel` field is set to a real channel
- Or have `sessions_spawn` resolve `requesterOrigin` from the session's canonical routing (`entry.channel` + `entry.lastTo`) rather than from the transient inbound context

## Environment

- Clawdbot 2026.1.24-3 (885167d)
- macOS, Slack socket mode
- Session: Slack private channel with `noMention: true`
- Trigger: concurrent messages (main + thread reply) in the same channel, or any timing where a heartbeat/internal message touches the session between spawn and announce

## Comments


## Links

- None detected yet
