---
number: 7422
title: "[Feature]: Support model-specific cooldowns for providers with per-model quotas"
author: hardicd
created: 2026-02-02T20:10:26Z
updated: 2026-02-02T20:10:26Z
labels: ["enhancement"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/7422
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

 Description:

  Problem

  When using a provider that has model-specific quotas (e.g., google-antigravity where Claude and Gemini models have
  separate rate limits), the current failover logic fails to try fallback models.

  Current behavior:
  1. Primary model (google-antigravity/claude-sonnet-4-5) hits its quota
  2. Profile is marked with cooldownUntil at the profile level
  3. Failover checks the fallback model (google-antigravity/gemini-3-pro-high)
  4. Since both models share the same profile, and the profile is in cooldown, the fallback is skipped
  5. Request fails even though gemini has available quota

  Expected behavior:
  Fallback models should be attempted since they have independent quotas on the provider.

  Root Cause

  Cooldowns are tracked per-profile in ProfileUsageStats, but providers like Google Cloud (Vertex AI), AWS Bedrock, and
  google-antigravity have per-model quotas, not per-profile.

  Proposed TypeScript Changes

  1. Update ProfileUsageStats type in src/agents/auth-profiles/types.ts:

  /** Per-model cooldown stats for providers with model-specific quotas */
  export type ModelCooldownStats = {
    cooldownUntil?: number;
    disabledUntil?: number;
    disabledReason?: AuthProfileFailureReason;
    errorCount?: number;
    lastFailureAt?: number;
  };

  /** Per-profile usage statistics for round-robin and cooldown tracking */
  export type ProfileUsageStats = {
    lastUsed?: number;
    cooldownUntil?: number;
    disabledUntil?: number;
    disabledReason?: AuthProfileFailureReason;
    errorCount?: number;
    failureCounts?: Partial<Record<AuthProfileFailureReason, number>>;
    lastFailureAt?: number;
    /** Model-specific cooldowns for providers with per-model quotas */
    modelCooldowns?: Record<string, ModelCooldownStats>;
  };

  2. Update isProfileInCooldown in src/agents/auth-profiles/usage.ts:

  /**
   * Check if a profile is currently in cooldown (due to rate limiting or errors).
   * When model is provided, checks model-specific cooldowns first.
   */
  export function isProfileInCooldown(
    store: AuthProfileStore,
    profileId: string,
    model?: string
  ): boolean {
    const stats = store.usageStats?.[profileId];
    if (!stats) {
      return false;
    }

    // Check model-specific cooldown first
    if (model && stats.modelCooldowns?.[model]) {
      const modelStats = stats.modelCooldowns[model];
      const modelUnusable = resolveProfileUnusableUntil(modelStats);
      if (modelUnusable && Date.now() < modelUnusable) {
        return true;
      }
      return false; // Model-specific check passed, don't fall through to profile-level
    }

    // Fall back to profile-level cooldown (for auth errors affecting all models)
    const unusableUntil = resolveProfileUnusableUntil(stats);
    return unusableUntil ? Date.now() < unusableUntil : false;
  }

  3. Update markAuthProfileFailure params and computeNextProfileUsageStats:

  export async function markAuthProfileFailure(params: {
    store: AuthProfileStore;
    profileId: string;
    reason: AuthProfileFailureReason;
    cfg?: OpenClawConfig;
    agentDir?: string;
    model?: string;  // NEW: optional model for model-specific cooldowns
  }): Promise<void> {
    // ... pass model to computeNextProfileUsageStats
  }

  function computeNextProfileUsageStats(params: {
    existing: ProfileUsageStats;
    now: number;
    reason: AuthProfileFailureReason;
    cfgResolved: ResolvedAuthCooldownConfig;
    model?: string;  // NEW
  }): ProfileUsageStats {
    // ... existing logic ...

    // For rate_limit/billing with model specified, use model-specific cooldowns
    const isModelSpecificQuota = params.model &&
      (params.reason === "rate_limit" || params.reason === "billing");

    if (isModelSpecificQuota) {
      updatedStats.modelCooldowns = { ...params.existing.modelCooldowns };
      const modelStats = updatedStats.modelCooldowns[params.model] ?? {};
      // ... apply cooldown to modelStats instead of profile-level ...
    } else {
      // ... existing profile-level cooldown logic ...
    }
  }

  4. Update callers to pass model:

  In src/agents/model-fallback.ts:
  const isAnyProfileAvailable = profileIds.some(
    (id) => !isProfileInCooldown(authStore, id, candidate.model)  // pass model
  );

  In src/agents/pi-embedded-runner/run.ts, pass model: modelId to markAuthProfileFailure calls.

  Backward Compatibility

  - The model parameter is optional throughout
  - If not provided, behavior is unchanged (profile-level cooldowns)
  - Auth errors (401/403) should continue using profile-level cooldowns since they affect all models

  Use Case

  {
    "agents": {
      "defaults": {
        "model": {
          "primary": "google-antigravity/claude-sonnet-4-5",
          "fallbacks": ["google-antigravity/gemini-3-pro-high"]
        }
      }
    }
  }

  When claude-sonnet hits quota, gemini should be tried since it has independent quota.

  ---
  This is based on the actual TypeScript source.

## Comments


## Links

- None detected yet
