---
number: 6721
title: "Voice Call: Stale calls in calls.jsonl block new calls forever"
author: ario
created: 2026-02-02T00:25:02Z
updated: 2026-02-02T13:41:05Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6721
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Problem

The voice_call tool returns `Maximum concurrent calls (1) reached` even when no calls are active.

## Root Cause

`loadActiveCalls()` in `manager.ts` loads calls from `calls.jsonl` that aren't in terminal states. If a call was interrupted (gateway crash, network issue, etc.) without reaching a terminal state, it stays "active" forever.

**Example stale record:**
```json
{"callId":"49a7d28f-...","state":"initiated",...}
```

This call is days old but still blocks new calls because `initiated` isn't in `TerminalStates`.

## Location

`extensions/voice-call/src/manager.ts` lines 829-859:
```typescript
private loadActiveCalls(): void {
  // ...
  for (const [callId, call] of callMap) {
    if (!TerminalStates.has(call.state)) {
      this.activeCalls.set(callId, call);  // Stale calls loaded here
    }
  }
}
```

## Suggested Fix

Add stale call cleanup on startup - calls in non-terminal states older than X minutes (e.g., 30 min) should be marked as `ended` with `endReason: 'stale-timeout'`:

```typescript
const STALE_CALL_THRESHOLD_MS = 30 * 60 * 1000; // 30 minutes

private loadActiveCalls(): void {
  // ... existing code ...
  
  const now = Date.now();
  for (const [callId, call] of callMap) {
    if (!TerminalStates.has(call.state)) {
      const age = now - call.startedAt;
      if (age > STALE_CALL_THRESHOLD_MS) {
        // Mark as stale and persist
        call.state = 'ended';
        call.endedAt = now;
        call.endReason = 'stale-timeout';
        this.persistCall(call);
        continue; // Don't add to activeCalls
      }
      this.activeCalls.set(callId, call);
    }
  }
}
```

## Workaround

Manually append a terminal state record to `calls.jsonl`:
```bash
echo '{"callId":"<stale-call-id>","state":"ended","endReason":"manual-cleanup",...}' >> ~/clawd/voice-calls/calls.jsonl
```

## Environment

- OpenClaw 2026.1.24-3
- macOS arm64

## Comments

### @mazamizo21 (2026-02-02)

# OpenClaw voice-call (Twilio) — fixes for “Application error”, “call connects but no audio”, and hangups

> Goal: document the end-to-end fixes we applied so others can reproduce a working setup.
> 
> **Important:** This doc intentionally avoids secrets (Twilio SIDs/tokens) and personal phone numbers. Use placeholders.

## Symptoms → likely causes

### 1) Callee hears “Application error” immediately
Usually means Twilio failed to:
- fetch valid TwiML from your webhook, **or**
- connect to the Media Streams WebSocket specified in TwiML.

### 2) Call connects but is silent / no bot voice
Common causes:
- Media stream isn’t actually reachable by Twilio (WebSocket endpoint not public / wrong URL / wrong scheme).
- Inbound call is **rejected by policy** (default inbound policy is disabled), so OpenClaw never “owns” the call.
- Conversation mode bugs/limitations (see open issues below).

### 3) Call drops / hangs up in conversation mode
Often overlaps with the above, plus known conversation-mode instability in some versions.

## Working architecture (high-level)
- **Twilio Programmable Voice** answers the PSTN call.
- Twilio hits OpenClaw’s **/voice/webhook** (public HTTPS) to get TwiML.
- TwiML uses `<Connect><Stream url="wss://…/voice/stream"/></Connect>` so Twilio opens a **WebSocket** to OpenClaw.
- OpenClaw receives audio from Twilio over the stream and sends audio back (TTS) over the same stream.

**Key point:** Twilio must be able to reach BOTH:
- `https://<public-host>/voice/webhook`  (TwiML)
- `wss://<public-host>/voice/stream`     (Media Streams)

## What we changed (the actual fixes)

### Fix A — expose the voice endpoints publicly (Tailscale Funnel)
Twilio needs a public URL. We used Tailscale Funnel to expose the local voice server.

The voice-call server runs locally at something like:
- `http://127.0.0.1:3334`

Expose it via Funnel under a stable path:

```bash
openclaw voicecall expose --mode funnel --path /voice --port 3334 --serve-path /voice
```

Confirm:
```bash
tailscale funnel status
```

You should see routes similar to:
- `/voice` → `http://127.0.0.1:3334`
- `/voice/webhook` → `http://127.0.0.1:3334/voice/webhook`
- `/voice/stream` → `http://127.0.0.1:3334/voice/stream`

Why this matters:
- The original “Application error” happened when `/voice/stream` wasn’t reachable by Twilio.

### Fix B — ensure your TwiML uses the PUBLIC `wss://…/voice/stream` URL
Your webhook must return TwiML that points to the public WebSocket endpoint, e.g.:

```xml
<Response>
  <Connect>
    <Stream url="wss://<your-funnel-host>.ts.net/voice/stream" />
  </Connect>
</Response>
```

If it points at `ws://127.0.0.1:3334/...` or a tailnet-only URL, Twilio won’t be able to connect.

### Fix C — enable inbound calls (policy defaults to disabled)
OpenClaw defaults to:
- `inboundPolicy: "disabled"`

That produces logs like:
- `Inbound call rejected: policy is disabled`
- `No active call found for provider ID: <CallSid>`

Fix by allowlisting your caller number:

```json5
plugins: {
  entries: {
    "voice-call": {
      enabled: true,
      config: {
        inboundPolicy: "allowlist",
        allowFrom: ["+1XXXXXXXXXX"],
        inboundGreeting: "Hey — I can hear you. Say something and I’ll respond.",
      }
    }
  }
}
```

### Fix D — Funnel persistence across restarts
In our case, after a gateway restart the exposure sometimes reverted to tailnet-only.

Workaround:
- Re-run the expose command after restart, or
- Use:

```bash
tailscale funnel --bg --set-path /voice 3334
```

(Exact persistence behavior can depend on how you configured Tailscale serve/funnel and whether another service also owns `/`.)

## Verification checklist (copy/paste)

### 1) Webhook returns TwiML
```bash
curl -i -X POST https://<your-funnel-host>.ts.net/voice/webhook
```
Expect: `200` and `content-type: application/xml`.

### 2) WebSocket endpoint accepts upgrade (PUBLIC)
Use an HTTP/1.1 WebSocket handshake:

```bash
curl --http1.1 -i \
  -H 'Connection: Upgrade' \
  -H 'Upgrade: websocket' \
  -H 'Sec-WebSocket-Version: 13' \
  -H 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==' \
  https://<your-funnel-host>.ts.net/voice/stream
```
Expect: `HTTP/1.1 101 Switching Protocols`.

Note: If you don’t send a proper WS handshake, you may see `400`/`405`/`404` and misdiagnose it.

### 3) Watch logs during a test call
Useful files:
- `/tmp/openclaw/openclaw-YYYY-MM-DD.log`
- `~/.openclaw/logs/gateway.log`
- `~/.openclaw/logs/gateway.err.log`
- `~/.openclaw/voice-calls/calls.jsonl`

Look for:
- `WebSocket upgrade for media stream`
- `MediaStream Twilio connected`
- `Stream started: MZ... (call: CA...)`
- `Speaking initial message...`

If you still see `No active call found for provider ID`, you’re still failing policy or call tracking.

## References (related open issues)
- #5732 — conversation mode drops call immediately / no audio
  https://github.com/openclaw/openclaw/issues/5732
- #4820 — Streaming returns 404, non-streaming ignores Gather callbacks
  https://github.com/openclaw/openclaw/issues/4820
- #5131 — accepts calls but never generates/serves TTS audio
  https://github.com/openclaw/openclaw/issues/5131

## “What finally made it work” (one-paragraph summary)
We fixed the call failures by (1) exposing OpenClaw’s `/voice/webhook` and `/voice/stream` publicly via **Tailscale Funnel**, (2) confirming TwiML pointed at the **public** `wss://…/voice/stream` endpoint and that it upgraded successfully (HTTP 101), and (3) enabling inbound calling by setting `inboundPolicy: "allowlist"` with `allowFrom` so OpenClaw would accept/track inbound calls and actually speak audio back.

## Secure Production Setup (The "Hospital Trick")
*Added Feb 2, 2026*

We hardened the above setup to make it secure enough for permanent public exposure.

### 1. Enable Signature Verification
In `~/.openclaw/openclaw.json`, set:
```json
"skipSignatureVerification": false
```
This forces OpenClaw to validate that every request is signed by Twilio using your `authToken`. External scanners or hackers will receive a `403 Forbidden`.

### 2. Harden the WebSocket Path
We changed the stream path from the default `/voice/stream` to a random, unguessable path to prevent probing of the raw socket.
In `openclaw.json`:
```json
"streamPath": "/voice/stream-secure-9x2k1"
```
*Note: Ensure your TwiML or webhook logic points to this new secure URL.*

### 3. Public Funnel with App-Layer Security
We use **Tailscale Funnel** to allow Twilio's public servers to reach us, but we rely on the application-layer security (Signature Validation) to protect the machine.

```bash
# Expose the voice service securely headers-first
tailscale funnel --bg --https=443 --set-path /voice http://127.0.0.1:3334/voice
```

### Verification
If the call connects, **Security is Working**.
If you see `Twilio signature verification failed` in `gateway.err.log`, check your `authToken`.



## Links

- None detected yet
