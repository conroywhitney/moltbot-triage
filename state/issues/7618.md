---
number: 7618
title: "Feature Request: Post-compaction prompt injection (compaction.postCompactionPrompt)"
author: joetomasone
created: 2026-02-03T01:32:33Z
updated: 2026-02-03T01:32:33Z
labels: []
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/7618
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Problem

After auto-compaction, the agent wakes up with only a (often thin) summary and recent messages. The pre-compaction `memoryFlush` successfully writes state to disk files, but nothing triggers the agent to **read those files back** after compaction completes.

This creates an amnesia gap: the agent responds to follow-up messages without context of what it was just working on, despite that context existing in memory files.

## Current Behavior

1. Session nears context limit
2. `memoryFlush` triggers → agent writes to `memory/active_work.json`, daily notes, etc. ✅
3. Compaction runs → older messages summarized
4. User sends follow-up message
5. Agent responds **without reading memory files** ❌
6. User experiences amnesia/context loss

## Proposed Solution

Add a `compaction.postCompactionPrompt` config option (parallel to `memoryFlush`):

```json
{
  "compaction": {
    "memoryFlush": { ... },
    "postCompaction": {
      "enabled": true,
      "prompt": "Context was just compacted. Read memory/active_work.json and memory/YYYY-MM-DD.md to restore state before responding to any user messages.",
      "systemPrompt": "You were just compacted. Restore context from memory files."
    }
  }
}
```

When compaction completes, Clawdbot would inject this prompt as the next turn (similar to how memoryFlush injects a pre-compaction turn). The agent reads its files, restores context, then handles the pending user message.

## Workaround

Currently working around this by adding detection rules to AGENTS.md ("if summary seems thin or message seems like follow-up, read memory files first"). This is fragile and relies on the agent recognizing it was compacted.

## Impact

This would close the loop on anti-compaction measures:
- **Before:** memoryFlush writes state ✅
- **After:** postCompaction reads state ✅

Would significantly improve continuity for long-running sessions.

---

Discussed with @joetomasone on 2026-02-03.

## Comments


## Links

- None detected yet
