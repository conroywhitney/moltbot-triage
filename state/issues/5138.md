---
number: 5138
title: "[Bug]: MemoryIndexManager INDEX_CACHE leaks file descriptors, watchers, and timers"
author: coygeek
created: 2026-01-31T03:33:13Z
updated: 2026-02-02T00:20:15Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5138
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description


**Severity:** P1/High (Score: 90/150)
**CWE:** [CWE-404](https://cwe.mitre.org/data/definitions/404.html) - Improper Resource Shutdown or Release
**OWASP:** [A05:2021](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security Misconfiguration
**File:** `src/memory/manager.ts:114, 176-206, 600-625`

| Factor | Assessment | Score |
|--------|------------|-------|
| **Reachability** | Memory search config changes | 25/40 |
| **Impact** | FD, watcher, timer accumulation | 30/50 |
| **Exploitability** | Config changes create new keys | 10/30 |
| **Verification** | Code confirmed with nuance | 25/30 |
| **Total** | â€” | **90/150** |

## Summary
The `INDEX_CACHE` for MemoryIndexManager instances holds heavy resources (SQLite database handles, file system watchers, timers) but has no eviction mechanism. When cache keys change due to configuration updates, old managers remain cached indefinitely with all resources open, causing resource exhaustion.

**Note:** A `close()` method exists (lines 600-625) that properly cleans up resources and removes from cache, but it is never called automatically when cache keys change - old managers persist.

## Steps to reproduce
1. Run the gateway with memory search enabled
2. Change memory search settings (chunking params, provider, paths) multiple times
3. Each change creates a new cache key; old managers remain in cache
4. Monitor file descriptor count, inotify watches, and timer counts growing

## Expected behavior
Old MemoryIndexManager instances should be closed and evicted when no longer in use, releasing their resources.

## Actual behavior
The cache has no max size, no TTL, and no eviction. Old managers persist with all resources open.

### Affected code location:
**File** (`src/memory/manager.ts:114-206`):
```typescript
// Line 114 - Module-level cache with no max size
const INDEX_CACHE = new Map<string, MemoryIndexManager>();

// Lines 176-206 - Static getter creates new manager if key changes
static async get(params: {
  cfg: OpenClawConfig;
  agentId: string;
}): Promise<MemoryIndexManager | null> {
  const settings = resolveMemorySearchConfig(cfg, agentId);
  if (!settings) return null;
  const workspaceDir = resolveAgentWorkspaceDir(cfg, agentId);
  const key = `${agentId}:${workspaceDir}:${JSON.stringify(settings)}`;
  const existing = INDEX_CACHE.get(key);
  if (existing) return existing;
  // ... creates new manager with heavy resources
  const manager = new MemoryIndexManager({...});
  INDEX_CACHE.set(key, manager);
  return manager;
}
```

**Each cached manager holds** (lines 142-174):
- `db: DatabaseSync` - Open SQLite database handle
- `watcher: FSWatcher` - Chokidar file system watcher
- `watchTimer`, `sessionWatchTimer`, `intervalTimer` - Active timers
- Multiple internal Maps and Sets

**Existing close() method** (lines 600-625):
```typescript
async close(): Promise<void> {
  if (this.closed) return;
  this.closed = true;
  // ... clears timers, closes watcher, closes db ...
  INDEX_CACHE.delete(this.cacheKey);  // Does remove from cache
}
```

## Environment
- Version: latest (main branch)
- OS: Any
- Install method: Any

## Logs or screenshots
N/A - issue is architectural

## Impact
- **File Descriptor Exhaustion**: Common OS limit is 256-1024 per process
- **Watch Handle Exhaustion**: Linux inotify limit is often ~65536 system-wide
- **Timer Accumulation**: Slows event loop with orphaned timers
- **SQLite WAL Files**: Accumulate on disk without cleanup
- **Unpredictable Failures**: Service degrades after days/weeks of operation

## Recommended fix
1. Add LRU eviction with max size limit to INDEX_CACHE, calling `manager.close()` when evicting:
```typescript
// When adding a new manager, check if we need to evict old ones
if (INDEX_CACHE.size >= MAX_CACHE_SIZE) {
  const oldest = findOldestManager();
  await oldest.close();  // close() already removes from cache
}
```

2. Or add a periodic cleanup that closes managers not accessed recently
3. Or call `close()` on old manager when creating a new one with different key for same agentId

## Comments

### @coygeek (2026-02-01)

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 4.4 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H)



## Links

- None detected yet
