---
number: 6036
title: "[Bug]: Gateway agentRunSeq Map Never Pruned Causes Memory Exhaustion"
author: coygeek
created: 2026-02-01T06:38:17Z
updated: 2026-02-02T00:16:49Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6036
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.5 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)


## Summary

The gateway server maintains an `agentRunSeq` Map to track sequence numbers for agent runs, but this Map is never pruned. Unlike other Maps in the gateway context (`dedupe`, `chatAbortControllers`, `chatRunState.abortedRuns`) which are cleaned up in the maintenance loop, `agentRunSeq` accumulates entries indefinitely, causing slow memory exhaustion on long-running gateway servers.

## Affected Code

**File:** `src/gateway/server-runtime-state.ts:155`
```typescript
const agentRunSeq = new Map<string, number>();
```

**File:** `src/gateway/server-chat.ts:246-264`
```typescript
const last = agentRunSeq.get(evt.runId) ?? 0;
if (evt.seq <= last) {
  // skip duplicate
}
agentRunSeq.set(evt.runId, evt.seq);  // Entry added, never removed
```

**File:** `src/gateway/server-maintenance.ts:75-117`
```typescript
// Maintenance loop prunes other maps but NOT agentRunSeq
const dedupeCleanup = setInterval(() => {
  // Prunes: dedupe, chatAbortControllers, chatRunState.abortedRuns
  // MISSING: agentRunSeq is never cleaned up
}, 60_000);
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [ ] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [ ] None (unauthenticated/public access)
- [x] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Any authenticated gateway client initiating agent runs via WebSocket connection

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Gateway server running with authenticated clients making agent requests over time

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data disclosure |
| Integrity | None | No data modification |
| Availability | High | Gateway process memory exhaustion leading to OOM crash or degraded performance |

## Steps to Reproduce

1. Start a gateway server with persistent uptime
2. Make repeated agent runs from authenticated clients over days/weeks
3. Monitor memory usage of the gateway process
4. Observe that memory grows linearly with total unique `runId` values ever seen
5. Eventually gateway becomes unresponsive or crashes due to memory exhaustion

## Recommended Fix

Add `agentRunSeq` to the maintenance cleanup loop in `server-maintenance.ts`:

```typescript
// In the dedupeCleanup interval, add:
const agentRunSeqCleanup = setInterval(() => {
  const maxAge = 60 * 60 * 1000; // 1 hour
  const now = Date.now();
  // Either track timestamps with entries, or clear periodically
  // Option 1: Clear entire map on interval (loses sequence tracking for old runs)
  if (agentRunSeq.size > 10000) {
    agentRunSeq.clear();
  }
  // Option 2: Track timestamps and prune old entries
}, 60_000);
```

## References

- **CWE:** [CWE-770](https://cwe.mitre.org/data/definitions/770.html) - Allocation of Resources Without Limits or Throttling
- **Related:** Similar to other unbounded cache issues in the codebase (presence cache, sticker cache, rate limit map)

## Comments


## Links

- None detected yet
