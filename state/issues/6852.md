---
number: 6852
title: "[Bug]: Gemini batch API calls lack individual timeouts, can hang indefinitely"
author: coygeek
created: 2026-02-02T03:50:57Z
updated: 2026-02-02T03:50:57Z
labels: []
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6852
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.5 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)


## Summary

The Gemini batch API functions in `batch-gemini.ts` make multiple HTTP fetch calls (file upload, batch creation, status polling, result download) without individual timeouts. While `waitForGeminiBatch` has a polling timeout, if any single fetch call hangs, the timeout check never executes, causing indefinite blocking.

## Affected Code

**File:** `src/memory/batch-gemini.ts:137,169,196,214`

```typescript
async function submitGeminiBatch(
  apiKey: string,
  requests: GeminiRequest[],
): Promise<GeminiBatchStatus> {
  // Line 137 - NO TIMEOUT on file upload
  const fileRes = await fetch(uploadUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-Goog-Upload-Protocol": "raw" },
    body: uploadPayload.body,
  });

  // Line 169 - NO TIMEOUT on batch creation
  const batchRes = await fetch(batchEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ... }),
  });
}

async function fetchGeminiBatchStatus(apiKey: string, batchName: string): Promise<GeminiBatchStatus> {
  // Line 196 - NO TIMEOUT on status check
  const res = await fetch(statusUrl, {
    headers: { "Content-Type": "application/json" },
  });
}

async function fetchGeminiFileContent(apiKey: string, fileUri: string): Promise<string> {
  // Line 214 - NO TIMEOUT on result download
  const res = await fetch(downloadUrl, {
    headers: { "Content-Type": "application/json" },
  });
}
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [ ] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [ ] None (unauthenticated/public access)
- [x] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Memory embedding operations that use Gemini's batch API for processing embeddings. Triggered by memory-related agent operations.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Gemini API must experience slowdown or become unresponsive. Large file uploads are particularly prone to hanging on network issues.

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | High | Memory embedding operations hang silently, background tasks stall |

## Steps to Reproduce

1. Configure OpenClaw with Gemini API key for memory embeddings
2. Simulate slow Gemini API responses (e.g., using a proxy that delays responses)
3. Trigger a memory embedding operation (e.g., long conversation that triggers batch processing)
4. Observe that the batch operation hangs indefinitely
5. The `waitForGeminiBatch` timeout at line 271 never fires because the fetch is blocking

## Recommended Fix

Add AbortController with timeout to each fetch call:

```typescript
const GEMINI_FETCH_TIMEOUT_MS = 120_000; // 2 minutes for large uploads

async function fetchWithTimeout(url: string, options: RequestInit = {}): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), GEMINI_FETCH_TIMEOUT_MS);

  try {
    return await fetch(url, { ...options, signal: controller.signal });
  } finally {
    clearTimeout(timeoutId);
  }
}

// Replace all fetch() calls with fetchWithTimeout()
```

## References

- **CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption

## Comments


## Links

- None detected yet
