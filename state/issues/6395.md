---
number: 6395
title: "config.apply has no guard against catastrophic data loss"
author: aneym
created: 2026-02-01T16:32:36Z
updated: 2026-02-01T20:58:12Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6395
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Bug Description

`config.apply` will happily replace a full config (e.g. 4KB with env vars, channels, auth, plugins, etc.) with a near-empty stub like `{"tools":{"alsoAllow":["agents_list"]}}` (65 bytes). There is no server-side guard against this — the only checks are baseHash (prevents concurrent writes) and schema validation (passes because all fields are optional).

## Impact

When an agent accidentally calls `config.apply` instead of `config.patch` with a partial config object, **all** config data is destroyed:
- Environment variables (`env` section — API keys, tokens)
- Channel configs (Telegram, Slack, Discord bots)
- Auth profiles
- Skills / plugins
- Gateway settings (port, auth token, mode)
- Hooks, compaction settings, etc.

The gateway then crash-loops because critical settings like `gateway.mode` and `gateway.auth.token` are gone. Subsequent `config.patch` calls can rebuild parts of the config, but anything not explicitly re-added (like `env`) stays lost.

## How It Happened

1. Agent (in a sub-agent session) called `config.apply` with `{"tools":{"alsoAllow":["agents_list"]}}` — intending a partial update
2. This replaced the entire 4KB config with 65 bytes
3. Gateway crashed repeatedly: "gateway auth mode is token, but no token was configured"
4. Manual recovery required: restoring sections from backup files (`.bak.N`)

## Suggested Fix

Add a destructive-change guard to `config.apply` that rejects writes when the new config would drop a significant portion of existing top-level keys, unless explicitly overridden:

```typescript
// In config.apply handler, before writeConfigFile():
const allowDestructive = (params as { allowDestructive?: unknown }).allowDestructive === true;
if (snapshot.exists && snapshot.config && !allowDestructive) {
  const existingKeys = Object.keys(snapshot.config).filter((k) => k !== "meta");
  const newKeys = Object.keys(validated.config).filter((k) => k !== "meta");
  const droppedKeys = existingKeys.filter((k) => !newKeys.includes(k));
  if (droppedKeys.length > 0 && droppedKeys.length >= existingKeys.length * 0.5) {
    respond(false, undefined, errorShape(
      ErrorCodes.INVALID_REQUEST,
      `config.apply would drop ${droppedKeys.length} of ${existingKeys.length} top-level sections ` +
      `(${droppedKeys.join(", ")}). Use config.patch for partial updates, or pass allowDestructive: true to force.`
    ));
    return;
  }
}
```

This catches the common case (agent using apply instead of patch) while still allowing intentional full-config replacement via `allowDestructive: true`.

## Environment

- OpenClaw v2026.1.30
- macOS, local mode
- Agent model: claude-opus-4-5

## Comments


## Links

- None detected yet
