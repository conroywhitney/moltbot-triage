---
number: 7184
title: "Synthetic tool_result repair creates API-invalid state (permanent session corruption)"
author: Datmandxb
created: 2026-02-02T14:24:32Z
updated: 2026-02-02T23:14:57Z
labels: []
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/7184
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Bug Description

When a tool execution result is lost (e.g., exec timeout, gateway restart mid-execution), OpenClaw's transcript repair inserts a synthetic `tool_result`:

```
[openclaw] missing tool result in session history; inserted synthetic error result for transcript repair.
```

This synthetic repair creates a state that the Anthropic API rejects with:

```
LLM request rejected: messages.22.content.1: unexpected tool_use_id found in
tool_result blocks: toolu_01Lo3sWsfBrupsCSM8BpBZzH. Each tool_result block must
have a corresponding tool_use block in the previous message.
```

The session becomes **permanently corrupted** — every subsequent API call fails with the same error. The gateway logs `Profile anthropic:default hit Cloud Code Assist format error. Tool calls will be sanitized on retry.` but the sanitizer cannot fix this state. The only recovery is to manually archive the session file and restart.

## Reproduction

1. Start a session with multiple tool calls (e.g., document processing via `exec`)
2. Have a tool call whose result is lost (e.g., unterminated heredoc causing exec timeout, or gateway restart mid-execution)
3. On next API call, OpenClaw inserts the synthetic repair
4. All subsequent API calls to Anthropic fail permanently

## Impact

- We have experienced this **3 times in 2 days** on a production gateway
- Each incident required manual SSH intervention to archive the session and restart
- The assistant is completely unresponsive until manual recovery
- All incidents occurred during document-heavy workflows (Google Drive document processing, file creation)

## Expected Behavior

The synthetic tool_result repair should produce a message structure that the Anthropic API accepts. Specifically, the repaired `tool_result` blocks must have matching `tool_use` blocks in the preceding assistant message.

Alternatively, if the session state is unrecoverable, the gateway should automatically rotate to a new session rather than entering a permanent error loop.

## Environment

- OpenClaw version: 2026.1.29 (upgraded to 2026.1.30, untested for this specific bug)
- Model: anthropic/claude-opus-4-5-20251101
- Context pruning: cache-ttl (1h)
- Compaction: safeguard

## Workaround

We deployed an auto-recovery cron that detects the format error loop and archives the corrupted session:

```bash
# Runs every 5 minutes
error_count=$(journalctl -u anabel-gateway.service --since "10min ago" --no-pager | grep -c "Cloud Code Assist format error")
if [ "$error_count" -ge 3 ]; then
    # Archive active session and restart
fi
```

## Comments

### @rodbland2021 (2026-02-02)

## Better workaround: In-place transcript repair (no session deletion needed)

We hit the same issue repeatedly on a production gateway running `anthropic/claude-opus-4-5` (v2026.1.30, now 2026.2.1). Our initial workaround was also nuking the session, but we found a better approach: **surgically removing only the broken entries from the JSONL transcript**, preserving the entire conversation history.

### Root cause analysis

The corruption has two layers:

1. **Synthetic repair entries** — OpenClaw inserts `[openclaw] missing tool result in session history; inserted synthetic error result for transcript repair` as a `toolResult`. This references a `tool_use_id` from the preceding assistant message.

2. **Compaction orphans the result** — When compaction later summarizes the assistant message containing the matching `tool_use`, the synthetic `tool_result` survives because it's a separate JSONL entry. Now it references a `tool_use_id` that no longer exists → permanent API 400.

The built-in `repairToolUseResultPairing` can't fix this because the orphan is in a structurally valid position — it just points to a compacted-away ID.

### Repair script

We wrote a Python tool that parses the `.jsonl` transcript and:

1. Finds all synthetic `tool_result` entries (by matching the `[openclaw] missing tool result` text)
2. Finds orphaned `tool_result` entries (no matching `tool_use` in any assistant message)
3. Finds orphaned `tool_use` blocks (no matching `tool_result`)
4. Removes the broken entries, and strips orphaned `tool_use` blocks from multi-block assistant messages
5. Verifies the repaired transcript has all tool calls properly paired

**Full script (307 lines, zero dependencies):** https://gist.github.com/rodbland2021/ee54e28fab443730068202249c6ca5bc

### Usage

```bash
# Dry run — see what would be fixed
python3 repair-session.py /path/to/session.jsonl --dry-run

# Repair to new file
python3 repair-session.py /path/to/session.jsonl

# Repair in-place (backup first!)
python3 repair-session.py session.jsonl -o session.jsonl
```

### Example output

```
Loading transcript: b7eae7a2.jsonl
  Loaded 126 entries
  Tool calls: 47
  Tool results: 47 (2 synthetic)

Repairs needed: 4
  [remove_synthetic_result] Line 89: toolu_01TB58fvKWsADDpYwdwvx37q
    Reason: Synthetic repair entry from OpenClaw — causes format errors on API
  [remove_synthetic_result] Line 94: toolu_016qmpHwQP1gyUxDMWmhgExj
    Reason: Synthetic repair entry from OpenClaw — causes format errors on API
  [remove_call_for_synthetic] Line 88: toolu_01TB58fvKWsADDpYwdwvx37q
    Reason: Tool call whose result was synthetic — removing both
  [remove_call_for_synthetic] Line 93: toolu_016qmpHwQP1gyUxDMWmhgExj
    Reason: Tool call whose result was synthetic — removing both

Result: 126 entries → 122 entries (4 removed)

Post-repair verification:
  Tool calls: 45
  Tool results: 45 (0 synthetic)
  Orphaned results: 0
  Orphaned calls: 0
  ✓ All tool calls and results are properly paired
```

### Automated integration

We also integrated this into a cron-based session monitor that detects the format error loop via `journalctl` and automatically runs the repair before falling back to session deletion:

```bash
# Detect format errors in last 10 minutes
error_count=$(journalctl -u clawdbot.service --since "10 minutes ago" --no-pager 2>/dev/null | grep -c "Cloud Code Assist format error")

if [ "$error_count" -ge 3 ]; then
    # Step 1: Try repair
    python3 repair-session.py "$transcript" -o "$transcript.repaired"
    if [ $? -eq 0 ]; then
        cp "$transcript" "$transcript.bak"
        mv "$transcript.repaired" "$transcript"
        systemctl restart gateway
        # Session preserved, no data loss
    else
        # Step 2: Fallback to archive only if repair fails
        mv "$transcript" "/archive/"
        systemctl restart gateway
    fi
fi
```

### Suggestion for OpenClaw core

Ideally this repair logic should happen inside the gateway itself — either:
- **Before API submission**: scan the message array for orphaned `tool_result` blocks and strip them (the `repairToolUseResultPairing` function almost does this but misses the compaction-created orphans)
- **During compaction**: treat `tool_use` + `tool_result` as atomic pairs that must be removed together

Happy to submit a PR if the maintainers think the approach is sound.



## Links

- None detected yet
