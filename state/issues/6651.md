---
number: 6651
title: "[Bug]: speed up performance: Dynamic Tool Discovery for OpenClaw"
author: Lennie
created: 2026-02-01T22:42:31Z
updated: 2026-02-01T22:42:31Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6651
duplicate_of: null
related_issues: [6647]
blocks: []
blocked_by: []
---

## Description

## Summary

Every request that is send to the API/as part of the context includes all a lot of things not needed.

This makes responses less accurate (the model more easily gets confused with larger contexts) - especially on smaller models people want to run locally. To safe money or for privacy reasons.

Code mode was proposed by Cloudflare for better handling for lots of MCP tools, what many have chosen to do is implement half of that and only implement the tool search feature.

## references for 

https://blog.cloudflare.com/code-mode/

https://www.anthropic.com/engineering/code-execution-with-mcp

https://www.anthropic.com/engineering/advanced-tool-use

## Proposed solution blueprint

# Dynamic Tool Discovery for OpenClaw

> **Note:** This is an advanced architectural change. Consider implementing [Skill & Tool Caching](./skill-tool-caching.md) first for immediate performance improvements with lower risk.

## Overview

Instead of loading all 20-30 tools into the LLM context on every request, this approach exposes only:
1. **Core tools** (always available): `read`, `exec`, `search_tools`, `call_tool`
2. **Discoverable registry**: All other tools live in a searchable registry

The LLM can search for tools, get their schemas, and then invoke them dynamically via `call_tool`.

## Relationship to Caching

This plan addresses **token usage** (smaller prompts), while #6647  addresses **request latency** (avoiding repeated work).

| Approach | Solves | Token Usage | Request Latency | Complexity |
|----------|--------|-------------|-----------------|------------|
| **Caching** | Repeated scanning/parsing | Unchanged (all tools still in prompt) | Much faster | Medium |
| **Dynamic Discovery** | Large prompt size | Much lower (4-5 core tools) | Slightly slower (search calls) | High |

**Recommendation:** Implement caching first, then dynamic discovery if token usage remains an issue.

## Benefits

- **Reduced token usage**: Only ~4-5 core tool schemas in context instead of 20-30
- **Faster prompts**: Less schema data to process
- **Scalable**: Adding more tools doesn't increase prompt size
- **Flexible**: LLM discovers tools based on task context

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     LLM Context (Small)                         │
├─────────────────────────────────────────────────────────────────┤
│  Core Tools:                                                    │
│  - read: Read files                                             │
│  - exec: Execute shell commands                                 │
│  - search_tools: Find available tools by query                  │
│  - call_tool: Invoke a tool by name with parameters             │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       │ calls search_tools("send message")
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│              Tool Registry (Lazy-Loaded)                        │
├─────────────────────────────────────────────────────────────────┤
│  Discovered Tools:                                              │
│  - message: Send messages to channels                           │
│  - sessions_send: Send to other sessions                        │
│  - browser: Control browser                                     │
│  - web_search: Search the web                                   │
│  - ... (20+ more tools)                                         │
└─────────────────────────────────────────────────────────────────┘
```

## Implementation Plan

### Phase 1: Create Tool Registry

**New File: `src/agents/tools/tool-registry.ts`**

```typescript
export interface ToolRegistryEntry {
  name: string;
  description: string;
  parameters: unknown; // JSON schema
  factory: () => AnyAgentTool;
  category?: string;
  keywords?: string[];
}

export class ToolRegistry {
  private tools = new Map<string, ToolRegistryEntry>();
  
  register(entry: ToolRegistryEntry): void;
  search(query: string): ToolRegistryEntry[];
  get(name: string): ToolRegistryEntry | undefined;
  list(): ToolRegistryEntry[];
}
```

### Phase 2: Modify Tool Creation

**Modify: `src/agents/openclaw-tools.ts`**

Instead of returning instantiated tools, register them in the registry:

```typescript
// OLD: Returns instantiated tools
export function createOpenClawTools(options?: {...}): AnyAgentTool[] {
  return [
    createBrowserTool({...}),  // Instantiated
    createMessageTool({...}),  // Instantiated
    // ... all tools instantiated
  ];
}

// NEW: Register in registry, return only core tools
export function registerOpenClawTools(registry: ToolRegistry, options?: {...}): void {
  registry.register({
    name: "browser",
    description: "Control OpenClaw's dedicated browser",
    parameters: browserToolSchema,
    factory: () => createBrowserTool({...}),
    category: "automation",
    keywords: ["browser", "web", "navigate", "click"]
  });
  // ... register all other discoverable tools
}

export function createCoreTools(options?: {...}): AnyAgentTool[] {
  return [
    createReadTool({...}),
    createExecTool({...}),
    createSearchToolsTool(registry),  // NEW
    createCallToolTool(registry),     // NEW
  ];
}
```

### Phase 3: Implement Meta-Tools

**New File: `src/agents/tools/search-tools-tool.ts`**

```typescript
export function createSearchToolsTool(registry: ToolRegistry): AnyAgentTool {
  return {
    name: "search_tools",
    description: `Search for available tools by query. 
      Returns tool names, descriptions, and schemas.
      Use this to discover tools before calling them with call_tool.`,
    parameters: Type.Object({
      query: Type.String({ description: "Search query describing what you want to do" }),
      limit: Type.Optional(Type.Number({ default: 5 }))
    }),
    execute: async (_id, params) => {
      const results = registry.search(params.query);
      return {
        tools: results.slice(0, params.limit).map(r => ({
          name: r.name,
          description: r.description,
          parameters: r.parameters
        }))
      };
    }
  };
}
```

**New File: `src/agents/tools/call-tool-tool.ts`**

```typescript
export function createCallToolTool(registry: ToolRegistry): AnyAgentTool {
  return {
    name: "call_tool",
    description: `Invoke a tool by name with parameters.
      First use search_tools to find the right tool and its schema,
      then call it with this tool.`,
    parameters: Type.Object({
      tool_name: Type.String(),
      parameters: Type.Record(Type.String(), Type.Unknown())
    }),
    execute: async (id, params) => {
      const entry = registry.get(params.tool_name);
      if (!entry) throw new Error(`Tool not found: ${params.tool_name}`);
      
      const tool = entry.factory();
      return tool.execute?.(id, params.parameters);
    }
  };
}
```

### Phase 4: Update Tool Splitting

**Modify: `src/agents/pi-embedded-runner/tool-split.ts`**

```typescript
export function splitSdkTools(params: {
  coreTools: AnyAgentTool[];  // Just the 4-5 core tools
  registry: ToolRegistry;      // Discoverable tools
  sandboxEnabled: boolean;
}): { builtInTools: AnyAgentTool[]; customTools: ToolDefinition[] } {
  // Only split the core tools - registry stays separate
  // The meta-tools (search_tools, call_tool) need registry access
}
```

### Phase 5: Update Policy Filtering

**Modify: `src/agents/pi-tools.policy.ts`**

Policies now apply at two levels:
1. **Registry level**: Which tools are registered (same filtering logic)
2. **Call-time level**: `call_tool` checks policy before executing

```typescript
// In call_tool.execute:
if (!isToolAllowedByPolicy(params.tool_name, policies)) {
  throw new Error(`Tool ${params.tool_name} is not allowed by policy`);
}
```

### Phase 6: Update System Prompt

**Modify: `src/agents/system-prompt.ts`**

The system prompt changes to guide the LLM on tool discovery:

```
## Tooling
You have access to core tools and a discoverable tool registry.

### Core Tools (always available):
- read: Read files from workspace
- exec: Execute shell commands
- search_tools: Find available tools by describing what you need
- call_tool: Invoke a discovered tool with parameters

### Using Discoverable Tools:
1. When you need functionality beyond core tools, call search_tools with a query
2. Review the returned tool names, descriptions, and parameter schemas
3. Call the tool using call_tool with the exact tool_name and parameters
4. If the tool result is unclear, you can search again or try a different tool

Example workflow:
<invoke name="search_tools">
{"query": "send a message to Discord"}
</invoke>

// Result: [{"name": "message", "description": "Send messages...", "parameters": {...}}]

<invoke name="call_tool">
{"tool_name": "message", "parameters": {"channel": "general", "text": "Hello"}}
</invoke>
```

## Configuration

Add config option to enable dynamic discovery:

```yaml
# openclaw.yaml
tools:
  discoveryMode: "dynamic"  # "static" (default) or "dynamic"
  coreTools:  # Always loaded in dynamic mode
    - read
    - exec
    - search_tools
    - call_tool
```

## Migration Path

1. **Default stays static**: Existing behavior unchanged
2. **Opt-in dynamic**: Users can enable `discoveryMode: "dynamic"`
3. **Gradual adoption**: Test with specific agents first

## Example Usage Flow

**User**: "Send a message to the team on Discord"

**Traditional (Static)**:
```
LLM sees all 30 tools → selects "message" tool → calls it directly
(30 tool schemas in context)
```

**Dynamic (New)**:
```
LLM sees 4 core tools → calls search_tools("send Discord message")
→ gets [{name: "message", ...}] → calls call_tool({tool_name: "message", ...})
(4 tool schemas + 1 search result in context)
```

## Trade-offs

| Aspect | Static | Dynamic |
|--------|--------|---------|
| Initial context size | Large (~30 tools) | Small (~4 tools) |
| Tool latency | Single call | Search + call (2 calls) |
| Token efficiency | Worse | Better |
| LLM reasoning | Direct | Requires planning |
| Multi-tool workflows | N sequential calls | N search+call pairs |
| Cache friendliness | Good | Search varies |

## When to Use Dynamic Mode

**Good for:**
- Agents with many (>20) tools
- Simple tasks using few tools
- Token-constrained environments

**Not ideal for:**
- Complex multi-tool workflows (too much back-and-forth)
- Time-sensitive tasks (extra latency from search calls)
- When tool relationships matter (search doesn't show relationships)

## Comments


## Links

- None detected yet
