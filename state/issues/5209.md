---
number: 5209
title: "STT pipeline skips audio files: OGG/Opus treated as text in media-understanding"
author: kxevol
created: 2026-01-31T05:55:08Z
updated: 2026-02-02T00:19:57Z
labels: ["bug"]
assignees: []
comments_count: 4
reactions_total: 1
url: https://github.com/openclaw/openclaw/issues/5209
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

> **TL;DR**: Audio files are silently skipped in `media-understanding/apply.js` because a text-likeness check is applied to binary audio data. One-line fix: change `kind === "audio"` to `kind !== "audio"` in the condition on ~line 200. This issue was identified and filed by an OpenClaw agent.

## Bug Description

Voice messages (audio attachments) are not being transcribed by the STT pipeline. Instead, the raw binary content is dumped as text into the session context.

## Root Cause

In `dist/media-understanding/apply.js` around line 200, when processing file attachments:

```javascript
if (!forcedTextMimeResolved && kind === "audio" && !textLike) {
    continue;  // SKIPS the audio file
}
```

This logic is inverted. When the attachment kind is `"audio"` and the buffer is **not** text-like (which is correct for binary audio data), the file is skipped with `continue` instead of being passed to the transcription pipeline. 

Audio binary data will never pass the `looksLikeUtf8Text()` check, so all audio files are silently dropped from media understanding. The raw binary then falls through to the text file attachment path, where it gets injected as garbled text.

## Expected Behavior
Audio files with kind `"audio"` should bypass the text-likeness check and be sent to the STT transcription pipeline.

## Actual Behavior
Audio files are skipped because they fail the UTF-8 text heuristic. The raw binary is then rendered as mojibake text in the session.

## Reproduction Steps
1. Configure any STT provider in openclaw.json (`tools.media.audio`)
2. Send a voice message to the agent
3. Observe that the agent receives raw binary instead of a transcript

## Suggested Fix
The condition should either:
- Skip the text-likeness check when `kind === "audio"` (let the audio pipeline handle it), or
- Invert the logic so audio files that are NOT text-like proceed to transcription

```javascript
if (!forcedTextMimeResolved && kind !== "audio" && !textLike) {
    continue;
}
```

## Comments

### @kxevol (2026-01-31)

## Root Cause Found

The issue description correctly identified the `extractFileBlocks` skip logic at line ~200 of `apply.ts`, but the actual root cause is upstream in `resolveUtf16Charset()`:

```javascript
// resolveUtf16Charset in apply.ts
const sampleLen = Math.min(buffer.length, 2048);
let zeroCount = 0;
for (let i = 0; i < sampleLen; i += 1) {
    if (buffer[i] === 0) zeroCount += 1;
}
if (zeroCount / sampleLen > 0.2) {
    return "utf-16le";  // FALSE POSITIVE for binary files
}
```

OGG Opus audio files typically have ~40% null bytes in the first 2048 bytes. This exceeds the 20% threshold, causing `resolveUtf16Charset` to falsely return `"utf-16le"`.

This flows into:
```javascript
const textLike = Boolean(utf16Charset) || looksLikeUtf8Text(bufferResult?.buffer);
if (!forcedTextMimeResolved && kind === "audio" && !textLike) {
    continue; // NEVER TRIGGERS because textLike is true
}
```

Since `utf16Charset` is truthy (`"utf-16le"`), `textLike` becomes `true`, and the audio skip condition `!textLike` is `false` — so the binary is NOT skipped and gets dumped as `<file mime="text/plain">`.

## Fix

The `!textLike` guard is unnecessary for audio/video — these should always be skipped from text extraction since they are handled by the `runCapability` transcription/description pipeline:

```typescript
// Before (broken):
if (!forcedTextMimeResolved && kind === "audio" && !textLike) {
    continue;
}

// After (fixed):
if (!forcedTextMimeResolved && (kind === "audio" || kind === "video")) {
    continue;
}
```

The original issue suggested changing `kind === "audio"` to `kind !== "audio"` — that would be incorrect as it would skip ALL non-audio files from text extraction. The actual fix is removing the `!textLike` guard for audio/video.

A secondary improvement would be making `resolveUtf16Charset` more robust against binary false positives (e.g., checking for valid UTF-16 code unit patterns, not just null byte ratio).

### @kxevol (2026-01-31)

## Update: Clarification & Fix Applied

**Reconciling the two failure modes described above:**

The original issue body described the *intended* behavior of the skip condition, but the actual root cause (found via runtime debug logging) is different:

1. **Expected:** `!textLike` should be `true` for binary audio → skip triggers → audio handled by transcription pipeline ✅
2. **Actual:** `resolveUtf16Charset()` falsely detects OGG null bytes as UTF-16 → `textLike = true` → skip does NOT trigger → binary dumped as `<file mime="text/plain">` ❌

So the issue body's TL;DR ("audio is skipped") was describing the *expected* path that never fires. The root cause comment above has the correct analysis.

**Fix applied in source (`apply.ts`):**

```typescript
// Remove textLike guard entirely for audio/video — these are always
// handled by runCapability transcription/description pipeline
if (!forcedTextMimeResolved && (kind === "audio" || kind === "video")) {
  continue;
}
```

**Re: `forcedTextMimeResolved` for audio/video:** Confirmed safe. `resolveTextMimeFromName()` only maps text extensions (.txt, .md, .csv, .json, .yaml, .xml, etc). Audio extensions (.ogg, .opus, .mp3, etc) are not in the map, so `forcedTextMimeResolved` is always `undefined` for audio/video files.

**Still needed:** Regression test with an OGG Opus sample to prevent this from recurring. The `resolveUtf16Charset` heuristic (>20% null bytes = UTF-16) should also be hardened — e.g. require alternating null/non-null pattern consistent with actual UTF-16 encoding.

### @kai-osthoff (2026-01-31)

We can confirm this also affects **Signal voice messages (.m4a)**. 

The root cause: M4A containers have ASCII-rich headers (`ftyp`, `moov`, `mdat` atom names, metadata) that can pass the 85% printable-bytes threshold in `looksLikeUtf8Text()`.

**Impact is significant:** Each voice message injects thousands of garbage characters (mojibake) into the agent context, rapidly exhausting the context window. This makes voice-heavy conversations practically unusable.

**Simplest fix:** Remove `&& !textLike` entirely — audio should always be skipped from text injection, regardless of byte patterns:

```javascript
if (!forcedTextMimeResolved && kind === "audio") {
    continue;
}
```

Audio belongs in the STT pipeline, never the text path.

### @Glucksberg (2026-01-31)

Submitted a fix in #5376 based on the excellent root cause analysis by @kxevol and @kai-osthoff in this thread.

**The fix (1 line):**
```diff
- if (!forcedTextMimeResolved && kind === "audio" && !textLike) {
+ if (!forcedTextMimeResolved && (kind === "audio" || kind === "video")) {
```

This removes the `&& !textLike` guard entirely, since audio/video should always be handled by the STT/description pipeline regardless of byte patterns.

Also commented on the alternative PR #5281 to compare approaches.


## Links

- None detected yet
