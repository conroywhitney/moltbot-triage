---
number: 5615
title: "[Bug]: Steer queue mode causes cross-thread reply contamination on Slack"
author: spartakb
created: 2026-01-31T18:33:03Z
updated: 2026-02-02T00:18:30Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 1
url: https://github.com/openclaw/openclaw/issues/5615
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

In `steer` queue mode, when multiple top-level messages arrive in a Slack channel in rapid succession, all replies get threaded under the first message instead of creating separate threads for each. The steer mechanism injects messages into the active run without checking whether the incoming message belongs to the same thread as the active run.

## Configuration

The key config that triggers this: `replyToMode: "all"` is set for Slack, which means every top-level channel message gets a threaded reply (reply posted as a thread under the original message). Combined with `messages.queue.mode: "steer"`, this creates the cross-thread contamination.

Relevant config:
```json
{
  "messages": {
    "queue": {
      "mode": "steer"
    },
    "replyToMode": "all"   // <-- replies go as threads to each message
  }
}
```

With `replyToMode: "all"`, each top-level message in a channel gets its own thread (the bot replies under it). So 3 rapid messages should produce 3 separate threads. Instead, steer collapses all replies into the first thread.

## Steps to reproduce

1. Configure `messages.queue.mode: "steer"` (global)
2. Set `replyToMode: "all"` for Slack (so replies are threaded under each message)
3. In a Slack channel, send 3 separate top-level messages in quick succession (within ~5 seconds), each containing a distinct instruction
4. Observe the thread behavior

## Expected behavior

Each top-level message should receive its own threaded reply. The agent should process each message independently with correct thread routing, creating 3 separate threads.

## Actual behavior

All replies from the agent land in the **first message's thread**. Messages 2 and 3 get ack reactions but their replies appear under message 1's thread. The agent processes all instructions correctly but routes all responses to the wrong parent.

## Root cause analysis

In `agent-runner.js`, when `shouldSteer && isStreaming`, the code calls:

```js
queueEmbeddedPiMessage(followupRun.run.sessionId, followupRun.prompt)
```

This injects the prompt text into the currently active run but **does not carry routing metadata** (`originatingThreadId`, `originatingChannel`, `originatingTo`). The active run's reply routing is locked to the first message's `threadId`, so all steered content gets replied to that thread.

For Slack with `replyToMode: "all"`, top-level channel messages each get a unique `threadId` (their message timestamp via the threading logic in `reply-threading.js`). When message 2 arrives while message 1's run is active and streaming, steer injects message 2's prompt into message 1's run. The run processes it and replies â€” but the reply goes to message 1's thread because that's where the run's routing points.

The fallback path (when steer fails or `shouldFollowup` is true) correctly preserves routing via `enqueueFollowupRun()` which carries `originatingThreadId` through the followup runner.

## Suggested fix

Before steering, compare the incoming message's `originatingThreadId` with the active run's thread. Only steer if they match (same thread). If they differ, skip steer and let the message go to the followup queue where per-message routing is preserved.

This preserves steer's value (interrupting within the same thread conversation) while preventing cross-thread contamination.

## Environment

- OpenClaw version: 2026.1.24-3
- OS: macOS (Darwin 23.1.0, arm64)
- Install method: pnpm (global)
- Channel: Slack (Socket Mode)

## Related

This is related to a separate issue where `collect` mode in `drain.js` uses `typeof i.originatingThreadId === "number"` to find thread IDs, but Slack thread timestamps are strings (e.g., `"1769742543.891709"`). This causes collected messages to lose their `originatingThreadId`, resulting in replies posted as top-level messages instead of threads. That type check should use `i.originatingThreadId != null` instead.

## Comments


## Links

- None detected yet
