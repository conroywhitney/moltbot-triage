---
number: 5258
title: "[Bug]: Slack thread starter cache grows unbounded causing memory exhaustion"
author: coygeek
created: 2026-01-31T07:53:32Z
updated: 2026-02-02T00:19:50Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5258
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description


## Summary

**Severity:** P1/High (Score: 85/150)
**CWE:** [CWE-770](https://cwe.mitre.org/data/definitions/770.html) - Allocation of Resources Without Limits or Throttling
**OWASP:** [A05:2021](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security Misconfiguration
**File:** `src/slack/monitor/media.ts:93`

The Slack thread starter cache uses a module-level Map with no TTL or size limit, causing memory to grow indefinitely until OOM in long-running processes.

**Why this is P1:** Gradual memory exhaustion over days/weeks of operation. No immediate attack required - normal usage triggers the leak.

## Triage Assessment

| Factor | Value | Score |
|--------|-------|-------|
| **Reachability** | Internal cache, grows with normal Slack usage | 15/40 |
| **Impact** | Memory exhaustion leading to OOM crash | 20/50 |
| **Exploitability** | Automatic over time, no attacker action needed | 20/30 |
| **Verification** | file:line ✓, code ✓, attack steps ✓ | 30/30 |
| **Total** | — | **85/150** |

## Steps to reproduce
1. Deploy OpenClaw with Slack integration on a busy workspace
2. Monitor memory usage over days/weeks
3. Observe steady memory growth proportional to unique thread count
4. Eventually process is OOM-killed

## Expected behavior
Cache should use TTL-based expiration and/or max size limits, like the existing `createDedupeCache` infrastructure in the codebase.

## Actual behavior
Every unique Slack thread creates a permanent cache entry that is never evicted.

### Affected code location:
**File** (`src/slack/monitor/media.ts:93-119`):
```typescript
const THREAD_STARTER_CACHE = new Map<string, SlackThreadStarter>();

export async function resolveSlackThreadStarter(params: {
  channelId: string;
  threadTs: string;
  client: SlackWebClient;
}): Promise<SlackThreadStarter | null> {
  const cacheKey = `${params.channelId}:${params.threadTs}`;
  const cached = THREAD_STARTER_CACHE.get(cacheKey);
  if (cached) return cached;

  // ... fetches from Slack API ...

  THREAD_STARTER_CACHE.set(cacheKey, starter);  // Never evicted
  return starter;
}
```

## Environment
- Version: latest (main branch)
- OS: Any
- Install method: Any

## Logs or screenshots
N/A - memory leak manifests over time

## Impact
- **Memory Exhaustion**: Process OOM after days/weeks of operation
- **Gradual Degradation**: GC pressure increases before crash
- **Silent Failure**: No warning before sudden crash
- **Production Risk**: Long-running gateway processes most affected

## Recommended fix
1. **Use existing bounded cache infrastructure**:
```typescript
import { createDedupeCache } from "../infra/dedupe";

const THREAD_STARTER_CACHE = createDedupeCache<SlackThreadStarter>({
  maxSize: 10000,
  ttlMs: 3600000,  // 1 hour
});
```

2. **Or add manual bounds**:
```typescript
const MAX_CACHE_SIZE = 10000;

function cacheThreadStarter(key: string, value: SlackThreadStarter) {
  if (THREAD_STARTER_CACHE.size >= MAX_CACHE_SIZE) {
    const firstKey = THREAD_STARTER_CACHE.keys().next().value;
    THREAD_STARTER_CACHE.delete(firstKey);
  }
  THREAD_STARTER_CACHE.set(key, value);
}
```

## Comments

### @coygeek (2026-02-01)

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.2 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)



## Links

- None detected yet
