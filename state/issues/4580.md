---
number: 4580
title: "Discord voice messages have incorrect mime type (text/plain instead of audio/ogg)"
author: webmastertorch
created: 2026-01-30T10:36:53Z
updated: 2026-01-31T02:29:45Z
labels: ["bug"]
assignees: []
comments_count: 2
reactions_total: 1
url: https://github.com/openclaw/openclaw/issues/4580
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Bug

Discord voice messages (.ogg files) are received with incorrect mime type \	ext/plain\ instead of \^Gudio/ogg\, causing the binary audio data to be displayed as garbled text.

## Steps to Reproduce

1. Send a voice message in Discord to a bot running OpenClaw
2. The voice message attachment is received with \mime: text/plain\
3. The binary content is displayed as garbled unicode characters

## Expected Behavior

Voice message attachments should be detected as \^Gudio/ogg\ (or appropriate audio mime type) and handled as audio files.

## Actual Behavior

The .ogg file is misidentified as \	ext/plain\, resulting in garbled output like:
\\\
杏卧Ȁ    阭䭣  笀祪ጁ灏獵效摡ā 뮀  伀杧S    ⴀ掖ŋ...
\\\

## Environment

- OpenClaw version: 2026.1.29
- Channel: Discord
- OS: Windows

## Additional Context

The voice-to-text transcript works correctly (the \[Audio] User text:\ prefix and transcript are present), but the raw file attachment has wrong mime type detection.

## Comments

### @batumilove (2026-01-30)

## Root Cause Analysis

The bug is in `src/media-understanding/apply.ts` — specifically the `resolveUtf16Charset` function.

### The Problem

OGG files (and other binary formats) often have significant null byte padding in their headers. The current heuristic assumes:
- \>20% null bytes in a sample = UTF-16 encoded text

This causes:
1. OGG file has ~40-50% null bytes in header region
2. Heuristic triggers: `textLike = true`
3. Binary is decoded as UTF-16LE → garbled unicode (杏卧Ȁ...)
4. Garbled text contains tab characters (0x00 0x09 sequences)
5. `guessDelimitedMime` classifies as `text/tab-separated-values`
6. Audio appears as garbled text block

### Why It's Intermittent

Not all OGG files trigger this — it depends on encoder settings and whether the header region sampled has >20% nulls.

### Suggested Fix

Check file magic bytes or trust the original MIME type **before** applying text heuristics. Binary formats (audio/*, video/*, image/*, application/octet-stream) should skip UTF-16 guessing entirely.

```typescript
// Skip text heuristics for known binary MIME types
const binaryMimePatterns = /^(audio|video|image)\//;
if (binaryMimePatterns.test(originalMime)) {
  return { content: buffer, mime: originalMime };
}
```

I'll submit a PR with this fix shortly.

### @batumilove (2026-01-30)

## Proposed Fix (PR Patch)

Since I cannot push to my fork (OAuth scope issue), here's the complete fix:

```diff
diff --git a/src/media-understanding/apply.ts b/src/media-understanding/apply.ts
--- a/src/media-understanding/apply.ts
+++ b/src/media-understanding/apply.ts
@@ -119,8 +119,25 @@ function appendFileBlocks(body: string | undefined, blocks: string[]): string {
   return `${base}\n\n${suffix}`.trim();
 }
 
-function resolveUtf16Charset(buffer?: Buffer): "utf-16le" | "utf-16be" | undefined {
+/**
+ * MIME type patterns for known binary formats that should never be treated as text.
+ * These formats often contain null bytes that would falsely trigger UTF-16 detection.
+ */
+const BINARY_MIME_PATTERNS = /^(audio|video|image)\//;
+
+function isBinaryMime(mime?: string): boolean {
+  if (!mime) return false;
+  return BINARY_MIME_PATTERNS.test(mime);
+}
+
+function resolveUtf16Charset(
+  buffer?: Buffer,
+  mimeHint?: string,
+): "utf-16le" | "utf-16be" | undefined {
   if (!buffer || buffer.length < 2) return undefined;
+  // Skip UTF-16 heuristics for known binary MIME types (audio, video, image)
+  // These formats often have null-byte padding that triggers false positives
+  if (isBinaryMime(mimeHint)) return undefined;
   const b0 = buffer[0];
   const b1 = buffer[1];
   if (b0 === 0xff && b1 === 0xfe) {
@@ -162,10 +179,10 @@ function looksLikeUtf8Text(buffer?: Buffer): boolean {
   return printable / total > 0.85;
 }
 
-function decodeTextSample(buffer?: Buffer): string {
+function decodeTextSample(buffer?: Buffer, mimeHint?: string): string {
   if (!buffer || buffer.length === 0) return "";
   const sample = buffer.subarray(0, Math.min(buffer.length, 8192));
-  const utf16Charset = resolveUtf16Charset(sample);
+  const utf16Charset = resolveUtf16Charset(sample, mimeHint);
   if (utf16Charset === "utf-16be") {
@@ -240,8 +257,10 @@ async function extractFileBlocks(params: {
     }
     const nameHint = bufferResult?.fileName ?? attachment.path ?? attachment.url;
     const forcedTextMimeResolved = forcedTextMime ?? resolveTextMimeFromName(nameHint ?? "");
-    const utf16Charset = resolveUtf16Charset(bufferResult?.buffer);
-    const textSample = decodeTextSample(bufferResult?.buffer);
+    // Get rawMime early so we can use it to skip UTF-16 detection for binary formats
+    const rawMime = bufferResult?.mime ?? attachment.mime;
+    const utf16Charset = resolveUtf16Charset(bufferResult?.buffer, rawMime);
+    const textSample = decodeTextSample(bufferResult?.buffer, rawMime);
     const textLike = Boolean(utf16Charset) || looksLikeUtf8Text(bufferResult?.buffer);
```

**Summary:**
- Add `isBinaryMime()` helper to detect audio/video/image MIME types
- Pass MIME hint to `resolveUtf16Charset()` and `decodeTextSample()`
- Skip null-byte heuristic for known binary formats
- BOM-based UTF-16 detection (0xFF 0xFE / 0xFE 0xFF) still works for all files

Happy to create a proper PR if a maintainer can help with the fork sync, or feel free to apply this patch directly.


## Links

- None detected yet
