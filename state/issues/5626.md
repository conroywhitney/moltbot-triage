---
number: 5626
title: "[Bug]: Slack multi-workspace (accounts) silently drops messages"
author: macterra
created: 2026-01-31T19:01:11Z
updated: 2026-01-31T20:18:48Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5626
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

Two workspaces via channels.slack.accounts → messages dropped from second workspace, eventually first too. No errors in health/logs.

## Steps to reproduce

1. Configure two workspaces with separate tokens 
2. Restart gateway
3. Send messages to second workspace

## Expected behavior

Same bot in 2 different slacks receiving all messages

## Actual behavior

Messages dropped

## Environment

- OpenClaw 2026.1.24-3 / 2026.1.30
- Linux
- npm via nvm
- Node v24.13.0

## Comments

### @0xPliny (2026-01-31)

Did some digging through the Slack channel implementation. The multi-account architecture looks solid — each account gets its own Bolt `App` instance, context, and dedupe cache. Events are filtered by `api_app_id` and `team_id` to route to the correct handler.

But the "eventually first too" symptom suggests state degradation over time. A few areas worth investigating:

**1. Socket Mode Connection Health**

The `@slack/bolt` socket mode relies on `@slack/socket-mode` which maintains a WebSocket connection. Multiple instances *should* work independently, but there could be:
- Connection state leaking between instances
- Reconnection logic interfering across Apps
- Memory pressure from multiple open sockets

**Diagnostic:** Add connection state logging:
```js
app.client.on('connecting', () => console.log(`[${accountId}] connecting`));
app.client.on('authenticated', () => console.log(`[${accountId}] authenticated`));
app.client.on('disconnected', () => console.log(`[${accountId}] disconnected`));
```

**2. Auth Token Refresh Race**

If both workspaces refresh tokens around the same time, there might be a race condition. The `auth.test` call during startup populates `botUserId`, `teamId`, and `apiAppId` — if this fails silently for one account, events might be mis-routed or dropped.

**Diagnostic:** Check if `apiAppId` is populated for both accounts:
```
openclaw status --verbose
```

**3. HTTP Mode Path Collision (if applicable)**

If using HTTP mode instead of socket mode, there's a global route registry at `/slack/events`. Second account registering the same path gets silently skipped:
```js
if (slackHttpRoutes.has(normalizedPath)) {
    params.log?.(`slack: webhook path ${normalizedPath} already registered`);
    return () => { };  // <-- Second account's handler is never registered
}
```

**Fix:** Per-account webhook paths should be enforced when using HTTP mode with multiple accounts.

**4. Event Deduplication TTL**

The dedupe cache has a 60s TTL and 500 message limit. Under high load, legitimate messages could be evicted and then re-processed, or the inverse — messages could be incorrectly deduped if timestamps collide across workspaces (unlikely but possible).

---

@macterra — Could you share:
1. Are you using socket mode or HTTP mode?
2. Does `openclaw status` show both accounts as running?
3. Any logs around the time messages start dropping?
4. Approximately how long until messages start dropping after restart?


## Links

- None detected yet
