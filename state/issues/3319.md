---
number: 3319
title: "[Feature]: [RFC] Cross-Platform Dependency Management via Skill Manifests (replacing hardcoded Brew)"
author: AdamParker19
created: 2026-01-28T12:34:40Z
updated: 2026-01-28T12:34:40Z
labels: ["enhancement"]
assignees: []
comments_count: 0
reactions_total: 4
url: https://github.com/openclaw/openclaw/issues/3319
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

Currently, the integration of external tools relies heavily on brew commands or shell-specific scripts within skills. This effectively locks the ecosystem to macOS and Linux (Homebrew users), treating Windows users as second-class citizens despite valid alternatives like winget or choco existing.

Current workarounds involve patching individual skills with if/else statements for OS detection, which leads to messy, unmaintainable code as the library grows.

The Proposal: Dependency Abstraction Layer
I propose moving away from imperative installation commands (e.g., run("brew install ffmpeg")) toward a declarative Dependency Manifest.

1. The manifest.json (or skill.json update) Skills should declare what they need, not how to get it. We can introduce a dependencies object in the skill definition:

```
{
  "name": "video-transcriber",
  "dependencies": {
    "system_tools": {
      "ffmpeg": {
        "brew": "ffmpeg",
        "apt": "ffmpeg",
        "winget": "Gyan.FFmpeg",
        "choco": "ffmpeg"
      }
    },
    "python_packages": ["pandas", "numpy"]
  }
}
```

Note: We could support a concise string "ffmpeg" for tools where the package name is identical across platforms, and an object (as above) where package IDs differ.

2. The Package Manager Adapter The core bot logic would include a PackageManager class that detects the host OS on startup and routes the installation request accordingly:

macOS: Defaults to brew install [id]

Windows: Defaults to winget install -e --id [id]

Debian/Ubuntu: Defaults to sudo apt-get install -y [id]

Benefits
True Cross-Platform Support: Windows and Linux users get native support immediately without hacking scripts.

Security & Stability: We centralize the installation logic. We can add checks (e.g., verifying winget source hash) in one place rather than trusting every individual skill's install script.

Cleaner Skills: Skill developers only need to list the tool name, reducing boilerplate code.

Implementation Plan
I am happy to take the lead on this. My plan would be:

Define the schema for the dependencies block.

Implement a basic DependencyManager class in the core.

Migrate one high-profile skill (e.g., one using ffmpeg) to use this new system as a proof of concept.

Does this architectural direction align with the roadmap? Let us discuss

## Comments


## Links

- None detected yet
