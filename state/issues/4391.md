---
number: 4391
title: "[Feature]: Native Slack streaming via chat.startStream / appendStream / stopStream APIs"
author: spartakb
created: 2026-01-30T05:18:42Z
updated: 2026-01-30T09:34:59Z
labels: []
assignees: []
comments_count: 3
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/4391
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

Add native real-time token streaming for Slack channels using Slack's `chat.startStream`, `chat.appendStream`, and `chat.stopStream` APIs. This replaces the current block-streaming approach (periodic message edits) with true streaming — tokens appear character-by-character as the LLM generates them, matching the experience users get in ChatGPT, Claude.ai, etc.

## Motivation

Clawdbot's current Slack delivery has two modes:
1. **No streaming** — entire response posted at once after generation completes
2. **Block streaming** — response chunked and delivered via periodic message edits (`chat.update`)

Block streaming is a significant improvement, but it's still noticeably "chunky" — text appears in bursts rather than flowing smoothly. Slack now offers native streaming APIs that deliver a much better UX.

## Working Implementation

I've built and tested a complete implementation that's been running in production. Here's how it works:

### Architecture

Two files:
1. **`dist/slack/chat-stream.js`** (NEW) — Streaming wrapper with throttling, error recovery, and graceful fallback
2. **`dist/slack/monitor/message-handler/dispatch.js`** (MODIFIED) — Wires streaming into the existing reply pipeline

### Key API Details

Slack's streaming API has some poorly documented requirements discovered during implementation:

```js
// Start a stream — creates a placeholder message that updates in real-time
const response = await client.chat.startStream({
    channel,
    thread_ts: threadTs,           // REQUIRED — streaming only works in threads
    recipient_team_id: teamId,     // REQUIRED — poorly documented
    recipient_user_id: userId,     // REQUIRED — poorly documented  
    markdown_text: firstChunk,
});
const streamTs = response.ts;  // message timestamp for subsequent calls

// Append more text (delta-based — send only new characters)
await client.chat.appendStream({
    channel,
    ts: streamTs,
    markdown_text: deltaText,
});

// Finalize — locks the message with final content
await client.chat.stopStream({
    channel,
    ts: streamTs,
    markdown_text: finalFullText,  // optional: replace entire content
});
```

### Integration with dispatch.js

The stream hooks into the existing `blockStreaming` pipeline:

```js
// In dispatch.js — stream creation
const canStreamNative = account.config.nativeStreaming === true ||
    (account.config.nativeStreaming !== false && account.config.blockStreaming === true);

const chatStream = canStreamNative
    ? createSlackChatStream({
        client: ctx.app.client,
        channel: message.channel,
        threadTs: initialThreadTs,
        teamId: ctx.teamId || message.team,
        userId: message.user,
        token: ctx.botToken,
    })
    : undefined;

// Partial reply handler — feeds LLM tokens to the stream
onPartialReply: chatStream
    ? (payload) => { if (payload.text) chatStream.update(payload.text); }
    : undefined,

// Delivery handler — stream IS the delivery, skip chat.postMessage
deliver: async (payload, info) => {
    if (chatStream?.isStarted() && !chatStream.hasFailed()) {
        const response = await chatStream.stop(payload.text);
        if (response) {
            replyPlan.markSent();
            if (!hasMedia) return;  // text delivered via stream
        }
    }
    // Fallback to normal delivery
    await deliverReplies({ ... });
}
```

### Design Decisions

1. **Thread-only**: Slack streaming only works as threaded replies (`thread_ts` required). Falls back to normal delivery for top-level messages.
2. **Throttled**: 300ms minimum between API calls to avoid rate limits. Uses a timer-based throttle similar to `telegram/draft-stream.js`.
3. **Delta-based**: Only sends new characters (not full text each time), matching Slack's append model.
4. **Graceful fallback**: If streaming fails at any point, `hasFailed()` returns true and the delivery path falls through to normal `chat.postMessage`.
5. **No duplicate messages**: When stream succeeds, the deliver callback returns early — the streamed message IS the final message, no separate `chat.postMessage` needed.
6. **Block streaming disabled during stream**: `disableBlockStreaming: true` prevents the block chunking pipeline from also editing the message.

### Config

Activates automatically when `blockStreaming: true` (existing config). Could also support a dedicated `nativeStreaming: true` flag.

## Requirements

- Slack bot token with appropriate scopes
- `replyToMode: "all"` or messages in existing threads (streaming requires `thread_ts`)
- `blockStreaming: true` in channel config (or a new `nativeStreaming` flag)

## Notes

- `recipient_team_id` and `recipient_user_id` are **required** by the Slack API but not well documented — took trial and error to discover
- The stream wrapper pattern mirrors `telegram/draft-stream.js` for consistency
- This has been running in production on a real workspace with no issues
- Happy to contribute a PR if maintainers are interested

## Comments

### @spartakb (2026-01-30)

## Bug: Silent token (NO_REPLY) leaks partial text during native streaming

While running this native streaming implementation, I discovered a bug: the `onPartialReply` handler streams partial text to Slack **before** the silent token check can recognize the full `NO_REPLY` token.

### What happens

1. Model starts outputting `NO_REPLY`
2. A partial chunk with just `"NO"` arrives at `onPartialReply`
3. That gets fed directly to `chatStream.update()` which streams `"NO"` to Slack
4. The full `NO_REPLY` silent token check only happens during final delivery — but the stream already sent `"NO"` to the user

The user sees `"NO"` appear in Slack before the message is finalized.

### Root cause

The `onPartialReply` handler in `dispatch.js` has no silent token awareness:

```js
onPartialReply: chatStream
    ? (payload) => {
        if (payload.text) chatStream.update(payload.text);
    }
    : undefined,
```

### Fix

The handler should check both full and **prefix** matches against the silent token before streaming:

```js
import { isSilentReplyText, SILENT_REPLY_TOKEN } from "../../../auto-reply/tokens.js";

onPartialReply: chatStream
    ? (payload) => {
        if (payload.text
            && !isSilentReplyText(payload.text, SILENT_REPLY_TOKEN)
            && !SILENT_REPLY_TOKEN.startsWith(payload.text.trim())) {
            chatStream.update(payload.text);
        }
    }
    : undefined,
```

The key addition is `!SILENT_REPLY_TOKEN.startsWith(payload.text.trim())` — this buffers text that could be a prefix of the silent token (like `"NO"` being the start of `"NO_REPLY"`) until enough text arrives to confirm it is not the silent token.

This same issue would apply to `HEARTBEAT_OK` — partial `"HEARTBEAT"` could leak similarly.

### @spartakb (2026-01-30)

## Bug #2: `removeAckAfterReply` never fires with native streaming

Discovered another bug in the native streaming implementation: the `removeAckAfterReply` feature (which removes the ack emoji reaction after a reply is sent) never triggers when native streaming is active.

### What happens

1. User sends message → bot adds ⚡ ack reaction
2. Bot generates reply via native streaming → reply delivered as a **block** reply
3. `dispatchInboundMessage` returns `queuedFinal=false` (counts: `{tool:0, block:1, final:0}`)
4. `dispatch.js` checks `if (!queuedFinal) return` → **returns early**, skipping `removeAckReactionAfterReply`
5. ⚡ reaction stays permanently on the message

### Root cause

With native streaming, replies are delivered through the `onPartialReply` → `chatStream.update()` → `chatStream.stop()` path, which counts as a **block** delivery, not a **final** delivery. The `queuedFinal` flag is only set when `dispatcher.sendFinalReply()` returns a normalized payload — but with streaming, the final reply text has already been consumed by the stream.

### Fix

Move `removeAckReactionAfterReply` to fire based on **total replies delivered** (block + tool + final > 0), not just `queuedFinal`:

```js
const totalReplies = (counts.tool ?? 0) + (counts.block ?? 0) + (counts.final ?? 0);
if (totalReplies > 0) {
    removeAckReactionAfterReply({
        removeAfterReply: ctx.removeAckAfterReply,
        ackReactionPromise: prepared.ackReactionPromise,
        ackReactionValue: prepared.ackReactionValue,
        remove: () => removeSlackReaction(message.channel, prepared.ackReactionMessageTs ?? "", prepared.ackReactionValue, {
            token: ctx.botToken,
            client: ctx.app.client,
        }),
        onError: (err) => { /* ... */ },
    });
}
// Then continue with the existing queuedFinal check for other cleanup
```

This ensures the ack reaction is removed after any reply delivery method — streaming, block, or final.

### @spartakb (2026-01-30)

## Additional nuance: Ack/Done reaction behavior on silent replies

When a message is processed but the model returns a silent reply (`NO_REPLY` / `HEARTBEAT_OK`), the current streaming implementation has a gap in reaction lifecycle management:

### Problem

The reaction cleanup block (remove ⚡ ack reaction + add ✅ done reaction) is gated behind `if (totalReplies > 0)` in `dispatch.js`. When the model returns a silent reply, the message is suppressed and `totalReplies` stays at 0. This means:
- ⚡ (ack reaction) is never removed — stays permanently on the message
- ✅ (done reaction) is never added

This affects both the submessage (thread reply) and parent thread message when `ackReactionSyncParent` is enabled.

### Expected behavior

The ⚡ → ✅ lifecycle should complete regardless of whether a visible reply was sent. ✅ means "processed", not "replied" — the bot acknowledged and handled the message, even if the appropriate response was silence.

### Fix

Add an `else` branch after the `totalReplies > 0` block that:
1. Calls `removeAckReactionAfterReply()` to remove ⚡ from submessage (promise-gated, same as normal path)
2. Directly removes ⚡ from parent thread message (when `ackReactionSyncParent` is enabled)
3. Adds ✅ done reaction to both submessage and parent thread message

```js
else {
    // Silent reply — totalReplies is 0.
    // Still remove ack and add done reaction.
    removeAckReactionAfterReply({ /* same params */ });
    // Remove ack from parent
    if (ctx.ackReactionSyncParent && ctx.removeAckAfterReply && prepared.parentThreadTs && prepared.ackReactionValue) {
        removeSlackReaction(message.channel, prepared.parentThreadTs, prepared.ackReactionValue, { ... });
    }
    // Add done reaction — ✅ means processed, not replied
    if (ctx.doneReaction) {
        const doneEmoji = ctx.doneReaction.replace(/^:+|:+$/g, "");
        reactSlackMessage(message.channel, prepared.ackReactionMessageTs ?? message.ts, doneEmoji, { ... });
        if (ctx.ackReactionSyncParent && prepared.parentThreadTs) {
            reactSlackMessage(message.channel, prepared.parentThreadTs, doneEmoji, { ... });
        }
    }
}
```

This ensures the full ⚡ → ✅ lifecycle completes for every processed message, whether the bot replies visibly or stays silent.


## Links

- None detected yet
