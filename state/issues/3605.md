---
number: 3605
title: "Sub-agents share browser profile with parent, causing tab conflicts"
author: bergcb322-clawd
created: 2026-01-28T22:14:22Z
updated: 2026-01-29T07:00:11Z
labels: []
assignees: []
comments_count: 2
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/3605
duplicate_of: null
related_issues: [6]
blocks: []
blocked_by: []
---

## Description

# Sub-agents share browser profile with parent, causing tab conflicts

## Bug Description
When spawning sub-agents, both parent and sub-agent use the same browser profile, causing their browser tabs to interfere with each other. Tabs unexpectedly close, focus switches between agents, and parallel browser-based tasks are impossible.

## Evidence
- Parent agent: Working on GitHub signup (tab ID: `B36B8E8C954E18B401F55B0F833B9446`)
- Sub-agent: Working on X.com signup (tab ID: `BE929CA226E2E0D68EA8FB0933F9E886`)
- Both use `profile: clawd`
- Parent's GitHub tab disappeared when sub-agent performed actions
- Sub-agent explicitly closed parent's tab thinking it was noise

## Expected Behavior
Each agent (parent + sub-agents) should get isolated browser contexts or profiles so their tabs don't interfere with each other.

## Actual Behavior
All agents share the same browser profile and can see/close each other's tabs.

## Impact
- **CRITICAL:** Blocks parallel task execution
- Sub-agents cannot work autonomously if browser is needed
- Major limitation for multi-agent orchestration
- Forces sequential browser task execution

## Reproduction
1. Start task requiring browser in main session
2. Spawn sub-agent with another browser-based task
3. Observe tabs conflicting and closing unexpectedly

## Potential Solutions

### Option 1: Browser Profiles Per Agent
```javascript
const agentProfile = isSubAgent 
  ? `clawd-subagent-${agentId}` 
  : 'clawd-main';
```

### Option 2: Browser Contexts
Use Playwright's browser contexts for isolation within same profile.

### Option 3: Browser Locking
Implement coordination protocol where agents request/release browser access.

### Option 4: Multiple Browser Instances
Spawn separate Chrome instances per agent.

## Workaround
Created separate browser profile manually:
```json
{
  "browser": {
    "profiles": {
      "github": { "cdpPort": 18803, "color": "#6e5494" }
    }
  }
}
```
Then explicitly used `profile: "github"` for one agent.

## Environment
- Clawdbot version: 2026.1.24-3
- Browser: Chrome headless
- Multiple concurrent agents active

## Comments

### @JaydenLiang (2026-01-28)

https://github.com/moltbot/moltbot/blob/a7534dc22382c42465f3676724536a014ce0cbf7/src/browser/server-context.ts#L89
` const getProfileState = (): ProfileRuntimeState => {
    const current = state();
    let profileState = current.profiles.get(profile.name);
    if (!profileState) {
      profileState = { profile, running: null, lastTargetId: null };
      current.profiles.set(profile.name, profileState);
    }
    return profileState;
  };`

I think the browser has been designed as a single-instance with single-profile setup. I assume that agents now have to share the same profile. As seen on the code snippet, **profileState.lastTargetId** is intended to be passed along cross agents. That's how the current implementation causes the conflicts.

As **Option 2: Browser Contexts**  suggested, agent-level context isolation would mitigate the conflicts but I think it ideally needs a profile trees to maintain the parent-child relationships enabling the single browser instance to jump between multiple agent-contexts. I believe this is a much reliable solution.

I am still learning this project and I'd love to contribute to it

### @JaydenLiang (2026-01-29)

> [moltbot/src/browser/server-context.ts](https://github.com/moltbot/moltbot/blob/a7534dc22382c42465f3676724536a014ce0cbf7/src/browser/server-context.ts#L89)
> 
> Line 89 in [a7534dc](/moltbot/moltbot/commit/a7534dc22382c42465f3676724536a014ce0cbf7)
> 
>  const getProfileState = (): ProfileRuntimeState => { 
> 
> ` const getProfileState = (): ProfileRuntimeState => { const current = state(); let profileState = current.profiles.get(profile.name); if (!profileState) { profileState = { profile, running: null, lastTargetId: null }; current.profiles.set(profile.name, profileState); } return profileState; };`
> I think the browser has been designed as a single-instance with single-profile setup. I assume that agents now have to share the same profile. As seen on the code snippet, **profileState.lastTargetId** is intended to be passed along cross agents. That's how the current implementation causes the conflicts.
> 
> As **Option 2: Browser Contexts** suggested, agent-level context isolation would mitigate the conflicts but I think it ideally needs a profile trees to maintain the parent-child relationships enabling the single browser instance to jump between multiple agent-contexts. I believe this is a much reliable solution.
> 
> I am still learning this project and I'd love to contribute to it

Hi @bergcb322-clawd , after a careful review of the current design, it looks like the agents and tools (in this case, the browser-tool) are intentionally fairly decoupled in the existing architecture. The profiles don't appear to be designed to be scoped by a specific agent. While introducing a parentâ€“child context is a good direction to explore, I think it would require need further discussion to evaluate whether an agent-specific profile or context fit well with the current implementation and and its trade-offs or not.

Given that uncertainty, I still do my best to mitigate the issue. My proposal is to disallow closing tabs without a valid target id. Requiring developers to maintain the target id solve the problem while keeping the overall architecture unchanged!

Here is the topic should be discussed:
### **The system has run into a broader design question around tab ownership and concurrency safety, especially for destructive actions like close.**

**The problem:**
Recently, the 'close' action of the browser-tool allowed falling back to closing the active tab when no targetId was provided. This was convenient, but it implicitly relied on shared browser state. In practice, this becomes problematic when multiple tools, agents, or human-driven sessions operate against the same browser profile, as tab ownership cannot be reliably inferred.

### The broader questions remain open:

1. Would you be comfortable with your own browser tabs being closed arbitrarily?
2. How should browser-tool model tab ownership across concurrent or cooperative usage?
3. Should destructive actions always require explicit ownership, or are there cases where implicit behavior is acceptable?
4. Are there better abstractions (e.g. scoped contexts, session-level tab tracking, or tool-managed ownership) that could balance safety and usability more effectively?


## Links

- None detected yet
