---
number: 4650
title: "[Bug]: Tool Use/Result Pairing and Consecutive Assistant Messages After History Limiting"
author: NikitaYeryomin
created: 2026-01-30T13:26:21Z
updated: 2026-01-30T13:26:21Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/4650
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

After `limitHistoryTurns` or compaction operations, the message history can end up with:
1. Orphaned `tool_result` blocks that reference `tool_use` IDs not present in the immediately preceding assistant message
2. Consecutive assistant messages that violate Anthropic's API format requirements

This causes the Anthropic API to reject requests with errors like:
```
LLM request rejected: messages.18.content.1: unexpected tool_use_id found in tool_result blocks: toolu_01Y41DmovMuY4ZRW5FmxDStd. Each tool_result block must have a corresponding tool_use block in the previous message.
```

## Environment

- Moltbot/Clawdbot version: v2026.1.24-3
- Provider: Anthropic (claude-opus-4-5)
- API: anthropic-messages

## Root Cause Analysis

### Issue 1: Orphaned Tool Results After Limiting

The `sanitizeToolUseResultPairing` function runs **before** `limitHistoryTurns`. When history is limited, it can cut off an assistant message containing a `tool_use` block while keeping the corresponding `tool_result` in a later message.

**Example:**
```
Before limiting:
  [0] assistant (tool_use: toolu_123)
  [1] toolResult (toolu_123)
  [2] user
  [3] assistant
  ...

After limiting (if limit cuts at message 1):
  [0] toolResult (toolu_123)  <- ORPHAN: no matching tool_use
  [1] user
  [2] assistant
  ...
```

### Issue 2: Consecutive Assistant Messages After Compaction

When a compaction entry has "Summary unavailable due to context limits" or when history is reconstructed after compaction, consecutive assistant messages can occur.

**Example from session analysis:**
```
  [13] assistant: (no tools)
  [14] assistant: tool_uses=['toolu_01YVso6Qv']  <- CONSECUTIVE ASSISTANTS
  [15] toolResult
```

This happens because:
1. Compaction inserts a summary between messages
2. If the summary is unavailable/empty, consecutive assistants remain
3. `validateGeminiTurns` (which merges consecutive assistants) runs before limiting, not after

## Code Flow (Current - Buggy)

In `src/agents/pi-embedded-runner/run/attempt.ts`:
```typescript
const prior = await sanitizeSessionHistory({...});  // Includes repair + turn validation
const validatedGemini = transcriptPolicy.validateGeminiTurns
    ? validateGeminiTurns(prior) : prior;
const validated = transcriptPolicy.validateAnthropicTurns
    ? validateAnthropicTurns(validatedGemini) : validatedGemini;
const limited = limitHistoryTurns(validated, ...);  // CAN CREATE NEW ISSUES
// Messages sent to API without re-validation
activeSession.agent.replaceMessages(limited);
```

## Solution

Re-run both `sanitizeToolUseResultPairing` and turn validation (`validateGeminiTurns`, `validateAnthropicTurns`) **after** `limitHistoryTurns`.

### Proposed Fix

In `src/agents/pi-embedded-runner/run/attempt.ts` (main path ~line 447):

```typescript
const limited = limitHistoryTurns(validated, getDmHistoryLimitFromSessionKey(params.sessionKey, params.config));

// Re-run tool_use/tool_result pairing repair after limiting, as limiting can
// cut off tool_use blocks while keeping their orphaned tool_result blocks.
const repairedLimited = transcriptPolicy.repairToolUseResultPairing
    ? sanitizeToolUseResultPairing(limited)
    : limited;

// Re-run turn validation after limiting, as limiting/compaction can
// create consecutive assistant messages that need to be merged.
const revalidatedGemini = transcriptPolicy.validateGeminiTurns
    ? validateGeminiTurns(repairedLimited)
    : repairedLimited;
const revalidatedAnthropic = transcriptPolicy.validateAnthropicTurns
    ? validateAnthropicTurns(revalidatedGemini)
    : revalidatedGemini;

cacheTrace?.recordStage("session:limited", { messages: revalidatedAnthropic });
if (revalidatedAnthropic.length > 0) {
    activeSession.agent.replaceMessages(revalidatedAnthropic);
}
```

### Files Requiring Changes

1. **`src/agents/pi-embedded-runner/run/attempt.ts`**
   - Main code path (after `limitHistoryTurns`)
   - Orphan user message repair path (after `limitHistoryTurns`)
   - Add import: `import { sanitizeToolUseResultPairing } from "../../session-transcript-repair.js";`

2. **`src/agents/pi-embedded-runner/compact.ts`**
   - After `limitHistoryTurns` in compaction flow
   - Add import: `import { sanitizeToolUseResultPairing } from "../session-transcript-repair.js";`

## Diff

```diff
diff --git a/src/agents/pi-embedded-runner/run/attempt.ts b/src/agents/pi-embedded-runner/run/attempt.ts
--- a/src/agents/pi-embedded-runner/run/attempt.ts
+++ b/src/agents/pi-embedded-runner/run/attempt.ts
@@ -40,6 +40,7 @@ import {
   sanitizeToolsForGoogle,
 } from "../google.js";
 import { getDmHistoryLimitFromSessionKey, limitHistoryTurns } from "../history.js";
+import { sanitizeToolUseResultPairing } from "../../session-transcript-repair.js";

@@ -447,9 +448,22 @@ export async function runEmbeddedAttempt(
                 const validated = transcriptPolicy.validateAnthropicTurns
                     ? validateAnthropicTurns(validatedGemini)
                     : validatedGemini;
                 const limited = limitHistoryTurns(validated, getDmHistoryLimitFromSessionKey(params.sessionKey, params.config));
-                cacheTrace?.recordStage("session:limited", { messages: limited });
-                if (limited.length > 0) {
-                    activeSession.agent.replaceMessages(limited);
+                // Re-run tool_use/tool_result pairing repair after limiting
+                const repairedLimited = transcriptPolicy.repairToolUseResultPairing
+                    ? sanitizeToolUseResultPairing(limited)
+                    : limited;
+                // Re-run turn validation after limiting
+                const revalidatedGemini = transcriptPolicy.validateGeminiTurns
+                    ? validateGeminiTurns(repairedLimited)
+                    : repairedLimited;
+                const revalidatedAnthropic = transcriptPolicy.validateAnthropicTurns
+                    ? validateAnthropicTurns(revalidatedGemini)
+                    : revalidatedGemini;
+                cacheTrace?.recordStage("session:limited", { messages: revalidatedAnthropic });
+                if (revalidatedAnthropic.length > 0) {
+                    activeSession.agent.replaceMessages(revalidatedAnthropic);
                 }
```

Similar changes needed in:
- The orphan user message repair block in `attempt.ts` (~line 719-733)
- `compact.ts` compaction flow

## Steps to Reproduce

1. Create a session with many tool calls
2. Continue using the session until compaction occurs or history limit is reached
3. The next API request may fail with "unexpected tool_use_id found in tool_result blocks"

## Workaround

Manually delete or rename the affected session file to force a fresh session:
```bash
mv ~/.clawdbot/agents/main/sessions/<session-id>.jsonl ~/.clawdbot/agents/main/sessions/<session-id>.jsonl.broken
systemctl --user restart clawdbot-gateway
```

## Additional Notes

- The `validateGeminiTurns` function merges consecutive assistant messages
- The `validateAnthropicTurns` function merges consecutive user messages
- The `sanitizeToolUseResultPairing` function removes orphaned tool_results and creates synthetic results for missing tool_uses
- All three must run after any operation that modifies message order/content (including `limitHistoryTurns`)

## Comments


## Links

- None detected yet
