---
number: 5642
title: "[Bug]: Race condition drops first voice message when multiple arrive rapidly"
author: Kaizen-79
created: 2026-01-31T19:32:20Z
updated: 2026-02-02T00:18:21Z
labels: ["bug"]
assignees: []
comments_count: 2
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5642
duplicate_of: null
related_issues: [1,1989]
blocks: []
blocked_by: []
---

## Description

### Summary

When two voice messages are sent to the same chat within ~30 seconds, the first message is silently dropped and never receives a response. Only the second message is processed.

This is a different issue from #1989 (audio-only messages not triggering responses). Here, the messages ARE received and transcription starts, but the first run is orphaned due to a race condition in the session run registry.

### Steps to reproduce

1. Open a Telegram DM with your OpenClaw bot
2. Send a voice message (e.g., "This is my first message")
3. Within 10-30 seconds, send a second voice message (e.g., "This is my second message")
4. Wait for responses

**Expected:** Both voice messages receive responses
**Actual:** Only the second voice message receives a response; first is silently dropped

### Root cause analysis

The bug is in `dist/agents/pi-embedded-runner/runs.js`:

```javascript
const ACTIVE_EMBEDDED_RUNS = new Map();

export function setActiveEmbeddedRun(sessionId, handle) {
    const wasActive = ACTIVE_EMBEDDED_RUNS.has(sessionId);
    ACTIVE_EMBEDDED_RUNS.set(sessionId, handle);  // â† OVERWRITES previous handle
    // ...
}

export function clearActiveEmbeddedRun(sessionId, handle) {
    if (ACTIVE_EMBEDDED_RUNS.get(sessionId) === handle) {  // â† First run's handle no longer matches
        ACTIVE_EMBEDDED_RUNS.delete(sessionId);
        // ...
    }
}
```

**The problem:** `ACTIVE_EMBEDDED_RUNS` uses `sessionId` (per-chat) as the key, not a unique per-message/per-run ID.

**What happens:**
1. Voice message 1 arrives â†’ transcription starts â†’ `setActiveEmbeddedRun(sessionId, handle1)`
2. Voice message 2 arrives (while #1 still processing) â†’ `setActiveEmbeddedRun(sessionId, handle2)` **overwrites handle1**
3. Voice message 1 finishes â†’ `clearActiveEmbeddedRun(sessionId, handle1)` â†’ **handle mismatch, silently skipped**
4. Voice message 2 finishes normally

The call site is in `dist/agents/pi-embedded-runner/run/attempt.js:536`:
```javascript
setActiveEmbeddedRun(params.sessionId, queueHandle);
```

### Evidence from logs

```
# Two files received 24 seconds apart:
file_148---4c26870a... (178856 bytes) @ 22:57:06
file_149---5d0ad2cb... (141776 bytes) @ 22:57:30

# First transcription process killed:
[2026-01-31 22:59:45] Exec failed (signal SIGKILL)
```

### Suggested fix

**Option A (recommended):** Use a unique `runId` instead of `sessionId` as the Map key:
```javascript
const ACTIVE_EMBEDDED_RUNS = new Map(); // Key: runId (unique per message)

export function setActiveEmbeddedRun(runId, sessionId, handle) {
    ACTIVE_EMBEDDED_RUNS.set(runId, { sessionId, handle });
}
```

**Option B:** Implement a per-session queue that serializes runs:
```javascript
export function setActiveEmbeddedRun(sessionId, handle) {
    if (ACTIVE_EMBEDDED_RUNS.has(sessionId)) {
        // Queue the new run instead of replacing
        return queueRunForSession(sessionId, handle);
    }
    ACTIVE_EMBEDDED_RUNS.set(sessionId, handle);
}
```

**Option C (minimal):** Reject/defer new runs while one is active:
```javascript
export function setActiveEmbeddedRun(sessionId, handle) {
    if (ACTIVE_EMBEDDED_RUNS.has(sessionId)) {
        throw new Error(`Run already active for session ${sessionId}`);
    }
    ACTIVE_EMBEDDED_RUNS.set(sessionId, handle);
}
```

### Environment

- OpenClaw version: 2026.1.29
- OS: Linux 6.14.0-37-generic (x64)
- Node: v22.22.0
- Channel: Telegram
- Audio transcription: openai-whisper-api skill

### Workaround

Until fixed, users should wait for a response before sending another voice message to the same chat.

## Comments

### @1WINgFIRE1 (2026-01-31)

Wow ðŸ˜®! How do you even get it? Using a mess Id instead of a session Id is more logical but what if we can use time along with session id? Internal time calculation will be faster than mess id generation!

### @Kaizen-79 (2026-01-31)

> Wow ðŸ˜®! How do you even get it? Using a mess Id instead of a session Id is more logical but what if we can use time along with session id? Internal time calculation will be faster than mess id generation!

Thanks! The time + session id approach could work - main goal is ensuring each run has a unique key that doesn't get overwritten when a second message arrives while the first is still processing.

Either solution (runId, messageId, or timestamp+sessionId) would fix the race condition. I went with message/run id in my suggestion since it's already available in the context, but timestamp might be simpler to implement. Up to the maintainers to decide the cleanest approach!


## Links

- None detected yet
