---
number: 5951
title: "Bug: Queued followup messages are lost when agent run times out"
author: grassX1998
created: 2026-02-01T04:25:51Z
updated: 2026-02-02T00:17:12Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5951
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

# Bug: Queued followup messages are lost when agent run times out

## Summary

When an agent run times out and is force-cleared, any messages that were queued via `enqueueFollowupRun()` during the run are permanently lost. The followup queue is never drained because `forceClearActiveEmbeddedRun()` doesn't trigger `scheduleFollowupDrain()`.

## Affected Version

Current main branch (as of investigation date)

## Affected Files

- `dist/agents/pi-embedded-runner/runs.js` - `forceClearActiveEmbeddedRun()` function
- `dist/agents/pi-embedded-runner/run/attempt.js` - timeout handling logic
- `dist/auto-reply/reply/queue/drain.js` - `scheduleFollowupDrain()` function
- `dist/auto-reply/reply/agent-runner-helpers.js` - `finalizeWithFollowup()` function

## Problem Description

### Normal Flow (Working)

1. Messages arrive while agent is busy → `enqueueFollowupRun()` queues them to `FOLLOWUP_QUEUES`
2. Agent run completes → `finalizeWithFollowup()` is called
3. `scheduleFollowupDrain()` processes all queued messages
4. ✅ All messages are handled

### Timeout Flow (Bug)

1. Messages arrive while agent is busy → `enqueueFollowupRun()` queues them to `FOLLOWUP_QUEUES`
2. Agent run exceeds `timeoutMs` → `abortRun()` is called
3. After 30s grace period → `forceClearActiveEmbeddedRun(sessionId)` is called
4. `forceClearActiveEmbeddedRun()` only:
   - Deletes entry from `ACTIVE_EMBEDDED_RUNS`
   - Logs state change to "idle"
   - Notifies waiters via `notifyEmbeddedRunEnded()`
5. ❌ `scheduleFollowupDrain()` is **never called**
6. ❌ Queued messages remain in `FOLLOWUP_QUEUES` forever (until process restart)

### Code Evidence

**`forceClearActiveEmbeddedRun()` in `runs.js`:**
```javascript
export function forceClearActiveEmbeddedRun(sessionId) {
    if (ACTIVE_EMBEDDED_RUNS.has(sessionId)) {
        ACTIVE_EMBEDDED_RUNS.delete(sessionId);
        logSessionStateChange({ sessionId, state: "idle", reason: "timeout_force_cleared" });
        diag.warn(`run force cleared after timeout: sessionId=${sessionId} totalActive=${ACTIVE_EMBEDDED_RUNS.size}`);
        notifyEmbeddedRunEnded(sessionId);
        // BUG: Missing scheduleFollowupDrain() call here!
    }
}
```

**Compare with normal `clearActiveEmbeddedRun()` which is followed by `finalizeWithFollowup()`:**
```javascript
// In agent-runner-helpers.js
export const finalizeWithFollowup = (value, queueKey, runFollowupTurn) => {
    scheduleFollowupDrain(queueKey, runFollowupTurn);  // This drains the queue
    return value;
};
```

**Timeout trigger in `attempt.js`:**
```javascript
// Force-clear active run entry after grace period to prevent session from
// being permanently stuck when the run fails to clean up after abort.
forceCleanupTimer = setTimeout(() => {
    forceClearActiveEmbeddedRun(params.sessionId);
    // BUG: No followup drain scheduled here
}, 30_000);
```

## Steps to Reproduce

1. Start an OpenClaw agent
2. Send a message that triggers a long-running operation (e.g., complex tool use)
3. While the agent is processing, send additional messages
4. Wait for the run to timeout (default timeout + 30s grace period)
5. Observe that the messages sent in step 3 are never processed

## Expected Behavior

When an agent run times out:
1. The timeout cleanup should trigger `scheduleFollowupDrain()` with an appropriate queue key
2. All queued messages should be processed (or at minimum, preserved for the next run)
3. Users should not lose messages due to agent timeouts

## Actual Behavior

- Queued messages are orphaned in `FOLLOWUP_QUEUES`
- Messages are silently lost from the user's perspective
- No error or warning indicates that messages were dropped

## Suggested Fix

### Option 1: Drain queue in `forceClearActiveEmbeddedRun()`

The challenge here is that `forceClearActiveEmbeddedRun()` doesn't have access to `queueKey` or `runFollowupTurn`. This would require passing additional context.

### Option 2: Drain queue in the timeout handler (recommended)

In `attempt.js`, add a drain call in the timeout cleanup:

```javascript
forceCleanupTimer = setTimeout(() => {
    forceClearActiveEmbeddedRun(params.sessionId);
    
    // Drain any queued followup messages
    const queueKey = params.sessionKey ?? params.sessionId;
    if (queueKey) {
        scheduleFollowupDrain(queueKey, runFollowupTurn);
    }
}, 30_000);
```

This requires `queueKey` and `runFollowupTurn` to be in scope at the timeout handler location.

### Option 3: Clear the queue explicitly

If draining is not desirable after timeout (e.g., to prevent cascading failures), at minimum clear the queue and log a warning:

```javascript
import { clearFollowupQueue } from "../auto-reply/reply/queue/state.js";

forceCleanupTimer = setTimeout(() => {
    forceClearActiveEmbeddedRun(params.sessionId);
    
    const queueKey = params.sessionKey ?? params.sessionId;
    const dropped = clearFollowupQueue(queueKey);
    if (dropped > 0) {
        log.warn(`Dropped ${dropped} queued messages after timeout: sessionId=${params.sessionId}`);
    }
}, 30_000);
```

## Impact

- **User Experience**: Messages sent during agent processing may be silently lost
- **Data Loss**: User input is dropped without notification
- **Reliability**: Long-running operations become less reliable in high-message-volume scenarios

## Additional Context

The queue system is well-designed with debouncing, deduplication, and drop policies. The issue is specifically in the timeout code path not integrating with this system properly.

---

**Labels**: `bug`, `agent`, `message-queue`

## Comments


## Links

- None detected yet
