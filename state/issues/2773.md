---
number: 2773
title: "Model switch via /model directive acknowledged but overwritten by post-run session write (regression of #1435)"
author: dfmore
created: 2026-01-27T13:45:11Z
updated: 2026-01-29T07:02:11Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/moltbot/moltbot/issues/2773
duplicate_of: null
related_issues: [1435]
blocks: []
blocked_by: []
---

## Description

## Summary

When a user sends `/model <alias>` (e.g., `/model deepseek`), the directive handler correctly resolves the model, persists the override to the session store on disk, and replies "Switched to deepseek (ollama/deepseek-r1:8b)." However, `updateSessionStoreAfterAgentRun` then overwrites the session entry using stale in-memory state, reverting the model override. The model never actually switches.

**This appears to be a regression or incomplete fix of #1435.**

## Version

Clawdbot 2026.1.24-3 (885167d)

## Steps to Reproduce

1. Configure an Ollama provider with a model (e.g., `deepseek-r1:8b`) and an alias in `clawdbot.json`
2. Start a session (default model: `anthropic/claude-opus-4-5` or any Anthropic model)
3. Send `/model deepseek` via Signal (or CLI: `clawdbot agent --agent main -m "/model deepseek"`)
4. Observe the reply: "Switched to deepseek (ollama/deepseek-r1:8b)."
5. Check the session store on disk: `cat ~/.clawdbot/agents/main/sessions/sessions.json`

## Expected Behavior

`sessions.json` should show:
```json
"providerOverride": "ollama",
"modelOverride": "deepseek-r1:8b"
```

The next message should be processed by the Ollama/deepseek model.

## Actual Behavior

`sessions.json` still shows the previous model (e.g., `anthropic/claude-sonnet-4-5`). The switch acknowledgment text is correct, but the override is immediately reverted. All subsequent messages continue using the previous model.

Sending `/model deepseek` a second time returns "Already on deepseek (ollama/deepseek-r1:8b)" (the in-memory gateway state thinks it switched), but the disk state and actual execution model remain unchanged.

## Root Cause Analysis

The bug is a **stale in-memory session state race** between the directive handler and the post-run session update.

### Code flow

**File: `dist/commands/agent.js`**

1. `agentCommand()` loads the session into a local `sessionStore` object (line ~97, via `resolveSession`)
2. The embedded agent runs (`runEmbeddedPiAgent`, line ~329). This is a separate execution context with its own session references.

**File: `dist/auto-reply/reply/directive-handling.impl.js`**

3. Inside the embedded agent, the directive handler processes `/model deepseek`
4. `applyModelOverrideToSessionEntry()` correctly sets `providerOverride: "ollama"` and `modelOverride: "deepseek-r1:8b"` on the session entry (line ~250)
5. `updateSessionStore()` writes the updated entry to disk (line ~278). **This write succeeds.**

**File: `dist/commands/agent/session-store.js`**

6. After the embedded agent completes, `updateSessionStoreAfterAgentRun()` fires (agent.js line ~410)
7. It reads `sessionStore[sessionKey]` — the **stale** in-memory object from step 1 (line 13 of session-store.js)
8. It builds `next = { ...entry, sessionId, updatedAt, modelProvider, model, contextTokens, ... }` (lines 17-24)
9. Since `entry` is the stale object (never updated by the embedded agent's directive handler), the spread preserves the OLD `modelOverride` and `providerOverride`
10. It writes `next` to disk (line 40-42), **overwriting the directive handler's correct write from step 5**

### Why the in-memory state is stale

`agentCommand` passes `sessionStore` to `runEmbeddedPiAgent`, but the embedded agent runs in a separate execution context. When the directive handler inside the embedded agent modifies its session entry and calls `sessionStore[sessionKey] = sessionEntry`, it may be modifying a different reference than what `agentCommand` holds. The `updateSessionStoreAfterAgentRun` function reads from `agentCommand`'s reference, which was never updated.

## Suggested Fix

In `dist/commands/agent/session-store.js`, the `entry` should be read from the **fresh disk state** inside the `updateSessionStore` mutator, not from the stale in-memory `sessionStore[sessionKey]`.

Current code (lines 13-42):
```javascript
const entry = sessionStore[sessionKey] ?? { sessionId, updatedAt: Date.now() };
const next = { ...entry, sessionId, updatedAt: Date.now(), modelProvider: providerUsed, model: modelUsed, contextTokens };
// ... additional fields ...
sessionStore[sessionKey] = next;
await updateSessionStore(storePath, (store) => {
    store[sessionKey] = next;
});
```

Suggested change:
```javascript
await updateSessionStore(storePath, (store) => {
    const entry = store[sessionKey] ?? { sessionId, updatedAt: Date.now() };
    const next = { ...entry, sessionId, updatedAt: Date.now(), modelProvider: providerUsed, model: modelUsed, contextTokens };
    // ... additional fields ...
    store[sessionKey] = next;
    sessionStore[sessionKey] = next; // sync in-memory
});
```

This ensures the post-run write merges with the latest disk state (which includes the directive handler's model override) rather than clobbering it with stale in-memory data.

## Impact

- **All model switches via `/model` directive are broken** — the switch is acknowledged but never persisted
- Affects both Signal and CLI invocations
- The in-memory gateway state becomes inconsistent with the disk state
- Users believe they are talking to one model but are actually talking to another

## Workaround

None known at the config level. The issue is in the agent command's session persistence logic.

## Environment

- Clawdbot 2026.1.24-3 (885167d)
- Node.js 22.22.0
- Linux (Debian-based)
- Providers: Anthropic (API key), Ollama (local)
- Channel: Signal

## Comments

### @dfmore (2026-01-29)

## Verified Fix

I've tested the suggested fix locally and can confirm it resolves the issue. Here's the complete working patch:

### File: `dist/commands/agent/session-store.js`

**Before (buggy):**
```javascript
export async function updateSessionStoreAfterAgentRun(params) {
    const { cfg, sessionId, sessionKey, storePath, sessionStore, defaultProvider, defaultModel, fallbackProvider, fallbackModel, result, } = params;
    const usage = result.meta.agentMeta?.usage;
    const modelUsed = result.meta.agentMeta?.model ?? fallbackModel ?? defaultModel;
    const providerUsed = result.meta.agentMeta?.provider ?? fallbackProvider ?? defaultProvider;
    const contextTokens = params.contextTokensOverride ?? lookupContextTokens(modelUsed) ?? DEFAULT_CONTEXT_TOKENS;
    const entry = sessionStore[sessionKey] ?? {
        sessionId,
        updatedAt: Date.now(),
    };
    const next = {
        ...entry,
        sessionId,
        updatedAt: Date.now(),
        modelProvider: providerUsed,
        model: modelUsed,
        contextTokens,
    };
    if (isCliProvider(providerUsed, cfg)) {
        const cliSessionId = result.meta.agentMeta?.sessionId?.trim();
        if (cliSessionId)
            setCliSessionId(next, providerUsed, cliSessionId);
    }
    next.abortedLastRun = result.meta.aborted ?? false;
    if (hasNonzeroUsage(usage)) {
        const input = usage.input ?? 0;
        const output = usage.output ?? 0;
        const promptTokens = input + (usage.cacheRead ?? 0) + (usage.cacheWrite ?? 0);
        next.inputTokens = input;
        next.outputTokens = output;
        next.totalTokens = promptTokens > 0 ? promptTokens : (usage.total ?? input);
    }
    sessionStore[sessionKey] = next;
    await updateSessionStore(storePath, (store) => {
        store[sessionKey] = next;
    });
}
```

**After (fixed):**
```javascript
export async function updateSessionStoreAfterAgentRun(params) {
    const { cfg, sessionId, sessionKey, storePath, sessionStore, defaultProvider, defaultModel, fallbackProvider, fallbackModel, result, } = params;
    const usage = result.meta.agentMeta?.usage;
    const modelUsed = result.meta.agentMeta?.model ?? fallbackModel ?? defaultModel;
    const providerUsed = result.meta.agentMeta?.provider ?? fallbackProvider ?? defaultProvider;
    const contextTokens = params.contextTokensOverride ?? lookupContextTokens(modelUsed) ?? DEFAULT_CONTEXT_TOKENS;
    await updateSessionStore(storePath, (store) => {
        // Read entry from fresh disk state to preserve directive handler changes
        const entry = store[sessionKey] ?? {
            sessionId,
            updatedAt: Date.now(),
        };
        const next = {
            ...entry,
            sessionId,
            updatedAt: Date.now(),
            modelProvider: providerUsed,
            model: modelUsed,
            contextTokens,
        };
        if (isCliProvider(providerUsed, cfg)) {
            const cliSessionId = result.meta.agentMeta?.sessionId?.trim();
            if (cliSessionId)
                setCliSessionId(next, providerUsed, cliSessionId);
        }
        next.abortedLastRun = result.meta.aborted ?? false;
        if (hasNonzeroUsage(usage)) {
            const input = usage.input ?? 0;
            const output = usage.output ?? 0;
            const promptTokens = input + (usage.cacheRead ?? 0) + (usage.cacheWrite ?? 0);
            next.inputTokens = input;
            next.outputTokens = output;
            next.totalTokens = promptTokens > 0 ? promptTokens : (usage.total ?? input);
        }
        store[sessionKey] = next;
        sessionStore[sessionKey] = next; // sync in-memory state
    });
}
```

### Key Changes

1. **Moved all logic inside the `updateSessionStore` mutator callback** - This ensures we read the entry from fresh disk state (`store[sessionKey]`) rather than stale in-memory state (`sessionStore[sessionKey]`)

2. **Added in-memory sync** - After updating the store, we sync `sessionStore[sessionKey] = next` to keep the in-memory reference consistent

### Why This Works

The `updateSessionStore` function (in `config/sessions/store.js`) already has the right pattern:
```javascript
export async function updateSessionStore(storePath, mutator) {
    return await withSessionStoreLock(storePath, async () => {
        // Always re-read inside the lock to avoid clobbering concurrent writers.
        const store = loadSessionStore(storePath, { skipCache: true });
        const result = await mutator(store);
        await saveSessionStoreUnlocked(storePath, store);
        return result;
    });
}
```

The `store` passed to the mutator is freshly loaded from disk with `skipCache: true`. By reading `entry` from `store[sessionKey]` inside the mutator, we get the state that includes the directive handler's model override writes, and our spread preserves `modelOverride` and `providerOverride` fields.

### Test Verification

Tested on Clawdbot 2026.1.24-3 via Signal:
1. Session at `anthropic/claude-sonnet-4-5`
2. Sent `/model qwen` via Signal
3. Received "Switched to qwen (ollama/qwen2.5:3b)"
4. Verified `sessions.json` shows `modelOverride: "qwen2.5:3b"` and `providerOverride: "ollama"` ✓
5. Follow-up message confirmed qwen is responding ✓

The override now persists correctly across messages.


## Links

- None detected yet
