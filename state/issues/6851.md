---
number: 6851
title: "[Bug]: Slack file download lacks timeout, can hang gateway indefinitely"
author: coygeek
created: 2026-02-02T03:50:36Z
updated: 2026-02-02T03:50:36Z
labels: []
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6851
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 7.5 / 10.0 |
| **Severity** | High |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)


## Summary

The Slack file download function `fetchWithSlackAuth` in `media.ts` makes HTTP fetch calls without any timeout or AbortController. If Slack's CDN becomes slow or unresponsive, these calls block indefinitely, potentially hanging the message processing pipeline.

## Affected Code

**File:** `src/slack/monitor/media.ts:15-18,36`

```typescript
export async function fetchWithSlackAuth(url: string, token: string): Promise<Response> {
  const initialRes = await fetch(url, {  // NO TIMEOUT
    headers: { Authorization: `Bearer ${token}` },
    redirect: "manual",
  });

  // Handle Slack's redirect pattern for private file URLs
  if (initialRes.status === 302) {
    const resolvedUrl = initialRes.headers.get("location");
    // ...
    return fetch(resolvedUrl, { redirect: "follow" });  // Line 36 - NO TIMEOUT
  }

  return initialRes;
}
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [ ] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [x] None (unauthenticated/public access)
- [ ] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Any Slack message with a file attachment triggers download via this function. Slack files are in the critical path for processing attachments.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Slack CDN must experience slowdown or become unresponsive. This can occur due to:
- Slack infrastructure issues
- Network connectivity problems
- Large file downloads over slow connections
- Malicious network interception

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | High | Message processing hangs, affecting all Slack channels monitored by the bot |

## Steps to Reproduce

1. Configure OpenClaw with Slack integration
2. Simulate slow Slack CDN responses (e.g., using a proxy that delays responses)
3. Upload a file to a Slack channel the bot monitors
4. Observe that the gateway hangs waiting for the fetch to complete
5. Additional messages queue up, eventually exhausting resources

## Recommended Fix

Add AbortController with timeout, consistent with patterns used elsewhere in the codebase:

```typescript
const SLACK_FETCH_TIMEOUT_MS = 60_000; // 60 seconds for large files

export async function fetchWithSlackAuth(url: string, token: string): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), SLACK_FETCH_TIMEOUT_MS);

  try {
    const initialRes = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
      redirect: "manual",
      signal: controller.signal,
    });

    if (initialRes.status === 302) {
      const resolvedUrl = initialRes.headers.get("location");
      if (!resolvedUrl) throw new Error("Missing redirect location");
      return fetch(resolvedUrl, { redirect: "follow", signal: controller.signal });
    }

    return initialRes;
  } finally {
    clearTimeout(timeoutId);
  }
}
```

## References

- **CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption

## Comments


## Links

- None detected yet
