---
number: 6628
title: "[Bug]: Synchronous file I/O in session listing blocks Node.js event loop"
author: coygeek
created: 2026-02-01T21:59:04Z
updated: 2026-02-02T00:16:25Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6628
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.5 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)


## Summary

The gateway session listing and preview APIs perform synchronous file I/O operations for every session when fetching derived titles, message previews, or session previews. With many sessions (100+), this blocks the Node.js event loop for seconds, freezing all WebSocket connections, HTTP requests, and async operations across the entire gateway.

## Affected Code

### Primary: sessions.list API

**File:** `src/gateway/session-utils.ts:679-704`

```typescript
const finalSessions: GatewaySessionRow[] = sessions.map((s) => {
  const { entry, ...rest } = s;
  let derivedTitle: string | undefined;
  let lastMessagePreview: string | undefined;
  if (entry?.sessionId) {
    if (includeDerivedTitles) {
      // BLOCKING: Called for EVERY session in the list
      const firstUserMsg = readFirstUserMessageFromTranscript(
        entry.sessionId,
        storePath,
        entry.sessionFile,
      );
      derivedTitle = deriveSessionTitle(entry, firstUserMsg);
    }
    if (includeLastMessage) {
      // BLOCKING: Called for EVERY session in the list
      const lastMsg = readLastMessagePreviewFromTranscript(
        entry.sessionId,
        storePath,
        entry.sessionFile,
      );
      // ...
    }
  }
  return { ...rest, derivedTitle, lastMessagePreview };
});
```

**File:** `src/gateway/session-utils.fs.ts:133-168`

```typescript
export function readFirstUserMessageFromTranscript(...): string | null {
  // ...
  let fd: number | null = null;
  try {
    fd = fs.openSync(filePath, "r");        // BLOCKING
    const buf = Buffer.alloc(8192);
    const bytesRead = fs.readSync(fd, buf, 0, buf.length, 0);  // BLOCKING
    // ...
  } finally {
    if (fd !== null) {
      fs.closeSync(fd);                      // BLOCKING
    }
  }
}
```

**File:** `src/gateway/session-utils.fs.ts:186-227`

```typescript
export function readLastMessagePreviewFromTranscript(...): string | null {
  // ...
  fd = fs.openSync(filePath, "r");           // BLOCKING
  const stat = fs.fstatSync(fd);             // BLOCKING
  // ...
  fs.readSync(fd, buf, 0, readLen, readStart);  // BLOCKING
}
```

### Secondary: sessions.preview API

**File:** `src/gateway/server-methods/sessions.ts:66-133`

```typescript
"sessions.preview": ({ params, respond }) => {
  // ...
  const keys = keysRaw.slice(0, 64);  // Up to 64 keys
  // ...
  for (const key of keys) {
    // BLOCKING: Called for EVERY key in the request
    const items = readSessionPreviewItemsFromTranscript(
      entry.sessionId,
      target.storePath,
      entry.sessionFile,
      target.agentId,
      limit,
      maxChars,
    );
    // ...
  }
}
```

**File:** `src/gateway/session-utils.fs.ts:384-430`

```typescript
function readRecentMessagesFromTranscript(...): TranscriptPreviewMessage[] {
  let fd: number | null = null;
  try {
    fd = fs.openSync(filePath, "r");         // BLOCKING
    const stat = fs.fstatSync(fd);           // BLOCKING
    // ...
    fs.readSync(fd, buf, 0, readLen, readStart);  // BLOCKING
  } finally {
    if (fd !== null) {
      fs.closeSync(fd);                       // BLOCKING
    }
  }
}
```

### Tertiary: Static file serving

**File:** `src/gateway/control-ui.ts:167-173`

```typescript
function serveFile(res: ServerResponse, filePath: string) {
  const ext = path.extname(filePath).toLowerCase();
  res.setHeader("Content-Type", contentTypeForExt(ext));
  res.setHeader("Cache-Control", "no-cache");
  res.end(fs.readFileSync(filePath));  // BLOCKING
}
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)

**Authentication required?**
- [x] Low (any authenticated user)

**Entry points:**
- `sessions.list` API with `includeDerivedTitles: true` or `includeLastMessage: true`
- `sessions.preview` API with multiple keys

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)

**User interaction:**
- [x] None (automatic, no victim action needed)

**Prerequisites:** User must have multiple sessions (100+ makes the issue severe). This naturally occurs with regular usage over time.

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | High | Gateway-wide freeze affecting all clients; WebSocket heartbeats fail causing disconnects; cascading failures from retries |

## Steps to Reproduce

1. Create many sessions (100+) with conversation content
2. Call `sessions.list` API with `includeDerivedTitles: true` and `includeLastMessage: true`
3. Observe event loop blocked for multiple seconds
4. During this time, all other WebSocket connections and HTTP requests are frozen
5. Clients may timeout and disconnect

Alternative trigger:
1. Call `sessions.preview` API with 64 session keys
2. Same blocking behavior occurs

## Recommended Fix

1. Convert synchronous file operations to async using `fs.promises`:

```typescript
export async function readFirstUserMessageFromTranscriptAsync(
  sessionId: string,
  storePath: string,
  sessionFile: string | null,
): Promise<string | null> {
  const filePath = getTranscriptPath(sessionId, storePath, sessionFile);
  if (!filePath) return null;

  let filehandle: fs.promises.FileHandle | null = null;
  try {
    filehandle = await fs.promises.open(filePath, "r");
    const buf = Buffer.alloc(8192);
    const { bytesRead } = await filehandle.read(buf, 0, buf.length, 0);
    // ... process buffer
  } finally {
    await filehandle?.close();
  }
}
```

2. Add concurrency limits (e.g., process 10 sessions at a time with `p-limit`)

3. Consider caching first/last message previews in the session store metadata

4. Default `includeDerivedTitles` and `includeLastMessage` to `false` or add pagination

## References

- **CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption
- **Related:** Node.js best practice to avoid blocking the event loop with sync I/O

## Comments


## Links

- None detected yet
