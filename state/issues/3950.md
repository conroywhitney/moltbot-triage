---
number: 3950
title: "[Bug]: spawn EBADF on macOS Daemon (LaunchAgent)"
author: william123438
created: 2026-01-29T12:04:46Z
updated: 2026-01-29T12:04:46Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/moltbot/moltbot/issues/3950
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

# Bug Report: `spawn EBADF` on macOS Daemon (LaunchAgent)

## Summary
The `spawn EBADF` (Bad File Descriptor) error crashes command execution when running shell commands via the Moltbot Daemon (LaunchAgent) on macOS. This prevents the agent from running any shell commands when hosted as a background service.

## Steps to Reproduce
1.  **Install Moltbot** globally on macOS (e.g., via Homebrew/npm).
2.  **Start the Service:** Run `clawdbot daemon start` to launch the background agent.
3.  **Connect a Client:** Connect via `clawdbot tui` or a Telegram/Slack integration.
4.  **Execute Command:** Ask the agent to run a shell command, e.g., `"run exec pwd"`.

## Expected Behavior
The agent should execute the shell command (e.g., `pwd`), capture the standard output, and return the result to the user.

## Actual Behavior
The command fails immediately. The agent reports an execution failure, and the daemon logs show a persistent `spawn EBADF` error.

## Environment
- **Clawdbot Version:** 2026.1.27-beta.1 (7eb57b6)
- **OS:** macOS 26.2 (Build 25C56)
- **Install Method:** Global npm (`/opt/homebrew/lib/node_modules/moltbot`)
- **Node Version:** Node v25.5.0

## Logs
**Gateway Error Log (`~/.clawdbot/logs/gateway.err.log`):**
```text
[exec] spawn failed (spawn EBADF syscall=spawn errno=-9); retrying with no-detach.
[tools] exec failed: spawn EBADF
```

## Root Cause Analysis
The issue stems from the macOS `launchd` environment. When the daemon is started as a LaunchAgent, the `stdin`, `stdout`, and `stderr` file descriptors may be invalid or closed.
When Node.js `child_process.spawn` is called with `stdio: ['pipe', 'pipe', 'pipe']` (the default behavior for capturing output), it attempts to create pipes or duplicate these descriptors. Because the parent's descriptors are invalid, the syscall fails with `EBADF`.

## Workaround Implementation
We successfully patched the issue by avoiding Node.js pipes entirely for the Daemon environment.

**File Modified:** `dist/agents/bash-tools.exec.js`

### Code Changes

**1. Import necessary modules:**
```javascript
import fs from "node:fs";
import os from "node:os";
```

**2. Modify `runExecProcess` to use Shell Redirection:**
Instead of relying on Node.js pipes, we wrap the command to redirect output to temporary files and force `stdio: 'ignore'` to detach from the parent's descriptors.

```javascript
    else {
        const { shell, args: shellArgs } = getShellConfig();
        
        // 1. Generate temp file paths
        tmpOut = path.join(os.tmpdir(), `moltbot-exec-out-${sessionId}.txt`);
        tmpErr = path.join(os.tmpdir(), `moltbot-exec-err-${sessionId}.txt`);
        
        // 2. Wrap command: (cmd) > out.txt 2> err.txt
        const wrappedCommand = `(${opts.command}) > "${tmpOut}" 2> "${tmpErr}"`;
        
        // 3. Spawn with stdio: 'ignore' (CRITICAL for EBADF fix)
        const { child: spawned } = await spawnWithFallback({
            argv: [shell, ...shellArgs, wrappedCommand],
            options: {
                cwd: opts.workdir,
                env: opts.env,
                detached: true, 
                stdio: "ignore", 
            },
            fallbacks: [
                {
                    label: "no-detach-shell-redirect",
                    options: { detached: false, stdio: "ignore" },
                },
            ],
            // ... existing error handling ...
        });
        child = spawned;
    }
```

**3. Modify `handleExit` to read output:**
When the process exits, we read the content from the temporary files and inject it back into the standard `handleStdout` / `handleStderr` flow.

```javascript
        const handleExit = (code, exitSignal) => {
            // Read stdout temp file
            if (tmpOut && fs.existsSync(tmpOut)) {
                try {
                    const content = fs.readFileSync(tmpOut, "utf8");
                    if (content) handleStdout(content);
                    fs.unlinkSync(tmpOut);
                } catch (e) { logWarn(`Failed to read stdout temp file: ${e}`); }
            }
            
            // Read stderr temp file
            if (tmpErr && fs.existsSync(tmpErr)) {
                try {
                    const content = fs.readFileSync(tmpErr, "utf8");
                    if (content) handleStderr(content);
                    fs.unlinkSync(tmpErr);
                } catch (e) { logWarn(`Failed to read stderr temp file: ${e}`); }
            }
            
            // ... continue with existing exit logic ...
```

## Comments


## Links

- None detected yet
