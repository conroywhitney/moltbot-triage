---
number: 6081
title: "[Bug]: Telegram Voice `.ogg` Misclassified as Text"
author: hackmannbr
created: 2026-02-01T08:03:30Z
updated: 2026-02-03T03:19:33Z
labels: ["bug"]
assignees: []
comments_count: 7
reactions_total: 1
url: https://github.com/openclaw/openclaw/issues/6081
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

# üêõ OpenClaw Bug Report ‚Äì Telegram Voice `.ogg` Misclassified as Text

## Summary

Telegram voice messages (`.ogg` / Opus) may be misclassified as text during media understanding. This results in raw binary garbage being injected into the conversation as a `<file>` block, which is **persisted to session history** and reappears when reopening the session.

Live responses appear clean, but historical data becomes corrupted.

---

## Symptoms

* User sends a Telegram voice message (`.ogg`)
* **Live response**:

  * Whisper transcription is correct ‚úÖ
  * No visible garbage
* User closes and reopens the session (TUI or Web UI)
* The **previous user message** now contains an extra block:

```xml
<file name="..." mime="text/tab-separated-values">
  ‚Ä¶binary garbage‚Ä¶
</file>
```

This contaminates:

* Session history (`.jsonl`)
* Memory files generated later from those sessions

---

## Root Cause

In `dist/media-understanding/apply.js`, the function `extractFileBlocks()` attempts heuristic text detection on **all attachments**, including audio:

* `resolveUtf16Charset()`
* `looksLikeUtf8Text()`
* `decodeTextSample()` + `guessDelimitedMime()`

Binary audio data may:

* Decode into byte patterns containing tabs/commas
* Trigger `guessDelimitedMime()`
* Be reclassified as `text/tab-separated-values` or `text/plain`

Once reclassified, a `<file>` block is generated and appended to `ctx.Body`, then persisted. Reopening the session re-renders the corrupted history.

This happens **before** Whisper transcription and **ignores MIME allowlists**, since the code can override MIME based on heuristics.

---

## Why Configuration Allowlists Are Insufficient

Even if `audio/ogg` is excluded from `allowedMimes`, the code path overrides MIME:

```js
const textHint = forcedTextMimeResolved
  ?? guessedDelimited
  ?? (textLike ? "text/plain" : undefined);
```

Thus, binary audio can still be forced into a text MIME and extracted.

---

## Proposed Fix 

Hard-stop text extraction for known binary media **before any text heuristics run**.

Telegram voice notes are OGG containers and always start with the magic bytes:

```
OggS
```

### Fix Strategy

1. Detect known binary media via magic bytes
2. Bail out early in:

   * `resolveUtf16Charset()`
   * `extractFileBlocks()` loop (after buffer fetch, before decoding)

---

## Minimal Patch Example

```js
function hasMagic(buffer, ascii) {
  if (!buffer || buffer.length < ascii.length) return false;
  for (let i = 0; i < ascii.length; i++) {
    if (buffer[i] !== ascii.charCodeAt(i)) return false;
  }
  return true;
}

function isKnownBinaryMedia(buffer) {
  if (hasMagic(buffer, "OggS")) return true; // Telegram voice (OGG/Opus)
  if (hasMagic(buffer, "RIFF")) return true; // WAV/AVI
  if (hasMagic(buffer, "ID3"))  return true; // MP3 tag
  return false;
}
```

### In `resolveUtf16Charset(buffer)`

```js
if (isKnownBinaryMedia(buffer)) {
  return undefined;
}
```

### In `extractFileBlocks()` (inside loop, after `getBuffer()`)

```js
const buf = bufferResult?.buffer;
if (isKnownBinaryMedia(buf)) {
  continue;
}
```

---

## Result After Patch

* Whisper transcription unchanged ‚úÖ
* No `<file>` blocks generated for audio ‚úÖ
* Session history remains clean after reopening ‚úÖ
* No downstream memory contamination ‚úÖ

---

## Environment

* Telegram voice messages (`.ogg` / Opus)
* OpenClaw (npm / pnpm global install)
* Issue reproducible consistently before patch
* Fixed locally using the above approach

---

## Notes

This affects **persisted data integrity**, not only UI rendering.

A magic-byte guard is safer than MIME or heuristic-based detection alone.

Happy to submit a PR if desired.

## Comments

### @VSPlekhanov (2026-02-01)

Can confirm this bug on OpenClaw 2026.1.30 with Telegram voice messages.

Observations:

Telegram voice .ogg files correctly saved with audio extension
MIME type incorrectly detected as text/tab-separated-values instead of audio/ogg
Media understanding pipeline never triggers (no transcription logs)
Manual transcription with Whisper API works perfectly on the same files
Configuration in tools.media.audio is correct, but ignored due to MIME mismatch

Environment:

OpenClaw 2026.1.30 (npm global install)
macOS (Darwin 24.1.0 arm64)
Telegram bot integration
Whisper API skill configured
The proposed magic-byte fix looks solid. Looking forward to the patch! üëç



### @MarcBickel (2026-02-01)

can confirm as well, started when the migration to Openclaw happened, believe it wa 2026.1.29 for me. 

### @batumilove (2026-02-01)

**Additional reproduction data (2026-02-01)**

Reproduced live on OpenClaw 2026.1.29 (Telegram channel):

- Voice message sent to group chat
- File bytes confirmed valid: `OggS` magic header + `OpusHead` markers present
- Reported MIME: `text/tab-separated-values` ‚ùå
- Expected MIME: `audio/ogg`

**Interesting observation:** Deepgram transcription still succeeded ‚Äî it ignores the MIME label and parses actual bytes. So the functional impact is limited to context pollution, not transcription failure.

The root cause analysis in this issue matches our findings exactly. Looking forward to one of the PRs landing!

### @hackmannbr (2026-02-01)

Yep... transcription is fine... just shows the binary junk as a file block after transcription... 

problem is that junk is ending up on memory files and also hanging up browser when load past session's messages

If you guys want i can past here the entire file with this fix. So will be like copy and paste. Also would help validade the fix... for me was dead spot. No more binary junk on audio files transcription.

Also this fix did not change the open file functionality to everything... it just detects audio file and do a pinpoint fix.

### @VSPlekhanov (2026-02-02)

That would be really helpful. 

Probably the best way is to leave a link to PR with the fix

### @hackmannbr (2026-02-02)

ok, i am using OpenClaw 2026.1.30

files is:

~/.npm-global/lib/node_modules/openclaw/dist/media-understanding/apply.js

```
import path from "node:path";
import { finalizeInboundContext } from "../auto-reply/reply/inbound-context.js";
import { logVerbose, shouldLogVerbose } from "../globals.js";
import { DEFAULT_INPUT_FILE_MAX_BYTES, DEFAULT_INPUT_FILE_MAX_CHARS, DEFAULT_INPUT_FILE_MIMES, DEFAULT_INPUT_MAX_REDIRECTS, DEFAULT_INPUT_PDF_MAX_PAGES, DEFAULT_INPUT_PDF_MAX_PIXELS, DEFAULT_INPUT_PDF_MIN_TEXT_CHARS, DEFAULT_INPUT_TIMEOUT_MS, extractFileContentFromSource, normalizeMimeList, normalizeMimeType, } from "../media/input-files.js";
import { extractMediaUserText, formatAudioTranscripts, formatMediaUnderstandingBody, } from "./format.js";
import { runWithConcurrency } from "./concurrency.js";
import { resolveConcurrency } from "./resolve.js";
import { resolveAttachmentKind } from "./attachments.js";
import { buildProviderRegistry, createMediaAttachmentCache, normalizeMediaAttachments, runCapability, } from "./runner.js";
const CAPABILITY_ORDER = ["image", "audio", "video"];
const EXTRA_TEXT_MIMES = [
    "application/xml",
    "text/xml",
    "application/x-yaml",
    "text/yaml",
    "application/yaml",
    "application/javascript",
    "text/javascript",
    "text/tab-separated-values",
];
const TEXT_EXT_MIME = new Map([
    [".csv", "text/csv"],
    [".tsv", "text/tab-separated-values"],
    [".txt", "text/plain"],
    [".md", "text/markdown"],
    [".log", "text/plain"],
    [".ini", "text/plain"],
    [".cfg", "text/plain"],
    [".conf", "text/plain"],
    [".env", "text/plain"],
    [".json", "application/json"],
    [".yaml", "text/yaml"],
    [".yml", "text/yaml"],
    [".xml", "application/xml"],
]);
const XML_ESCAPE_MAP = {
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
};

function hasMagic(buffer, ascii) {
  if (!buffer || buffer.length < ascii.length) return false;
  for (let i = 0; i < ascii.length; i += 1) {
    if (buffer[i] !== ascii.charCodeAt(i)) return false;
  }
  return true;
}

function isKnownBinaryMedia(buffer) {
  // Telegram voice notes are OGG/Opus in an OGG container.
  if (hasMagic(buffer, "OggS")) return true;

  // Defense-in-depth for other common binary formats.
  if (hasMagic(buffer, "RIFF")) return true; // WAV/AVI
  if (hasMagic(buffer, "ID3")) return true;  // MP3 tag header
  if (buffer?.length >= 2 && buffer[0] === 0xff && (buffer[1] & 0xe0) === 0xe0) return true; // MP3 frame sync

  // Images/PDF sometimes get mis-sniffed too (optional but safe)
  if (buffer?.length >= 4 && buffer[0] === 0x89 && buffer[1] === 0x50 && buffer[2] === 0x4e && buffer[3] === 0x47) return true; // PNG
  if (buffer?.length >= 3 && buffer[0] === 0xff && buffer[1] === 0xd8 && buffer[2] === 0xff) return true; // JPEG
  if (buffer?.length >= 4 && buffer[0] === 0x25 && buffer[1] === 0x50 && buffer[2] === 0x44 && buffer[3] === 0x46) return true; // PDF

  return false;
}
/**
 * Escapes special XML characters in attribute values to prevent injection.
 */
function xmlEscapeAttr(value) {
    return value.replace(/[<>&"']/g, (char) => XML_ESCAPE_MAP[char] ?? char);
}
function resolveFileLimits(cfg) {
    const files = cfg.gateway?.http?.endpoints?.responses?.files;
    return {
        allowUrl: files?.allowUrl ?? true,
        allowedMimes: normalizeMimeList(files?.allowedMimes, DEFAULT_INPUT_FILE_MIMES),
        maxBytes: files?.maxBytes ?? DEFAULT_INPUT_FILE_MAX_BYTES,
        maxChars: files?.maxChars ?? DEFAULT_INPUT_FILE_MAX_CHARS,
        maxRedirects: files?.maxRedirects ?? DEFAULT_INPUT_MAX_REDIRECTS,
        timeoutMs: files?.timeoutMs ?? DEFAULT_INPUT_TIMEOUT_MS,
        pdf: {
            maxPages: files?.pdf?.maxPages ?? DEFAULT_INPUT_PDF_MAX_PAGES,
            maxPixels: files?.pdf?.maxPixels ?? DEFAULT_INPUT_PDF_MAX_PIXELS,
            minTextChars: files?.pdf?.minTextChars ?? DEFAULT_INPUT_PDF_MIN_TEXT_CHARS,
        },
    };
}
function appendFileBlocks(body, blocks) {
    if (!blocks || blocks.length === 0) {
        return body ?? "";
    }
    const base = typeof body === "string" ? body.trim() : "";
    const suffix = blocks.join("\n\n").trim();
    if (!base) {
        return suffix;
    }
    return `${base}\n\n${suffix}`.trim();
}
function resolveUtf16Charset(buffer) {
    if (!buffer || buffer.length < 2) {
      return undefined;
    }
    if (isKnownBinaryMedia(buffer)) {
      return undefined;
    }
    const b0 = buffer[0];
    const b1 = buffer[1];
    if (b0 === 0xff && b1 === 0xfe) {
        return "utf-16le";
    }
    if (b0 === 0xfe && b1 === 0xff) {
        return "utf-16be";
    }
    const sampleLen = Math.min(buffer.length, 2048);
    let zeroCount = 0;
    for (let i = 0; i < sampleLen; i += 1) {
        if (buffer[i] === 0) {
            zeroCount += 1;
        }
    }
    if (zeroCount / sampleLen > 0.2) {
        return "utf-16le";
    }
    return undefined;
}
function looksLikeUtf8Text(buffer) {
    if (!buffer || buffer.length === 0) {
        return false;
    }
    const sampleLen = Math.min(buffer.length, 4096);
    let printable = 0;
    let other = 0;
    for (let i = 0; i < sampleLen; i += 1) {
        const byte = buffer[i];
        if (byte === 0) {
            other += 1;
            continue;
        }
        if (byte === 9 || byte === 10 || byte === 13 || (byte >= 32 && byte <= 126)) {
            printable += 1;
        }
        else {
            other += 1;
        }
    }
    const total = printable + other;
    if (total === 0) {
        return false;
    }
    return printable / total > 0.85;
}
function decodeTextSample(buffer) {
    if (!buffer || buffer.length === 0) {
        return "";
    }
    const sample = buffer.subarray(0, Math.min(buffer.length, 8192));
    const utf16Charset = resolveUtf16Charset(sample);
    if (utf16Charset === "utf-16be") {
        const swapped = Buffer.alloc(sample.length);
        for (let i = 0; i + 1 < sample.length; i += 2) {
            swapped[i] = sample[i + 1];
            swapped[i + 1] = sample[i];
        }
        return new TextDecoder("utf-16le").decode(swapped);
    }
    if (utf16Charset === "utf-16le") {
        return new TextDecoder("utf-16le").decode(sample);
    }
    return new TextDecoder("utf-8").decode(sample);
}
function guessDelimitedMime(text) {
    if (!text) {
        return undefined;
    }
    const line = text.split(/\r?\n/)[0] ?? "";
    const tabs = (line.match(/\t/g) ?? []).length;
    const commas = (line.match(/,/g) ?? []).length;
    if (commas > 0) {
        return "text/csv";
    }
    if (tabs > 0) {
        return "text/tab-separated-values";
    }
    return undefined;
}
function resolveTextMimeFromName(name) {
    if (!name) {
        return undefined;
    }
    const ext = path.extname(name).toLowerCase();
    return TEXT_EXT_MIME.get(ext);
}
async function extractFileBlocks(params) {
    const { attachments, cache, limits } = params;
    if (!attachments || attachments.length === 0) {
        return [];
    }
    const blocks = [];
    for (const attachment of attachments) {
        if (!attachment) {
            continue;
        }
        const forcedTextMime = resolveTextMimeFromName(attachment.path ?? attachment.url ?? "");
        const kind = forcedTextMime ? "document" : resolveAttachmentKind(attachment);
        if (!forcedTextMime && (kind === "image" || kind === "video")) {
            continue;
        }
        if (!limits.allowUrl && attachment.url && !attachment.path) {
            if (shouldLogVerbose()) {
                logVerbose(`media: file attachment skipped (url disabled) index=${attachment.index}`);
            }
            continue;
        }
        let bufferResult;
        try {
            bufferResult = await cache.getBuffer({
                attachmentIndex: attachment.index,
                maxBytes: limits.maxBytes,
                timeoutMs: limits.timeoutMs,
            });
        }
        catch (err) {
            if (shouldLogVerbose()) {
                logVerbose(`media: file attachment skipped (buffer): ${String(err)}`);
            }
            continue;
        }

        const buf = bufferResult?.buffer;
        if (isKnownBinaryMedia(buf)) {
            continue;
        }

        const nameHint = bufferResult?.fileName ?? attachment.path ?? attachment.url;
        const forcedTextMimeResolved = forcedTextMime ?? resolveTextMimeFromName(nameHint ?? "");
        const utf16Charset = resolveUtf16Charset(bufferResult?.buffer);
        const textSample = decodeTextSample(bufferResult?.buffer);
        const textLike = Boolean(utf16Charset) || looksLikeUtf8Text(bufferResult?.buffer);
        if (!forcedTextMimeResolved && kind === "audio" && !textLike) {
            continue;
        }
        const guessedDelimited = textLike ? guessDelimitedMime(textSample) : undefined;
        const textHint = forcedTextMimeResolved ?? guessedDelimited ?? (textLike ? "text/plain" : undefined);
        const rawMime = bufferResult?.mime ?? attachment.mime;
        const mimeType = textHint ?? normalizeMimeType(rawMime);
        // Log when MIME type is overridden from non-text to text for auditability
        if (textHint && rawMime && !rawMime.startsWith("text/")) {
            logVerbose(`media: MIME override from "${rawMime}" to "${textHint}" for index=${attachment.index}`);
        }
        if (!mimeType) {
            if (shouldLogVerbose()) {
                logVerbose(`media: file attachment skipped (unknown mime) index=${attachment.index}`);
            }
            continue;
        }
        const allowedMimes = new Set(limits.allowedMimes);
        for (const extra of EXTRA_TEXT_MIMES) {
            allowedMimes.add(extra);
        }
        if (mimeType.startsWith("text/")) {
            allowedMimes.add(mimeType);
        }
        if (!allowedMimes.has(mimeType)) {
            if (shouldLogVerbose()) {
                logVerbose(`media: file attachment skipped (unsupported mime ${mimeType}) index=${attachment.index}`);
            }
            continue;
        }
        let extracted;
        try {
            const mediaType = utf16Charset ? `${mimeType}; charset=${utf16Charset}` : mimeType;
            extracted = await extractFileContentFromSource({
                source: {
                    type: "base64",
                    data: bufferResult.buffer.toString("base64"),
                    mediaType,
                    filename: bufferResult.fileName,
                },
                limits: {
                    ...limits,
                    allowedMimes,
                },
            });
        }
        catch (err) {
            if (shouldLogVerbose()) {
                logVerbose(`media: file attachment skipped (extract): ${String(err)}`);
            }
            continue;
        }
        const text = extracted?.text?.trim() ?? "";
        let blockText = text;
        if (!blockText) {
            if (extracted?.images && extracted.images.length > 0) {
                blockText = "[PDF content rendered to images; images not forwarded to model]";
            }
            else {
                blockText = "[No extractable text]";
            }
        }
        const safeName = (bufferResult.fileName ?? `file-${attachment.index + 1}`)
            .replace(/[\r\n\t]+/g, " ")
            .trim();
        // Escape XML special characters in attributes to prevent injection
        blocks.push(`<file name="${xmlEscapeAttr(safeName)}" mime="${xmlEscapeAttr(mimeType)}">\n${blockText}\n</file>`);
    }
    return blocks;
}
export async function applyMediaUnderstanding(params) {
    const { ctx, cfg } = params;
    const commandCandidates = [ctx.CommandBody, ctx.RawBody, ctx.Body];
    const originalUserText = commandCandidates
        .map((value) => extractMediaUserText(value))
        .find((value) => value && value.trim()) ?? undefined;
    const attachments = normalizeMediaAttachments(ctx);
    const providerRegistry = buildProviderRegistry(params.providers);
    const cache = createMediaAttachmentCache(attachments);
    try {
        const fileBlocks = await extractFileBlocks({
            attachments,
            cache,
            limits: resolveFileLimits(cfg),
        });
        const tasks = CAPABILITY_ORDER.map((capability) => async () => {
            const config = cfg.tools?.media?.[capability];
            return await runCapability({
                capability,
                cfg,
                ctx,
                attachments: cache,
                media: attachments,
                agentDir: params.agentDir,
                providerRegistry,
                config,
                activeModel: params.activeModel,
            });
        });
        const results = await runWithConcurrency(tasks, resolveConcurrency(cfg));
        const outputs = [];
        const decisions = [];
        for (const entry of results) {
            if (!entry) {
                continue;
            }
            for (const output of entry.outputs) {
                outputs.push(output);
            }
            decisions.push(entry.decision);
        }
        if (decisions.length > 0) {
            ctx.MediaUnderstandingDecisions = [...(ctx.MediaUnderstandingDecisions ?? []), ...decisions];
        }
        if (outputs.length > 0) {
            ctx.Body = formatMediaUnderstandingBody({ body: ctx.Body, outputs });
            const audioOutputs = outputs.filter((output) => output.kind === "audio.transcription");
            if (audioOutputs.length > 0) {
                const transcript = formatAudioTranscripts(audioOutputs);
                ctx.Transcript = transcript;
                if (originalUserText) {
                    ctx.CommandBody = originalUserText;
                    ctx.RawBody = originalUserText;
                }
                else {
                    ctx.CommandBody = transcript;
                    ctx.RawBody = transcript;
                }
            }
            else if (originalUserText) {
                ctx.CommandBody = originalUserText;
                ctx.RawBody = originalUserText;
            }
            ctx.MediaUnderstanding = [...(ctx.MediaUnderstanding ?? []), ...outputs];
        }
        if (fileBlocks.length > 0) {
            ctx.Body = appendFileBlocks(ctx.Body, fileBlocks);
        }
        if (outputs.length > 0 || fileBlocks.length > 0) {
            finalizeInboundContext(ctx, {
                forceBodyForAgent: true,
                forceBodyForCommands: outputs.length > 0,
            });
        }
        return {
            outputs,
            decisions,
            appliedImage: outputs.some((output) => output.kind === "image.description"),
            appliedAudio: outputs.some((output) => output.kind === "audio.transcription"),
            appliedVideo: outputs.some((output) => output.kind === "video.description"),
            appliedFile: fileBlocks.length > 0,
        };
    }
    finally {
        await cache.cleanup();
    }
}

```

Let me know if it worked for you.
Cheerz!



### @hackmannbr (2026-02-03)

I think it is fixed on new version:  OpenClaw 2026.2.1 .    I will test sometime and if its ok will close this issue.


## Links

- None detected yet
