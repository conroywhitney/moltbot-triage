---
number: 4448
title: "[Feature]: Done reaction after reply (messages.doneReaction)"
author: spartakb
created: 2026-01-30T07:07:10Z
updated: 2026-01-30T07:33:14Z
labels: []
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/4448
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

Add a configurable "done" emoji reaction that gets added to the user's message after the bot finishes replying. This complements the existing `ackReaction` (intake) and `removeAckAfterReply` (cleanup) flow.

## Motivation

With `ackReaction` + `removeAckAfterReply`, the current flow is:
1. User sends message → ⚡ appears (acknowledged)
2. Bot replies → ⚡ disappears

This works well as a processing indicator, but there's no persistent visual confirmation that the bot handled the message. Adding a "done" reaction creates a complete lifecycle:
1. User sends message → ⚡ appears (processing)
2. Bot replies → ⚡ disappears, ✅ appears (done)

The ✅ stays permanently, giving a clear visual signal in busy channels that the bot handled each message.

## Proposed Config

```json5
{
  messages: {
    ackReaction: "zap",
    ackReactionScope: "all",
    removeAckAfterReply: true,
    doneReaction: "white_check_mark"  // NEW
  }
}
```

- `doneReaction`: Slack emoji name (without colons). Empty string or omitted = disabled.
- Should respect the same scoping as `ackReactionScope` (only fire when ack would have fired).
- Fires after reply delivery, alongside `removeAckAfterReply`.

## Working Implementation

I've built and tested this. Changes required:

### 1. Schema (`config/zod-schema.session.js`)
```js
doneReaction: z.string().optional(),
```

### 2. Provider (`slack/monitor/provider.js`)
```js
const doneReaction = cfg.messages?.doneReaction ?? "";
// ... pass to context creation
```

### 3. Context (`slack/monitor/context.js`)
```js
doneReaction: params.doneReaction ?? "",
```

### 4. Dispatch (`slack/monitor/message-handler/dispatch.js`)
```js
import { reactSlackMessage, removeSlackReaction } from "../../actions.js";

// After removeAckReactionAfterReply block:
if (ctx.doneReaction) {
    const doneEmoji = ctx.doneReaction.replace(/^:+|:+$/g, "");
    reactSlackMessage(message.channel, prepared.ackReactionMessageTs ?? message.ts, doneEmoji, {
        token: ctx.botToken,
        client: ctx.app.client,
    }).catch((err) => {
        logVerbose(`slack done-reaction failed: ${err}`);
    });
}
```

## Notes

- This is channel-agnostic in concept but my implementation is Slack-only. Could be extended to Discord/Telegram.
- The done reaction fires on the same message timestamp as the ack reaction.
- Best-effort (fire and forget with `.catch`) — same pattern as ack reactions.
- Works with both streaming and non-streaming reply paths.

Happy to contribute a PR if maintainers are interested.

## Comments

### @spartakb (2026-01-30)

## Enhancement: `ackReactionSyncParent` — sync reactions to thread parent

Building on the `doneReaction` feature above, I've also implemented parent thread message sync. When a message arrives in a thread, the ack (⚡) and done (✅) reactions are applied to both the sub-message AND the thread's parent message.

### Config

```json5
{
  messages: {
    ackReaction: "zap",
    ackReactionScope: "all",
    removeAckAfterReply: true,
    doneReaction: "white_check_mark",
    ackReactionSyncParent: true  // NEW
  }
}
```

### Full lifecycle in a thread

1. New message arrives → old ✅ removed from parent → ⚡ added to sub-message + parent
2. Bot replies → ⚡ removed from both → ✅ added to both
3. Next message → cycle repeats

The parent message always shows the current state: ⚡ = processing, ✅ = done.

### Implementation details

**Schema** (`config/zod-schema.session.js`):
```js
ackReactionSyncParent: z.boolean().optional(),
```

**Provider** (`slack/monitor/provider.js`):
```js
const ackReactionSyncParent = cfg.messages?.ackReactionSyncParent ?? false;
```

**Prepare** (`slack/monitor/message-handler/prepare.js`):
```js
// Determine parent thread ts
const parentThreadTs = message.thread_ts && message.thread_ts !== message.ts 
    ? message.thread_ts : null;

// Remove old done reaction from parent before adding new ack
if (ctx.ackReactionSyncParent && parentThreadTs && doneReaction) {
    removeSlackReaction(message.channel, parentThreadTs, doneEmoji, { ... })
        .catch(() => { /* ignore - might not have one yet */ });
}

// Add ack reaction to parent
const ackReactionParentPromise = ctx.ackReactionSyncParent && shouldAckReaction() && parentThreadTs
    ? reactSlackMessage(message.channel, parentThreadTs, ackReactionValue, { ... })
    : null;
```

**Dispatch** (`slack/monitor/message-handler/dispatch.js`):
```js
// Direct removal of ack from parent (not promise-gated, avoids "already_reacted" issue)
if (ctx.ackReactionSyncParent && ctx.removeAckAfterReply && prepared.parentThreadTs) {
    removeSlackReaction(message.channel, prepared.parentThreadTs, prepared.ackReactionValue, { ... })
        .catch(() => {});
}

// Add done reaction to parent
if (ctx.ackReactionSyncParent && ctx.doneReaction && prepared.parentThreadTs) {
    reactSlackMessage(message.channel, prepared.parentThreadTs, doneEmoji, { ... })
        .catch(() => {});
}
```

### Key design decision

Parent ack removal uses **direct `removeSlackReaction`** instead of `removeAckReactionAfterReply`. The promise-gated approach fails when the parent already has an ⚡ from a previous cycle — `reactions.add` returns "already_reacted" error → promise resolves to `false` → removal is skipped. Direct removal avoids this entirely.


## Links

- None detected yet
