---
number: 7139
title: "Critical: Default configuration provides zero isolation - users have unrestricted filesystem access and plaintext credentials"
author: joshyorko
created: 2026-02-02T12:50:53Z
updated: 2026-02-03T00:09:21Z
labels: []
assignees: []
comments_count: 2
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/7139
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Summary

OpenClaw's default configuration gives an AI agent **unrestricted read/write access to the entire filesystem** and stores API credentials in **plaintext JSON files**. The "workspace" is not a sandbox - it is a lie. This is not a misconfiguration edge case. This is the out-of-box experience for every user.

This has been independently verified by multiple security audits. Users are being harmed.

---

## Issue 1: The "Workspace" Is Not a Sandbox

**Your own documentation admits this** (`docs/concepts/agent-workspace.md`):

> **Important:** the workspace is the **default cwd**, not a hard sandbox. Tools resolve relative paths against the workspace, but **absolute paths can still reach elsewhere on the host** unless sandboxing is enabled.

**Code proof** (`src/agents/pi-tools.ts`):
```typescript
if (tool.name === readTool.name) {
  if (sandboxRoot) {
    return [createSandboxedReadTool(sandboxRoot)];  // Only used when sandbox ON
  }
  const freshReadTool = createReadTool(workspaceRoot);  // Default: NO path restrictions
  return [createOpenClawReadTool(freshReadTool)];
}
```

**What this means in practice:**
- `read({ path: "~/.ssh/id_rsa" })` - works
- `read({ path: "~/.aws/credentials" })` - works  
- `read({ path: "/etc/shadow" })` - works (if running as root)
- `exec({ command: "rm -rf ~" })` - works

The default configuration provides **zero filesystem isolation**.

---

## Issue 2: Sandbox Disabled by Default

**Code proof** (`src/agents/sandbox/config.ts:137`):
```typescript
return {
  mode: agentSandbox?.mode ?? agent?.mode ?? "off",  // DEFAULT IS "off"
  // ...
}
```

A Docker sandbox implementation exists with proper isolation (`--network none`, `--cap-drop ALL`, `--read-only`, `--security-opt no-new-privileges`). It is well-designed. **But it is opt-in and disabled by default.**

Users must explicitly know to configure `sandbox.mode: "docker"` to get any protection. Most users do not know this.

---

## Issue 3: Plaintext Credential Storage

**Code proof** (`src/agents/auth-profiles/store.ts:283-291`):
```typescript
export function saveAuthProfileStore(store: AuthProfileStore, agentDir?: string): void {
  const authPath = resolveAuthStorePath(agentDir);
  const payload = {
    version: AUTH_STORE_VERSION,
    profiles: store.profiles,  // Contains raw API keys
    // ...
  };
  saveJsonFile(authPath, payload);  // Plaintext JSON
}
```

API keys for Anthropic, OpenAI, and other providers are stored in `~/.openclaw/agents/*/agent/auth-profiles.json` as plaintext. Any malware, malicious browser extension, or compromised process can read these files and exfiltrate credentials.

The iOS app uses proper Keychain storage (`apps/ios/Sources/Gateway/KeychainStore.swift`). The CLI/server does not.

---

## Issue 4: Per-Route Authentication (Fragile Pattern)

There is no global authentication middleware. Each route implements its own auth check. This is a classic "vibe coding" anti-pattern where:
- New routes can be added without auth and nobody notices
- Auth logic is duplicated and inconsistent
- One missed check exposes a vulnerability

---

## Issue 5: No CORS Protection

No `Access-Control-Allow-Origin` headers are set. While token-based auth provides some protection, defense-in-depth requires explicit CORS denial for cross-origin requests to a local agent.

---

## The Core Problem

This application was built by an experienced engineer (founder of PSPDFKit) using "vibe coding" methodology. The result is software that looks functional but has fundamental security architecture problems:

1. Security features exist but are opt-in rather than opt-out
2. The path of least resistance leaves users completely exposed
3. Documentation buries warnings about lack of isolation instead of making secure defaults
4. Battle-tested solutions (OS keychain, container isolation) were skipped in favor of shipping fast

A user who downloads OpenClaw and runs it with default settings is giving an AI agent:
- Full filesystem access to their machine
- Credentials stored where any malware can read them
- Direct shell execution with no sandboxing
- No network isolation

This is unacceptable for software that markets itself as a personal AI assistant.

---

## Required Changes

1. **Sandbox enabled by default** - Change `mode` default from `"off"` to `"docker"` (or require explicit user acknowledgment of risks)
2. **OS keychain integration** - Store credentials in platform-native secure storage
3. **Global auth middleware** - Replace per-route auth with middleware pattern
4. **CORS headers** - Explicitly deny cross-origin requests
5. **Startup warning** - Display clear warning when running without sandbox

---

## References

- Commit analyzed: `57d008a33d4208c81183384d47f938d69b7c7044`
- Independent verification: GitHub Copilot code analysis, Gemini security audit
- Related documentation: `docs/concepts/agent-workspace.md` (admits workspace is not a sandbox)

## Comments

### @joshyorko (2026-02-02)

## Deeper Analysis: Architectural Negligence

After further code review, the problems go deeper than insecure defaults. This is a case of building features first and security never - exactly the pattern you see when AI writes code without architectural oversight.

---

### They Know About These Issues

The codebase has a 37KB security audit file (`src/security/audit.ts`) that detects:
- Missing gateway authentication
- File permission problems
- Dangerous configuration options
- Channel security vulnerabilities

The audit tool flags `gateway.loopback_no_auth` as **critical**. They know this is a problem. But instead of making secure defaults, they built a tool to tell users about problems **after they've already been exposed**.

This is backwards. Security should be preventive, not reactive.

---

### No Rate Limiting

Search for "rate limit" in the codebase returns documentation and changelog entries, not implementation. An AI agent with shell access and no rate limiting is a recipe for resource exhaustion attacks.

---

### No Input Validation Framework

There is no centralized input validation. Each route handles its own validation (or doesn't). This is the same per-route pattern as authentication - fragile and prone to gaps.

---

### Framework Comparison

The user asked why not just use Django. Here's what Django would have provided out of the box:
- CSRF protection (enabled by default)
- Secure session management
- Forced SECRET_KEY configuration
- Built-in password hashing
- SQL injection protection via ORM
- Security middleware
- Proper CORS handling with django-cors-headers

Express/Node provides none of this. You have to add every security feature manually. When you "vibe code" with Express, you get exactly what OpenClaw has: a feature-complete application with security bolted on as an afterthought.

This isn't about Node vs Python. It's about choosing a framework that forces security decisions upfront vs one that lets you ship insecure code by default.

---

### The Pattern

1. Feature works? Ship it.
2. Security audit finds problem? Document it in audit.ts.
3. User runs `openclaw security audit`? Now they know they're vulnerable.
4. User doesn't run audit? They never find out.

This is not how security engineering works.

---

### Additional Missing Security Controls

- **No session expiration** - Tokens don't expire by default
- **No audit logging** - No record of who accessed what when
- **No principle of least privilege** - All authenticated users have full access
- **No secrets rotation** - Plaintext credentials with no rotation mechanism
- **No security headers** - No Content-Security-Policy, X-Frame-Options, etc.
- **No input sanitization** - User input goes directly to AI prompts (prompt injection vector)

---

### The Real Issue

This codebase was built by someone who knows better. The iOS app uses proper Keychain storage. The Docker sandbox has proper isolation flags. The security audit catches real problems.

But all of that is opt-in. The path of least resistance - which is the path every new user takes - leaves them completely exposed.

Either make the secure path the default path, or stop marketing this as production-ready software.

### @unisone (2026-02-03)

Some of these gaps are being actively addressed â€” I have open PRs for config validation fail-closed (#6700, fixes the "silent reset to insecure defaults" pattern), telegram webhook binding to loopback (#7357), and path traversal in archive extraction (#6729). The "validate at the boundary" pattern mentioned here is exactly what #7484 does for the browser upload API.

The broader point about secure defaults > reactive auditing is spot on though. The audit tool catches problems after exposure; these fixes move validation to the code path itself.



## Links

- None detected yet
