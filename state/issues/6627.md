---
number: 6627
title: "[Bug]: Ngrok command spawns lack timeout causing indefinite hangs"
author: coygeek
created: 2026-02-01T21:59:03Z
updated: 2026-02-02T00:16:26Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6627
duplicate_of: null
related_issues: [4956,5135]
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.2 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)


## Summary

The voice-call extension spawns ngrok CLI commands without any timeout mechanism. If the ngrok binary hangs (network issues, stuck auth token update, unresponsive process), the Promise never resolves, blocking the caller indefinitely and potentially causing the voice-call feature to hang forever.

## Affected Code

**File:** `extensions/voice-call/src/tunnel.ts:164-209`

```typescript
async function runNgrokCommand(args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn("ngrok", args, {
      stdio: ["ignore", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";
    proc.stdout.on("data", (data) => (stdout += data.toString()));
    proc.stderr.on("data", (data) => (stderr += data.toString()));

    // NO TIMEOUT - hangs indefinitely if ngrok is unresponsive
    proc.on("close", (code) => {
      if (code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(`ngrok command failed: ${stderr || stdout}`));
      }
    });
    proc.on("error", reject);
  });
}

export async function isNgrokAvailable(): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn("ngrok", ["version"], {
      stdio: ["ignore", "pipe", "pipe"],
    });
    // NO TIMEOUT - availability check can hang forever
    proc.on("close", (code) => {
      resolve(code === 0);
    });
    proc.on("error", () => {
      resolve(false);
    });
  });
}
```

## Attack Surface

**How is this reached?**
- [x] Local (local file, CLI argument, environment variable)

**Authentication required?**
- [x] None (unauthenticated/public access)

**Entry point:** Voice call feature initialization triggers `isNgrokAvailable()`, and tunnel creation triggers `runNgrokCommand()`.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)

**User interaction:**
- [x] None (automatic, no victim action needed)

**Prerequisites:** Ngrok binary must be in a state where it hangs (network timeout, stuck auth, unresponsive process).

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | High | Voice call feature becomes completely unresponsive; initialization can hang forever |

## Steps to Reproduce

1. Configure voice-call extension to use ngrok tunneling
2. Cause ngrok binary to hang (e.g., network firewall blocking ngrok API, corrupted ngrok state)
3. Trigger voice call feature initialization
4. Observe that `isNgrokAvailable()` or `runNgrokCommand()` never returns
5. Voice call feature is now permanently stuck

## Recommended Fix

Add a timeout wrapper around the spawn operations:

```typescript
async function runNgrokCommand(args: string[], timeoutMs = 30000): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn("ngrok", args, {
      stdio: ["ignore", "pipe", "pipe"],
    });

    const timeout = setTimeout(() => {
      proc.kill("SIGKILL");
      reject(new Error(`ngrok command timed out after ${timeoutMs}ms`));
    }, timeoutMs);

    let stdout = "";
    let stderr = "";
    proc.stdout.on("data", (data) => (stdout += data.toString()));
    proc.stderr.on("data", (data) => (stderr += data.toString()));

    proc.on("close", (code) => {
      clearTimeout(timeout);
      if (code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(`ngrok command failed: ${stderr || stdout}`));
      }
    });
    proc.on("error", (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}
```

## References

- **CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption
- **Related:** Similar to #5135 (execDocker() missing spawn error handler), #4956 (waitForWaConnection() no timeout)

## Comments


## Links

- None detected yet
