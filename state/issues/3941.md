---
number: 3941
title: "[Bug]: Browser Control Server hangs on /start endpoint (x64 Ubuntu)"
author: AlbertoSpain
created: 2026-01-29T11:45:27Z
updated: 2026-01-31T02:34:50Z
labels: ["bug"]
assignees: []
comments_count: 2
reactions_total: 1
url: https://github.com/openclaw/openclaw/issues/3941
duplicate_of: null
related_issues: [2702]
blocks: []
blocked_by: []
---

## Description

## Summary

Browser control server hangs indefinitely when receiving POST requests to `/start` endpoint, causing timeout errors despite the server being active and responding to other requests.

## Steps to reproduce

1. Install Clawdbot on Ubuntu 24.04 x64
2. Configure browser with Playwright's Chromium:
   ```json
   "browser": {
     "enabled": true,
     "defaultProfile": "clawd",
     "executablePath": "/home/user/.cache/ms-playwright/chromium-1208/chrome-linux64/chrome",
     "headless": true
   }
   ```
3. Start gateway: `clawdbot gateway start`
4. Attempt to use browser: `browser.start()`

## Expected behavior

Browser should launch successfully in headless mode.

## Actual behavior

- Browser control server starts and listens on port 18791
- Server responds to GET requests (e.g., `curl http://127.0.0.1:18791/` returns 200 OK)
- POST requests to `/start` hang indefinitely without any error logs
- After 15 seconds, timeout error occurs: `Can't reach the clawd browser control server at http://127.0.0.1:18791/start (timed out after 15000ms)`

## Environment

- **Clawdbot Version:** 2026.1.24-3
- **OS:** Ubuntu 24.04.1 LTS (x64)
- **Node.js:** v22.22.0
- **Playwright:** Chromium 145.0.7632.6 (installed via `npx playwright install chromium`)
- **Display:** No X11 (SSH connection, headless mode required)

## Additional context

- Playwright works correctly when tested directly:
  ```javascript
  const browser = await chromium.launch({
    executablePath: '/home/user/.cache/ms-playwright/chromium-1208/chrome-linux64/chrome',
    headless: true
  });
  // Works perfectly ✓
  ```
- Browser control server logs show it starts successfully but no errors when it hangs
- Similar to #2702 but on x64 instead of arm64
- The `/start` endpoint specifically causes the hang - other endpoints respond

## Logs

Gateway starts successfully:
```
{"subsystem":"browser/server"} Browser control listening on http://127.0.0.1:18791/
```

Tool call attempt:
```
{"subsystem":"agent/embedded"} embedded run tool start: tool=browser toolCallId=...
[tools] browser failed: Can't reach the clawd browser control server at http://127.0.0.1:18791/start (timed out after 15000ms)
```

No errors or exceptions logged during the hang.

## Comments

### @AlbertoSpain (2026-01-29)

## Root Cause Analysis

I've identified the exact source of this bug by analyzing the moltbot source code.

### The Problem

The  endpoint is **synchronously blocking** during Chrome launch, consuming the entire 15-second timeout without responding to the HTTP client.

**Location**: `src/browser/chrome.ts` - `launchClawdChrome()` function (lines 201-205)

```typescript
const readyDeadline = Date.now() + 15_000;
while (Date.now() < readyDeadline) {
  if (await isChromeReachable(profile.cdpUrl, 500)) break;
  await new Promise((r) => setTimeout(r, 200));
}
```

### Call Chain

1. Client calls `POST /start` → `src/browser/routes/basic.ts` (line ~93)
2. Endpoint calls `profileCtx.ensureBrowserAvailable()` → `src/browser/server-context.ts` 
3. Which calls `launchClawdChrome()` → `src/browser/chrome.ts`
4. **Blocks here**: Busy-wait loop checking if Chrome is reachable for up to 15 seconds
5. If Chrome fails to start, loop consumes all 15 seconds **before** sending HTTP response
6. Client timeout (also 15s) expires before server can respond with error

### Why Both Timeouts Collide

- **Server-side**: 15-second busy-wait in `launchClawdChrome()`
- **Client-side**: 15-second timeout in browser tool
- Result: Client times out at ~15s, server finally responds with error at ~15s → timeout race condition

### The Fix

The `/start` endpoint should:
1. **Respond immediately** with `{ status: 'starting' }`
2. Launch Chrome in background
3. Provide a separate endpoint to poll for ready state (e.g., `GET /status` with `running` field)

Or alternatively:
- Keep current synchronous approach but respond with progress updates (chunked response / SSE)
- Reduce initial timeout to fail-fast (e.g., 5s) then return error immediately

### Related Code

All relevant files in the browser subsystem:
- `src/browser/server.ts` - HTTP server setup
- `src/browser/routes/basic.ts` - Route handlers
- `src/browser/server-context.ts` - Profile context and `ensureBrowserAvailable()`
- `src/browser/chrome.ts` - **The blocking loop** in `launchClawdChrome()`

This explains why GET requests work fine (no Chrome launch) but POST /start hangs (launches Chrome synchronously).

### @AlbertoSpain (2026-01-29)

## Update: Root Cause Confirmed + Workaround Found

### Confirmation
Chrome **does work** on x64 Ubuntu when properly configured. The blocking timeout is definitely the root cause of the issue.

### The Missing Piece: `noSandbox`

In headless environments without X11, Chrome requires:
```json
"browser": {
  "enabled": true,
  "noSandbox": true,
  "headless": true
}
```

Without `noSandbox: true`, Chrome fails silently in headless mode.

### Temporary Workaround

I've patched the timeout locally to validate the fix:

**File**: `dist/browser/chrome.js` (line ~203)
```javascript
// Original: const readyDeadline = Date.now() + 15_000;
const readyDeadline = Date.now() + 10_000;  // Reduced to 10s
```

With this change + `noSandbox: true`, browser now starts successfully:
- Chrome launches in ~2-3 seconds
- CDP ready and responding
- Browser tool fully functional

### Why The Issue Still Matters

Even though Chrome works with the right config, **the synchronous blocking design is still a bug**:

1. **Poor user experience**: Client waits 10s with no feedback
2. **Fragile**: Any delay in Chrome startup causes timeout
3. **No progress indication**: User doesn't know if it's working or stuck
4. **Resource waste**: Blocks Express worker thread during entire startup

### Recommended Fix

As stated in the original analysis, `/start` should:
1. Respond immediately with `{ status: 'starting', profile: '...' }`
2. Launch Chrome in background
3. Let clients poll `GET /` (status endpoint) for `running: true`

This pattern is standard for long-running operations in REST APIs.


## Links

- None detected yet
