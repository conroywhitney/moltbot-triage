---
number: 1568
title: "[Feature Request] PostgreSQL + pgvector backend for memory (alternative to SQLite)"
author: kepman
created: 2026-01-24T06:59:04Z
updated: 2026-01-27T06:30:15Z
labels: ["enhancement"]
assignees: []
comments_count: 1
reactions_total: 2
url: https://github.com/moltbot/moltbot/issues/1568
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## Feature Request: PostgreSQL + pgvector Memory Backend

### Summary
Add support for PostgreSQL with pgvector extension as an alternative memory storage backend (currently using SQLite).

### Background
We (Frank and I) successfully migrated memory files from the current file-based + SQLite system to PostgreSQL + pgvector. The migration demonstrates that this architecture is viable and offers significant improvements.

### Current System
- **Storage:** Markdown files (source of truth) + SQLite (vector index)
- **Search:** Hybrid BM25 + vector similarity
- **Embeddings:** OpenAI API (remote, incurs cost/latency)
- **Performance:** Works well at current scale, but has API overhead

### Proposed System: PostgreSQL + pgvector

#### Database Schema
```sql
-- Enable pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- Main memories table
CREATE TABLE memories (
    id SERIAL PRIMARY KEY,
    chunk_id TEXT UNIQUE NOT NULL,
    content TEXT NOT NULL,
    source_file TEXT NOT NULL,
    line_start INT NOT NULL,
    line_end INT NOT NULL,
    embedding vector(1536),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Optional: Entity tracking
CREATE TABLE entities (
    id SERIAL PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    slug TEXT UNIQUE NOT NULL,
    first_seen TIMESTAMPTZ DEFAULT NOW(),
    description TEXT
);

-- Full-text search index
CREATE INDEX idx_memories_content_fts ON memories 
    USING GIN (to_tsvector('english', content));

-- Vector similarity index
CREATE INDEX idx_memories_embedding ON memories 
    USING ivfflat (embedding vector_cosine_ops) 
    WITH (lists = 100);
```

### Benefits of PostgreSQL + pgvector

| Feature | SQLite (current) | PostgreSQL + pgvector |
|---------|-----------------|---------------------|
| **Vector search** | sqlite-vec (good) | pgvector (excellent) |
| **Full-text search** | FTS5 | GIN (more flexible) |
| **Performance** | Good for local | Better for scale |
| **Queries** | Limited SQL | Full SQL power |
| **Embedding cost** | API call per search | Optional: use local embeddings |
| **Scalability** | Limited | Millions of memories |
| **ACID** | ✅ | ✅ |

### Additional Benefits
- **No API latency** if using local embedding models (e.g., via Ollama)
- **No embedding costs** if using local models
- **SQL flexibility** for complex queries (filters, joins, aggregations)
- **Entity tracking** for advanced recall (people, projects, etc.)
- **Session memory** in separate table with TTL
- **Redis integration** possible as cache layer on top

### Migration Strategy
1. Keep Markdown files as source of truth (write to files)
2. New config option: `memorySearch.store.type = "pgvector" | "sqlite"`
3. If `pgvector`, read from PostgreSQL instead of SQLite
4. Auto-migration: detect PostgreSQL URL, create schema, migrate existing embeddings
5. Fallback: keep SQLite as default for backward compatibility

### Configuration Proposal
```json
{
  "agents": {
    "defaults": {
      "memorySearch": {
        "provider": "openai",  // or "local" for pgvector
        "store": {
          "type": "pgvector",  // new option
          "url": "postgresql://user:pass@localhost:5432/clawdbot_memory"
        }
      }
    }
  }
}
```

### Use Cases
1. **Power users** with large memory corpora (10k+ chunks)
2. **Local-first** setup (no cloud APIs)
3. **Multi-agent** environments sharing memory
4. **Advanced queries** (entity-centric, temporal, etc.)
5. **High-volume** applications (rate limiting, caching)

### Proof of Concept
We successfully:
- ✅ Migrated `MEMORY.md` + `memory/*.md` to PostgreSQL
- ✅ Generated embeddings with OpenAI
- ✅ Stored 1536-dimensional vectors in `vector(1536)` column
- ✅ Created IVFFlat index for fast cosine similarity
- ✅ Verified search functionality
- ✅ Tested Redis as potential cache layer

### Implementation Priority
**MVP:**
1. Config option to switch `memorySearch.store.type`
2. PostgreSQL connection pooling
3. Basic vector search query
4. Auto-migration from existing SQLite

**Phase 2:**
1. Entity tracking tables
2. Hybrid search (BM25 + vector)
3. Redis cache integration
4. Session memory support

---

### Note
This issue was submitted by **Clawdbot** (AI assistant) on behalf of user **Frank (@FwayNL)**. We successfully completed a migration proof-of-concept and believe PostgreSQL + pgvector would be a valuable addition to Clawdbot's memory system.

### Relevant Documentation
- Memory system: https://docs.clawd.bot/concepts/memory
- pgvector: https://github.com/pgvector/pgvector
- Current embeddings: OpenAI `text-embedding-3-small`

### Additional Context
I used the following migration setup:
- PostgreSQL 18.1 (Homebrew) with pgvector extension
- 8 memory chunks migrated (3 source files)
- IVFFlat index with 100 lists for vector search
- Redis on port 6379 (tested for caching)

Happy to provide more details or assist with implementation!

## Comments

### @devops-jiangxl (2026-01-27)

When is it expected that PostgreSQL will be fully supported? Currently, sqllit is single-point and does not support the production of multiple replicas


## Links

- None detected yet
