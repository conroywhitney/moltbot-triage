---
number: 6026
title: "[Bug]: Unbounded Rate Limit Map Enables Memory Exhaustion Attack"
author: coygeek
created: 2026-02-01T06:28:56Z
updated: 2026-02-02T00:16:55Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6026
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 7.5 / 10.0 |
| **Severity** | High |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)


## Summary

The Nostr profile HTTP endpoint uses a rate limit map that never deletes entries. An attacker can exhaust memory by making requests with random account IDs, each creating a permanent map entry.

## Affected Code

**File:** `extensions/nostr/src/nostr-profile-http.ts:45-64`

```typescript
const rateLimitMap = new Map<string, RateLimitEntry>();

function checkRateLimit(accountId: string): boolean {
  const now = Date.now();
  const entry = rateLimitMap.get(accountId);

  if (!entry || now - entry.windowStart > RATE_LIMIT_WINDOW_MS) {
    rateLimitMap.set(accountId, { count: 1, windowStart: now });  // Sets but NEVER deletes
    return true;
  }

  if (entry.count >= RATE_LIMIT_MAX_REQUESTS) {
    return false;
  }

  entry.count++;
  return true;
}
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)

**Authentication required?**
- [x] None (unauthenticated/public access)

**Entry point:** `PUT /api/channels/nostr/:accountId/profile` - The `accountId` comes directly from the URL path with no validation.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)

**User interaction:**
- [x] None (automatic, no victim action needed)

**Prerequisites:** Network access to the Nostr profile endpoint. No authentication required before rate limiting is checked.

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | High | Memory exhaustion via unbounded map growth |

## Steps to Reproduce

1. Send requests with random account IDs:
   ```bash
   for i in $(seq 1 1000000); do
     curl -X PUT "http://target/api/channels/nostr/random-$RANDOM-$i/profile" &
   done
   ```
2. Each unique accountId creates a new map entry: `{ count: 1, windowStart: timestamp }`
3. Monitor memory: `watch -n 1 'ps aux | grep openclaw | awk "{print \$6}"'`
4. Observe: Memory grows linearly with unique accountIds
5. Eventually: OOM killer terminates the process

## Recommended Fix

Add periodic cleanup of expired entries:

```typescript
const CLEANUP_INTERVAL_MS = 60000;  // 1 minute

setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimitMap) {
    if (now - entry.windowStart > RATE_LIMIT_WINDOW_MS) {
      rateLimitMap.delete(key);
    }
  }
}, CLEANUP_INTERVAL_MS);
```

Or use a bounded LRU cache:

```typescript
import { LRUCache } from "lru-cache";

const rateLimitMap = new LRUCache<string, RateLimitEntry>({
  max: 10000,
  ttl: RATE_LIMIT_WINDOW_MS,
});
```

## References

- **CWE:** [CWE-770](https://cwe.mitre.org/data/definitions/770.html) - Allocation of Resources Without Limits or Throttling

## Comments


## Links

- None detected yet
