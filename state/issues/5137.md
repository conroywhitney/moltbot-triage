---
number: 5137
title: "[Bug]: OpenAI Realtime STT waitForTranscript() has race condition causing hung Promises"
author: coygeek
created: 2026-01-31T03:32:37Z
updated: 2026-02-02T00:20:16Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5137
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description


**Severity:** P1/High (Score: 95/150)
**CWE:** [CWE-362](https://cwe.mitre.org/data/definitions/362.html) - Concurrent Execution Using Shared Resource with Improper Synchronization
**OWASP:** [A05:2021](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security Misconfiguration
**File:** `extensions/voice-call/src/providers/stt-openai-realtime.ts:284-297`

| Factor | Assessment | Score |
|--------|------------|-------|
| **Reachability** | Voice call transcription | 25/40 |
| **Impact** | Hung promises, memory leak | 25/50 |
| **Exploitability** | Concurrent transcript requests | 15/30 |
| **Verification** | Code confirmed | 30/30 |
| **Total** | â€” | **95/150** |

## Summary
The `waitForTranscript()` method in the OpenAI Realtime STT provider replaces `this.onTranscriptCallback` each time it's called. Concurrent calls cause one caller's Promise to hang forever because their callback is overwritten.

## Steps to reproduce
1. Call `waitForTranscript()` from two concurrent callers
2. The second call overwrites the first caller's callback
3. The first caller's Promise never resolves or rejects
4. The timeout from the first call may fire and null out the callback, breaking the second caller

## Expected behavior
Concurrent calls to `waitForTranscript()` should be properly queued or reject if already waiting.

## Actual behavior
The callback is a single instance variable that gets overwritten, causing race conditions.

### Affected code location:
**File** (`extensions/voice-call/src/providers/stt-openai-realtime.ts:284-296`):
```typescript
async waitForTranscript(timeoutMs = 30000): Promise<string> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      this.onTranscriptCallback = null;
      reject(new Error("Transcript timeout"));
    }, timeoutMs);

    this.onTranscriptCallback = (transcript) => {
      clearTimeout(timeout);
      this.onTranscriptCallback = null;
      resolve(transcript);
    };
  });
}
```

## Environment
- Version: latest (main branch)
- OS: Any
- Install method: Any

## Logs or screenshots
N/A - issue is in code logic

## Impact
- **Hung Promises**: Permanently hung Promises leak memory and resources
- **Voice Call Failures**: In voice call scenarios with rapid transcription requests, calls may hang
- **Memory Leak**: Unresolving Promises accumulate over time

## Recommended fix
Use a queue-based approach or mutex:
```typescript
private transcriptWaiters: Array<{
  resolve: (transcript: string) => void;
  reject: (err: Error) => void;
  timeout: NodeJS.Timeout;
}> = [];

async waitForTranscript(timeoutMs = 30000): Promise<string> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      const idx = this.transcriptWaiters.findIndex(w => w.timeout === timeout);
      if (idx >= 0) this.transcriptWaiters.splice(idx, 1);
      reject(new Error("Transcript timeout"));
    }, timeoutMs);

    this.transcriptWaiters.push({ resolve, reject, timeout });
  });
}

private onTranscriptReceived(transcript: string) {
  const waiter = this.transcriptWaiters.shift();
  if (waiter) {
    clearTimeout(waiter.timeout);
    waiter.resolve(transcript);
  }
}
```

## Comments

### @coygeek (2026-02-01)

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 5.3 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H)



## Links

- None detected yet
