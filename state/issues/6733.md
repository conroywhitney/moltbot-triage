---
number: 6733
title: "[Bug]: Plugin schema validator cache grows unbounded without eviction"
author: coygeek
created: 2026-02-02T00:49:53Z
updated: 2026-02-02T02:57:20Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6733
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 4.0 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L)


## Summary

The plugin schema validator cache accumulates compiled AJV validators for each unique schema cache key but has no eviction mechanism. In long-running gateway processes with plugin updates or multi-workspace usage, this causes gradual memory growth.

## Affected Code

**File:** `src/plugins/schema-validator.ts:14`

```typescript
const schemaCache = new Map<string, CachedValidator>();
```

**Usage at lines 27-37:**

```typescript
export function validateJsonSchemaValue(params: {
  schema: Record<string, unknown>;
  cacheKey: string;
  value: unknown;
}): { ok: true } | { ok: false; errors: string[] } {
  let cached = schemaCache.get(params.cacheKey);
  if (!cached || cached.schema !== params.schema) {
    const validate = ajv.compile(params.schema);
    cached = { validate, schema: params.schema };
    schemaCache.set(params.cacheKey, cached);  // Never evicted
  }
  // ...
}
```

**Contrast with properly bounded caches:**

```typescript
// manifest-registry.ts HAS TTL (good pattern):
const registryCache = new Map<string, { expiresAt: number; registry: PluginManifestRegistry }>();
```

## Attack Surface

**How is this reached?**
- [ ] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [x] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [x] None (unauthenticated/public access)
- [ ] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Plugin loading during normal operation. Cache key is `manifestPath:mtimeMs`.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Long-running process with plugin schema validation activity.

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data exposure |
| Integrity | None | No data modification |
| Availability | Low | Gradual memory growth, slower than runtime state leaks |

## Steps to Reproduce

1. Run a gateway with plugins enabled
2. Update plugin manifests periodically (each update creates new cache key)
3. Or configure multiple workspaces with different plugin sets
4. Monitor process memory over time
5. Observe: `schemaCache` grows with each unique manifest+mtime combination

## Recommended Fix

Add TTL-based eviction similar to `manifest-registry.ts`:

```typescript
interface CachedValidator {
  validate: AjvValidateFunction;
  schema: Record<string, unknown>;
  expiresAt: number;
}

const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

function getCached(cacheKey: string): CachedValidator | undefined {
  const cached = schemaCache.get(cacheKey);
  if (cached && Date.now() < cached.expiresAt) {
    return cached;
  }
  schemaCache.delete(cacheKey);
  return undefined;
}
```

## References

- **CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption

## Comments


## Links

- None detected yet
