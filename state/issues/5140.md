---
number: 5140
title: "[Bug]: DirectoryCache grows unbounded without max size limit"
author: coygeek
created: 2026-01-31T03:34:08Z
updated: 2026-02-02T00:20:13Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5140
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description


**Severity:** P2/Medium (Score: 70/150) 
**CWE:** [CWE-400](https://cwe.mitre.org/data/definitions/400.html) - Uncontrolled Resource Consumption
**OWASP:** [A05:2021](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security Misconfiguration
**File:** `src/infra/outbound/directory-cache.ts:22-61`

| Factor | Assessment | Score |
|--------|------------|-------|
| **Reachability** | Directory lookups | 30/40 |
| **Impact** | Memory growth | 15/50 |
| **Exploitability** | Passive - depends on targets | 5/30 |
| **Verification** | Code confirmed with mitigations | 20/30 |
| **Total** | â€” | **70/150** |

**Downgrade Reason:** Partial mitigations exist: (1) Config change clears the entire cache, (2) TTL provides cleanup on read access. Impact is lower than other unbounded Maps because entries have a limited lifetime when accessed.

## Summary
The `DirectoryCache` used for caching channel directory entries has a TTL but no maximum size limit. Unlike other caches in the codebase (like dedupe cache), entries accumulate indefinitely as the gateway interacts with different channels and accounts.

## Steps to reproduce
1. Run the gateway with multiple channels and accounts
2. Send messages to various users and groups across channels
3. Monitor memory usage growing over time as directory entries accumulate
4. TTL only triggers deletion on READ; entries that are set but never read again persist

## Expected behavior
The cache should have a maximum size limit with LRU eviction, similar to the dedupe cache.

## Actual behavior
The cache has TTL but no max size. Long-running gateways accumulate entries proportional to the number of unique targets contacted.

### Affected code location:
**File** (`src/infra/outbound/target-resolver.ts:44`):
```typescript
const CACHE_TTL_MS = 30 * 60 * 1000;
const directoryCache = new DirectoryCache<ChannelDirectoryEntry[]>(CACHE_TTL_MS);
```

**File** (`src/infra/outbound/directory-cache.ts:22-41`):
```typescript
export class DirectoryCache<T> {
  private readonly cache = new Map<string, CacheEntry<T>>();
  private lastConfigRef: OpenClawConfig | null = null;

  constructor(private readonly ttlMs: number) {}

  get(key: string, cfg: OpenClawConfig): T | undefined {
    this.resetIfConfigChanged(cfg);
    const entry = this.cache.get(key);
    if (!entry) return undefined;
    if (Date.now() - entry.fetchedAt > this.ttlMs) {
      this.cache.delete(key);  // Only deletes on access, not proactively
      return undefined;
    }
    return entry.value;
  }

  set(key: string, value: T, cfg: OpenClawConfig): void {
    this.resetIfConfigChanged(cfg);
    this.cache.set(key, { value, fetchedAt: Date.now() });  // No size check
  }
  // No max size enforcement anywhere
}
```

**Existing mitigations:**
- `resetIfConfigChanged()` clears cache when config object changes (lines 55-59)
- TTL cleanup on read access (lines 32-34)

## Environment
- Version: latest (main branch)
- OS: Any
- Install method: Any

## Logs or screenshots
N/A - issue is architectural

## Impact
- **Memory Exhaustion**: Each `ChannelDirectoryEntry[]` can contain hundreds of records
- **Scale**: With 10+ channels, multiple accounts, users/groups, cache/live variants, entries multiply
- **Unpredictable**: Memory growth depends on interaction patterns, hard to predict

## Recommended fix
Add max size enforcement similar to the dedupe cache:
```typescript
export class DirectoryCache<T> {
  private readonly cache = new Map<string, CacheEntry<T>>();
  private readonly maxSize: number;

  constructor(private readonly ttlMs: number, maxSize = 10000) {
    this.maxSize = maxSize;
  }

  set(key: string, value: T, cfg: OpenClawConfig): void {
    this.resetIfConfigChanged(cfg);
    // Evict oldest entries if at capacity
    if (this.cache.size >= this.maxSize) {
      const oldest = this.findOldestEntry();
      if (oldest) this.cache.delete(oldest);
    }
    this.cache.set(key, { value, fetchedAt: Date.now() });
  }
}
```

## Comments

### @coygeek (2026-02-01)

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.2 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)



## Links

- None detected yet
