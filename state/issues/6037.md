---
number: 6037
title: "[Bug]: Followup Queue Map Orphans Entries for Disconnected Sessions"
author: coygeek
created: 2026-02-01T06:40:41Z
updated: 2026-02-02T00:16:48Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6037
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 4.3 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L)


## Summary

The auto-reply module maintains a process-wide `FOLLOWUP_QUEUES` Map that stores queue state per session key. When sessions end abnormally (client disconnect, network error, process restart), the queue entries are not cleaned up. Cleanup only happens when queues are explicitly drained empty or when the `/stop` command triggers an abort flow, leaving orphaned entries for abnormally terminated sessions.

## Affected Code

**File:** `src/auto-reply/reply/queue/state.ts:20`
```typescript
export const FOLLOWUP_QUEUES = new Map<string, FollowupQueueState>();
```

**File:** `src/auto-reply/reply/queue/state.ts:37-56`
```typescript
export function getFollowupQueue(key: string, settings: QueueSettings): FollowupQueueState {
  const existing = FOLLOWUP_QUEUES.get(key);
  if (existing) {
    return existing;
  }
  const created: FollowupQueueState = {
    items: [],
    draining: false,
    lastEnqueuedAt: 0,
    // ... other fields
  };
  FOLLOWUP_QUEUES.set(key, created);  // Created on first access
  return created;
}
```

**File:** `src/auto-reply/reply/queue/drain.ts:129`
```typescript
// Only deleted when queue is explicitly drained empty
FOLLOWUP_QUEUES.delete(key);
```

**File:** `src/auto-reply/reply/queue/state.ts:74`
```typescript
// clearFollowupQueue only called by abort flow (/stop), not on session disconnect
FOLLOWUP_QUEUES.delete(cleaned);
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [ ] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [ ] None (unauthenticated/public access)
- [x] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Messaging channel sessions (Telegram, Discord, Slack, WhatsApp) that use followup queuing

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Messaging sessions that disconnect abnormally (network drops, client closes without graceful shutdown)

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data disclosure |
| Integrity | None | No data modification |
| Availability | Low | Memory growth proportional to abnormal session terminations |

## Steps to Reproduce

1. Start OpenClaw with a messaging channel (e.g., Telegram)
2. Begin a conversation that triggers followup queue creation
3. Disconnect abruptly (kill client, network interruption) without using `/stop`
4. The session's queue entry remains in `FOLLOWUP_QUEUES`
5. Repeat with different session keys to accumulate orphaned entries
6. Monitor memory usage showing growth from orphaned FollowupQueueState objects

## Recommended Fix

Add session-end cleanup hook or TTL-based pruning:

```typescript
// Option 1: Add idle timeout pruning
setInterval(() => {
  const maxIdleMs = 24 * 60 * 60 * 1000; // 24 hours
  const now = Date.now();
  for (const [key, state] of FOLLOWUP_QUEUES) {
    if (state.items.length === 0 && now - state.lastEnqueuedAt > maxIdleMs) {
      FOLLOWUP_QUEUES.delete(key);
    }
  }
}, 60 * 60 * 1000); // Check hourly

// Option 2: Register cleanup on session end event
onSessionEnd((sessionKey) => {
  FOLLOWUP_QUEUES.delete(sessionKey);
});
```

## References

- **CWE:** [CWE-770](https://cwe.mitre.org/data/definitions/770.html) - Allocation of Resources Without Limits or Throttling
- **Related:** Similar pattern to other orphaned cache issues in the codebase

## Comments


## Links

- None detected yet
