---
number: 5264
title: "[Bug]: Command queue lanes Map grows unbounded causing memory exhaustion"
author: coygeek
created: 2026-01-31T07:57:26Z
updated: 2026-02-02T00:19:47Z
labels: ["bug"]
assignees: []
comments_count: 1
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/5264
duplicate_of: null
related_issues: []
blocks: []
blocked_by: []
---

## Description


## Summary

**Severity:** P1/High (Score: 80/150)
**CWE:** [CWE-770](https://cwe.mitre.org/data/definitions/770.html) - Allocation of Resources Without Limits or Throttling
**OWASP:** [A05:2021](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/) - Security Misconfiguration
**File:** `src/process/command-queue.ts:26`

The command queue's `lanes` Map accumulates entries for each unique session without cleanup, causing memory to grow indefinitely until OOM in long-running processes.

**Why this is P1:** Production gateways handling many sessions will eventually crash with OOM, causing data loss for in-flight commands and service downtime.

## Triage Assessment

| Factor | Value | Score |
|--------|-------|-------|
| **Reachability** | Automatic via normal session handling | 25/40 |
| **Impact** | Denial of service via OOM crash | 25/50 |
| **Exploitability** | Gradual accumulation over days/weeks | 15/30 |
| **Verification** | file:line ✓, code ✓, attack steps ✓ | 15/30 |
| **Total** | — | **80/150** |

## Steps to reproduce

1. Run the gateway for extended periods handling many sessions
2. Each session creates a unique lane key (e.g., `session:telegram:123456`)
3. Monitor memory usage growing over time with `process.memoryUsage()`
4. Eventually process crashes with OOM

## Expected behavior

Lane entries should be cleaned up when sessions end, or have a TTL/max size limit.

## Actual behavior

Lane entries are created but never removed. The `clearCommandLane()` function only clears the queue within a lane, not the lane entry itself.

### Affected code location:
**File** (`src/process/command-queue.ts:26`):
```typescript
const lanes = new Map<string, LaneState>();

function getLaneState(lane: string): LaneState {
  const existing = lanes.get(lane);
  if (existing) return existing;
  const created: LaneState = {
    lane,
    queue: [],
    active: 0,
    maxConcurrent: 1,
    draining: false,
  };
  lanes.set(lane, created);  // Added but never removed
  return created;
}
```

**File** (`src/agents/pi-embedded-runner/lanes.ts:5`):
```typescript
export function resolveSessionLane(key: string) {
  const cleaned = key.trim() || CommandLane.Main;
  return cleaned.startsWith("session:") ? cleaned : `session:${cleaned}`;  // Dynamic lane per session
}
```

## Environment

- Version: latest (main branch)
- OS: Any
- Install method: Any

## Logs or screenshots

N/A - issue is in code logic

## Impact

- **Service degradation**: Memory pressure causes slowdowns and GC pauses
- **Crash**: OOM kill after days/weeks of operation
- **Data loss**: In-flight commands lost on crash
- **Unpredictable failures**: Crash timing depends on session volume

## Recommended fix

1. **Add `removeLane(lane: string)` function**: Delete completed session lanes explicitly
2. **Implement TTL-based eviction**: Remove lanes inactive for N minutes
3. **Add max lane count with LRU eviction**: Prevent unbounded growth
4. **Call cleanup when sessions terminate**: Hook into session lifecycle
5. **Add monitoring**: Expose lane count metric for alerting

## Comments

### @coygeek (2026-02-01)

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.2 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)



## Links

- None detected yet
