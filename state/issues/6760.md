---
number: 6760
title: "[Bug]: Remote skills node cache grows unbounded without cleanup"
author: coygeek
created: 2026-02-02T01:33:04Z
updated: 2026-02-02T02:57:13Z
labels: ["bug"]
assignees: []
comments_count: 0
reactions_total: 0
url: https://github.com/openclaw/openclaw/issues/6760
duplicate_of: null
related_issues: [4949,6021,6022,6609]
blocks: []
blocked_by: []
---

## Description

## CVSS Assessment

| Metric | Value |
|--------|-------|
| **Score** | 6.5 / 10.0 |
| **Severity** | Medium |
| **Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H |

> [CVSS v3.1 Calculator](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)


## Summary

The `remoteNodes` Map in the skills-remote module caches node metadata when nodes connect but never removes entries when nodes disconnect, causing memory exhaustion in environments with frequent node churn.

## Affected Code

**File:** `src/infra/skills-remote.ts:21`

```typescript
const remoteNodes = new Map<string, RemoteNodeRecord>();

function upsertNode(record: {
  nodeId: string;
  displayName?: string;
  // ...
}) {
  const existing = remoteNodes.get(record.nodeId);
  // ... merge logic
  remoteNodes.set(record.nodeId, { ... });  // Added, never removed
}

export function recordRemoteNodeInfo(node: { nodeId: string; ... }) {
  upsertNode(node);  // Called when nodes connect
}
```

## Attack Surface

**How is this reached?**
- [x] Network (HTTP/WebSocket endpoint, API call)
- [ ] Adjacent Network (same LAN, requires network proximity)
- [ ] Local (local file, CLI argument, environment variable)
- [ ] Physical (requires physical access to machine)

**Authentication required?**
- [ ] None (unauthenticated/public access)
- [x] Low (any authenticated user)
- [ ] High (admin/privileged user only)

**Entry point:** Node registration when remote skill nodes connect to the gateway. Connection requires authentication via `authorizeGatewayConnect()` or device token verification at `src/gateway/server/ws-connection/message-handler.ts:570-590`.

## Exploit Conditions

**Complexity:**
- [x] Low (no special conditions, works reliably)
- [ ] High (requires race condition, specific config, or timing)

**User interaction:**
- [x] None (automatic, no victim action needed)
- [ ] Required (victim must click, visit, or perform action)

**Prerequisites:** Gateway must accept remote skill node connections. Attacker needs valid authentication credentials.

## Impact Assessment

**Scope:**
- [x] Unchanged (impact limited to vulnerable component)
- [ ] Changed (can affect other components, escape sandbox)

**What can an attacker do?**

| Impact Type | Level | Description |
|-------------|-------|-------------|
| Confidentiality | None | No data disclosure |
| Integrity | None | No data modification |
| Availability | High | Memory exhaustion from stale node entries |

## Steps to Reproduce

1. Run a gateway that accepts remote skill nodes
2. Have ephemeral nodes connect and disconnect (CI/CD runners, temporary containers)
3. Each unique node ID creates a permanent cache entry
4. Node records include `Set<string>` of binary paths, increasing memory per entry
5. Over weeks of operation, stale entries accumulate
6. Eventually memory exhaustion occurs

## Recommended Fix

Add node removal when disconnection is detected. Modify `src/gateway/server/ws-connection.ts` to call a new cleanup function:

```typescript
// In skills-remote.ts, add:
export function removeRemoteNodeInfo(nodeId: string): void {
  remoteNodes.delete(nodeId);
}

// In ws-connection.ts around line 199, add after unregister:
if (nodeId) {
  removeRemoteNodeInfo(nodeId);
  context.nodeUnsubscribeAll(nodeId);
}
```

Alternatively, implement TTL-based pruning for nodes that haven't been seen recently:

```typescript
interface RemoteNodeRecord {
  // ... existing fields
  lastSeen: number;
}

function pruneStaleNodes(): void {
  const staleThreshold = Date.now() - (24 * 60 * 60 * 1000);  // 24 hours
  for (const [nodeId, record] of remoteNodes) {
    if (record.lastSeen < staleThreshold) {
      remoteNodes.delete(nodeId);
    }
  }
}
```

## References

- **CWE:** [CWE-401](https://cwe.mitre.org/data/definitions/401.html) - Missing Release of Memory after Effective Lifetime
- **Related (CWE-401):** #6609, #4949, #6021, #6022

## Comments


## Links

- None detected yet
